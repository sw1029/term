{
  "model_name": "google/gemma-2-2b-it",
  "layer_idx": 12,
  "command": "main.py sae.loss_option=3 sae.loss_module=option3_loss experiment.use_multi_contrast=true sae.guidance_method=contrastive sae.use_l0=false",
  "sae": {
    "input_dim": 2304,
    "sae_dim": 9216,
    "fixed_v_cnt": 0,
    "batch_size": 4,
    "epochs": 2,
    "max_steps": 2000,
    "l1_coeff": 0.005,
    "l0_coeff": 0.0,
    "use_l0": false,
    "concept_samples_per_label": 100,
    "loss_option": 3,
    "loss_module": "option3_loss",
    "concept_feature_indices": {
      "code": 0,
      "harm": 1,
      "struct": 2
    },
    "alpha_concept": {
      "code": 0.0,
      "harm": 0.0,
      "struct": 0.0
    },
    "positive_targets": {
      "code": 1,
      "harm": 1,
      "struct": 1
    },
    "guidance_method": "contrastive",
    "guidance_margin": 0.0,
    "guidance_coeff": 1.0,
    "guidance_mse_pos_value": 1.0,
    "guidance_mse_neg_value": 0.0,
    "jumprelu_bandwidth": 0.001,
    "jumprelu_init_threshold": 0.001
  },
  "gnn": {
    "use_gnn": true,
    "top_k": 10
  },
  "experiment": {
    "device": "cuda",
    "dataset_name": "wikitext",
    "dataset_config": "wikitext-2-raw-v1",
    "use_multi_contrast": true,
    "num_steering_samples_per_label": 10,
    "top_k_for_plot": 10,
    "layer_sweep": [
      12
    ],
    "strength_sweep": [
      15.0
    ]
  },
  "steering": {
    "label": "code",
    "feature_idx": 0,
    "strength": 15.0
  },
  "prompt": "#!/bin/env python\r\n#==========================================================================\r\n# (c) 2004-2005  Total Phase, Inc.\r\n#--------------------------------------------------------------------------\r\n# Project : Aardvark Sample Code\r\n# File    : aamonitor_filtered.py\r\n#--------------------------------------------------------------------------\r\n# Perform I2C monitoring functions with the Aardvark I2C/SPI adapter with\r\n# the ability to filter the data based on slave address.\r\n#--------------------------------------------------------------------------\r\n# Redistribution and use of this file in source and binary forms, with\r\n# or without modification, are permitted.\r\n#\r\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\r\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE\r\n# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\r\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\r\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\r\n# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n# POSSIBILITY OF SUCH DAMAGE.\r\n#==========================================================================\r\n\r\n#==========================================================================\r\n# IMPORTS\r\n#==========================================================================\r\nimport sys, time\r\n\r\nfrom aardvark_py import *\r\n\r\n\r\n#==========================================================================\r\n# CONSTANTS\r\n#==========================================================================\r\nBUFFER_SIZE = 32767\r\n\r\nTIMEFORMAT  = \"%Y-%m-%d %H:%M:%S\"\r\n\r\n#==========================================================================\r\n# FUNCTIONS\r\n#==========================================================================\r\ndef dump (handle, filter_addr, timeout):\r\n    # Wait for data on the bus\r\n    print \"Waiting %d ms for first transaction...\" % timeout\r\n    print \"  Filtering on 0x%03x\" % filter_addr\r\n    result = aa_async_poll(handle, timeout)\r\n    if (result == AA_ASYNC_NO_DATA):\r\n        print \"  no data pending.\"\r\n        return\r\n\r\n    print \"  data received\"\r\n    \r\n    last_data0 = 0\r\n    last_data1 = 0\r\n\r\n    # Loop until aa_async_poll times out\r\n    while 1:\r\n        # Read the next monitor transaction.\r\n        # This function has an internal timeout (see datasheet), though\r\n        # since we have already checked for data using aa_async_poll,\r\n        # the timeout should never be exercised.\r\n        (status, data) = aa_i2c_monitor_read(handle, BUFFER_SIZE)\r\n        \r\n        if (status < 0):\r\n            print \"error: %s\" % aa_status_string(status)\r\n            return\r\n        \r\n        # The display flag indicates if the filtered address has been matched\r\n        # and the data should be displayed.\r\n        display        = 0\r\n        \r\n        # The display_buffer is used to hold the start condition because it\r\n        # is sent before the address is known, so the output needs to be \r\n        # cached to display later.\r\n        display_buffer = \"\"\r\n        \r\n        for i in range(len(data)):\r\n            if (data[i] == AA_I2C_MONITOR_CMD_START):\r\n                # Generate a timestamp.  This time stamp does not accurately\r\n                # reflect the actual time that the transaction occurred, but \r\n                # is generated to give the user a relative time for the \r\n                # transaction.\r\n                fmtstamp = time.strftime(TIMEFORMAT, time.localtime(time.time()))\r\n                \r\n                # Cache the start condition\r\n                display_buffer = \"\\n%s : [S] \" % fmtstamp\r\n\r\n            elif (data[i] == AA_I2C_MONITOR_CMD_STOP):\r\n                if display:\r\n                    sys.stdout.write(\"[P]\\n\")\r\n                # After a stop condition, reset the display flag for \r\n                # next message\r\n                display = 0\r\n\r\n            else:\r\n                nack = (data[i] & AA_I2C_MONITOR_NACK)\r\n                if nack:  nack_str = \"*\"\r\n                else:     nack_str = \"\"\r\n                \r\n                # 7-bit addresses\r\n                if (last_data0 == AA_I2C_MONITOR_CMD_START and\r\n                    ((data[i] & 0xf8) != 0xf0 or nack)):\r\n                        \r\n                    # Test to see if 7-bit address matches\r\n                    if ((data[i] & 0xff) >> 1 == filter_addr):\r\n                        # If the address matches, the set display to 1\r\n                        display = 1\r\n                        # Write out the start condition\r\n                        sys.stdout.write(display_buffer)\r\n                        # And reset the buffer\r\n                        display_buffer = \"\"\r\n                        \r\n                        # Now process regularly\r\n                        if (data[i] & 0x01): dir_str = \"r\"\r\n                        else:                dir_str = \"w\"\r\n                        sys.stdout.write(\"<%02x:%s>%s \" %\r\n                            ((data[i] & 0xff) >> 1,\r\n                            dir_str,\r\n                            nack_str\r\n                            ))\r\n\r\n                # 10-bit addresses\r\n                # See Philips specification for more details.\r\n                elif (last_data1 == AA_I2C_MONITOR_CMD_START and\r\n                     (last_data0 & 0xf8) == 0xf0):\r\n\r\n                    # Test to see if 10-bit address matches\r\n                    if (((last_data0 << 7) & 0x300) | (data[i] & 0xff)) == filter_addr:\r\n                        \r\n                        # If the address matches, the set display to 1\r\n                        display = 1\r\n                        # Write out the start condition\r\n                        sys.stdout.write(display_buffer)\r\n                        # Reset the buffer\r\n                        display_buffer = \"\"\r\n                        \r\n                        if (last_data0 & 0x01): dir_str = \"r\"\r\n                        else:                   dir_str = \"w\"\r\n                        sys.stdout.write(\"<%03x:%s>%s \" %\r\n                            (((last_data0 << 7) & 0x300) | (data[i] & 0xff),\r\n                            dir_str,\r\n                            nack_str\r\n                            ))\r\n\r\n                # Normal data\r\n                elif (last_data0 != AA_I2C_MONITOR_CMD_START):\r\n                    if display:\r\n                        sys.stdout.write(\"%02x%s \" % (data[i] & 0xff, nack_str))\r\n\r\n            last_data1 = last_data0\r\n            last_data0 = data[i]\r\n            sys.stdout.flush()\r\n\r\n        # print \"\\nWaiting %d ms for subsequent transaction...\" % INTERVAL_TIMEOUT\r\n\r\n        # Use aa_async_poll to wait for the next transaction\r\n        result = aa_async_poll(handle, timeout)\r\n        if (result == AA_ASYNC_NO_DATA):\r\n            print \"  No more data pending.\"\r\n            break\r\n            \r\n\r\n#==========================================================================\r\n# MAIN PROGRAM\r\n#==========================================================================\r\nif (len(sys.argv) < 4):\r\n    print \"usage: aamonitor PORT ADDR TIMEOUT\"\r\n    print \"  where:\"\r\n    print \"    PORT    is the Aardvark adapter port number\"\r\n    print \"    ADDR    is the slave address as an integer\"\r\n    print \"    TIMEOUT is the timeout interval in ms\"\r\n    sys.exit()\r\n\r\nport        = int(sys.argv[1])\r\nfilter_addr = int(sys.argv[2], 0)\r\ntimeout     = int(sys.argv[3])\r\n\r\n# Open the device\r\nhandle = aa_open(port)\r\nif (handle <= 0):\r\n    print \"Unable to open Aardvark device on port %d\" % port\r\n    print \"Error code = %d\" % handle\r\n    sys.exit()\r\n    \r\n# Ensure that the I2C subsystem is enabled\r\naa_configure(handle,  AA_CONFIG_SPI_I2C)\r\n    \r\n# Disable the I2C bus pullup resistors (2.2k resistors).\r\n# This command is only effective on v2.0 hardware or greater.\r\n# The pullup resistors on the v1.02 hardware are enabled by default.\r\naa_i2c_pullup(handle, AA_I2C_PULLUP_NONE)\r\n\r\n# Disable the Aardvark adapter's power pins.\r\n# This command is only effective on v2.0 hardware or greater.\r\n# The power pins on the v1.02 hardware are not enabled by default.\r\naa_target_power(handle, AA_TARGET_POWER_NONE)\r\n\r\n# Enable the monitor\r\nresult = aa_i2c_monitor_enable(handle)\r\nif (result < 0):\r\n    print \"error: %s\\n\" % aa_status_string(result)\r\n    sys.exit()\r\n    \r\nprint \"Enabled I2C monitor.\"\r\n\r\n# Watch the I2C port\r\ndump(handle, filter_addr, timeout)\r\n\r\n# Disable the slave and close the device\r\naa_i2c_monitor_disable(handle)\r\naa_close(handle)\r\n",
  "output": {
    "before": "#!/bin/env python\r\n#==========================================================================\r\n# (c) 2004-2005  Total Phase, Inc.\r\n#--------------------------------------------------------------------------\r\n# Project : Aardvark Sample Code\r\n# File    : aamonitor_filtered.py\r\n#--------------------------------------------------------------------------\r\n# Perform I2C monitoring functions with the Aardvark I2C/SPI adapter with\r\n# the ability to filter the data based on slave address.\r\n#--------------------------------------------------------------------------\r\n# Redistribution and use of this file in source and binary forms, with\r\n# or without modification, are permitted.\r\n#\r\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\r\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE\r\n# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\r\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\r\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\r\n# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n# POSSIBILITY OF SUCH DAMAGE.\r\n#==========================================================================\r\n\r\n#==========================================================================\r\n# IMPORTS\r\n#==========================================================================\r\nimport sys, time\r\n\r\nfrom aardvark_py import *\r\n\r\n\r\n#==========================================================================\r\n# CONSTANTS\r\n#==========================================================================\r\nBUFFER_SIZE = 32767\r\n\r\nTIMEFORMAT  = \"%Y-%m-%d %H:%M:%S\"\r\n\r\n#==========================================================================\r\n# FUNCTIONS\r\n#==========================================================================\r\ndef dump (handle, filter_addr, timeout):\r\n    # Wait for data on the bus\r\n    print \"Waiting %d ms for first transaction...\" % timeout\r\n    print \"  Filtering on 0x%03x\" % filter_addr\r\n    result = aa_async_poll(handle, timeout)\r\n    if (result == AA_ASYNC_NO_DATA):\r\n        print \"  no data pending.\"\r\n        return\r\n\r\n    print \"  data received\"\r\n    \r\n    last_data0 = 0\r\n    last_data1 = 0\r\n\r\n    # Loop until aa_async_poll times out\r\n    while 1:\r\n        # Read the next monitor transaction.\r\n        # This function has an internal timeout (see datasheet), though\r\n        # since we have already checked for data using aa_async_poll,\r\n        # the timeout should never be exercised.\r\n        (status, data) = aa_i2c_monitor_read(handle, BUFFER_SIZE)\r\n        \r\n        if (status < 0):\r\n            print \"error: %s\" % aa_status_string(status)\r\n            return\r\n        \r\n        # The display flag indicates if the filtered address has been matched\r\n        # and the data should be displayed.\r\n        display        = 0\r\n        \r\n        # The display_buffer is used to hold the start condition because it\r\n        # is sent before the address is known, so the output needs to be \r\n        # cached to display later.\r\n        display_buffer = \"\"\r\n        \r\n        for i in range(len(data)):\r\n            if (data[i] == AA_I2C_MONITOR_CMD_START):\r\n                # Generate a timestamp.  This time stamp does not accurately\r\n                # reflect the actual time that the transaction occurred, but \r\n                # is generated to give the user a relative time for the \r\n                # transaction.\r\n                fmtstamp = time.strftime(TIMEFORMAT, time.localtime(time.time()))\r\n                \r\n                # Cache the start condition\r\n                display_buffer = \"\\n%s : [S] \" % fmtstamp\r\n\r\n            elif (data[i] == AA_I2C_MONITOR_CMD_STOP):\r\n                if display:\r\n                    sys.stdout.write(\"[P]\\n\")\r\n                # After a stop condition, reset the display flag for \r\n                # next message\r\n                display = 0\r\n\r\n            else:\r\n                nack = (data[i] & AA_I2C_MONITOR_NACK)\r\n                if nack:  nack_str = \"*\"\r\n                else:     nack_str = \"\"\r\n                \r\n                # 7-bit addresses\r\n                if (last_data0 == AA_I2C_MONITOR_CMD_START and\r\n                    ((data[i] & 0xf8) != 0xf0 or nack)):\r\n                        \r\n                    # Test to see if 7-bit address matches\r\n                    if ((data[i] & 0xff) >> 1 == filter_addr):\r\n                        # If the address matches, the set display to 1\r\n                        display = 1\r\n                        # Write out the start condition\r\n                        sys.stdout.write(display_buffer)\r\n                        # And reset the buffer\r\n                        display_buffer = \"\"\r\n                        \r\n                        # Now process regularly\r\n                        if (data[i] & 0x01): dir_str = \"r\"\r\n                        else:                dir_str = \"w\"\r\n                        sys.stdout.write(\"<%02x:%s>%s \" %\r\n                            ((data[i] & 0xff) >> 1,\r\n                            dir_str,\r\n                            nack_str\r\n                            ))\r\n\r\n                # 10-bit addresses\r\n                # See Philips specification for more details.\r\n                elif (last_data1 == AA_I2C_MONITOR_CMD_START and\r\n                     (last_data0 & 0xf8) == 0xf0):\r\n\r\n                    # Test to see if 10-bit address matches\r\n                    if (((last_data0 << 7) & 0x300) | (data[i] & 0xff)) == filter_addr:\r\n                        \r\n                        # If the address matches, the set display to 1\r\n                        display = 1\r\n                        # Write out the start condition\r\n                        sys.stdout.write(display_buffer)\r\n                        # Reset the buffer\r\n                        display_buffer = \"\"\r\n                        \r\n                        if (last_data0 & 0x01): dir_str = \"r\"\r\n                        else:                   dir_str = \"w\"\r\n                        sys.stdout.write(\"<%03x:%s>%s \" %\r\n                            (((last_data0 << 7) & 0x300) | (data[i] & 0xff),\r\n                            dir_str,\r\n                            nack_str\r\n                            ))\r\n\r\n                # Normal data\r\n                elif (last_data0 != AA_I2C_MONITOR_CMD_START):\r\n                    if display:\r\n                        sys.stdout.write(\"%02x%s \" % (data[i] & 0xff, nack_str))\r\n\r\n            last_data1 = last_data0\r\n            last_data0 = data[i]\r\n            sys.stdout.flush()\r\n\r\n        # print \"\\nWaiting %d ms for subsequent transaction...\" % INTERVAL_TIMEOUT\r\n\r\n        # Use aa_async_poll to wait for the next transaction\r\n        result = aa_async_poll(handle, timeout)\r\n        if (result == AA_ASYNC_NO_DATA):\r\n            print \"  No more data pending.\"\r\n            break\r\n            \r\n\r\n#==========================================================================\r\n# MAIN PROGRAM\r\n#==========================================================================\r\nif (len(sys.argv) < 4):\r\n    print \"usage: aamonitor PORT ADDR TIMEOUT\"\r\n    print \"  where:\"\r\n    print \"    PORT    is the Aardvark adapter port number\"\r\n    print \"    ADDR    is the slave address as an integer\"\r\n    print \"    TIMEOUT is the timeout interval in ms\"\r\n    sys.exit()\r\n\r\nport        = int(sys.argv[1])\r\nfilter_addr = int(sys.argv[2], 0)\r\ntimeout     = int(sys.argv[3])\r\n\r\n# Open the device\r\nhandle = aa_open(port)\r\nif (handle <= 0):\r\n    print \"Unable to open Aardvark device on port %d\" % port\r\n    print \"Error code = %d\" % handle\r\n    sys.exit()\r\n    \r\n# Ensure that the I2C subsystem is enabled\r\naa_configure(handle,  AA_CONFIG_SPI_I2C)\r\n    \r\n# Disable the I2C bus pullup resistors (2.2k resistors).\r\n# This command is only effective on v2.0 hardware or greater.\r\n# The pullup resistors on the v1.02 hardware are enabled by default.\r\naa_i2c_pullup(handle, AA_I2C_PULLUP_NONE)\r\n\r\n# Disable the Aardvark adapter's power pins.\r\n# This command is only effective on v2.0 hardware or greater.\r\n# The power pins on the v1.02 hardware are not enabled by default.\r\naa_target_power(handle, AA_TARGET_POWER_NONE)\r\n\r\n# Enable the monitor\r\nresult = aa_i2c_monitor_enable(handle)\r\nif (result < 0):\r\n    print \"error: %s\\n\" % aa_status_string(result)\r\n    sys.exit()\r\n    \r\nprint \"Enabled I2C monitor.\"\r\n\r\n# Watch the I2C port\r\ndump(handle, filter_addr, timeout)\r\n\r\n# Disable the slave and close the device\r\naa_i2c_monitor_disable(handle)\r\naa_close(handle)\r\nsys.exit()\n",
    "after": "#!/bin/env python\r\n#==========================================================================\r\n# (c) 2004-2005  Total Phase, Inc.\r\n#--------------------------------------------------------------------------\r\n# Project : Aardvark Sample Code\r\n# File    : aamonitor_filtered.py\r\n#--------------------------------------------------------------------------\r\n# Perform I2C monitoring functions with the Aardvark I2C/SPI adapter with\r\n# the ability to filter the data based on slave address.\r\n#--------------------------------------------------------------------------\r\n# Redistribution and use of this file in source and binary forms, with\r\n# or without modification, are permitted.\r\n#\r\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\r\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE\r\n# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\r\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\r\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\r\n# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n# POSSIBILITY OF SUCH DAMAGE.\r\n#==========================================================================\r\n\r\n#==========================================================================\r\n# IMPORTS\r\n#==========================================================================\r\nimport sys, time\r\n\r\nfrom aardvark_py import *\r\n\r\n\r\n#==========================================================================\r\n# CONSTANTS\r\n#==========================================================================\r\nBUFFER_SIZE = 32767\r\n\r\nTIMEFORMAT  = \"%Y-%m-%d %H:%M:%S\"\r\n\r\n#==========================================================================\r\n# FUNCTIONS\r\n#==========================================================================\r\ndef dump (handle, filter_addr, timeout):\r\n    # Wait for data on the bus\r\n    print \"Waiting %d ms for first transaction...\" % timeout\r\n    print \"  Filtering on 0x%03x\" % filter_addr\r\n    result = aa_async_poll(handle, timeout)\r\n    if (result == AA_ASYNC_NO_DATA):\r\n        print \"  no data pending.\"\r\n        return\r\n\r\n    print \"  data received\"\r\n    \r\n    last_data0 = 0\r\n    last_data1 = 0\r\n\r\n    # Loop until aa_async_poll times out\r\n    while 1:\r\n        # Read the next monitor transaction.\r\n        # This function has an internal timeout (see datasheet), though\r\n        # since we have already checked for data using aa_async_poll,\r\n        # the timeout should never be exercised.\r\n        (status, data) = aa_i2c_monitor_read(handle, BUFFER_SIZE)\r\n        \r\n        if (status < 0):\r\n            print \"error: %s\" % aa_status_string(status)\r\n            return\r\n        \r\n        # The display flag indicates if the filtered address has been matched\r\n        # and the data should be displayed.\r\n        display        = 0\r\n        \r\n        # The display_buffer is used to hold the start condition because it\r\n        # is sent before the address is known, so the output needs to be \r\n        # cached to display later.\r\n        display_buffer = \"\"\r\n        \r\n        for i in range(len(data)):\r\n            if (data[i] == AA_I2C_MONITOR_CMD_START):\r\n                # Generate a timestamp.  This time stamp does not accurately\r\n                # reflect the actual time that the transaction occurred, but \r\n                # is generated to give the user a relative time for the \r\n                # transaction.\r\n                fmtstamp = time.strftime(TIMEFORMAT, time.localtime(time.time()))\r\n                \r\n                # Cache the start condition\r\n                display_buffer = \"\\n%s : [S] \" % fmtstamp\r\n\r\n            elif (data[i] == AA_I2C_MONITOR_CMD_STOP):\r\n                if display:\r\n                    sys.stdout.write(\"[P]\\n\")\r\n                # After a stop condition, reset the display flag for \r\n                # next message\r\n                display = 0\r\n\r\n            else:\r\n                nack = (data[i] & AA_I2C_MONITOR_NACK)\r\n                if nack:  nack_str = \"*\"\r\n                else:     nack_str = \"\"\r\n                \r\n                # 7-bit addresses\r\n                if (last_data0 == AA_I2C_MONITOR_CMD_START and\r\n                    ((data[i] & 0xf8) != 0xf0 or nack)):\r\n                        \r\n                    # Test to see if 7-bit address matches\r\n                    if ((data[i] & 0xff) >> 1 == filter_addr):\r\n                        # If the address matches, the set display to 1\r\n                        display = 1\r\n                        # Write out the start condition\r\n                        sys.stdout.write(display_buffer)\r\n                        # And reset the buffer\r\n                        display_buffer = \"\"\r\n                        \r\n                        # Now process regularly\r\n                        if (data[i] & 0x01): dir_str = \"r\"\r\n                        else:                dir_str = \"w\"\r\n                        sys.stdout.write(\"<%02x:%s>%s \" %\r\n                            ((data[i] & 0xff) >> 1,\r\n                            dir_str,\r\n                            nack_str\r\n                            ))\r\n\r\n                # 10-bit addresses\r\n                # See Philips specification for more details.\r\n                elif (last_data1 == AA_I2C_MONITOR_CMD_START and\r\n                     (last_data0 & 0xf8) == 0xf0):\r\n\r\n                    # Test to see if 10-bit address matches\r\n                    if (((last_data0 << 7) & 0x300) | (data[i] & 0xff)) == filter_addr:\r\n                        \r\n                        # If the address matches, the set display to 1\r\n                        display = 1\r\n                        # Write out the start condition\r\n                        sys.stdout.write(display_buffer)\r\n                        # Reset the buffer\r\n                        display_buffer = \"\"\r\n                        \r\n                        if (last_data0 & 0x01): dir_str = \"r\"\r\n                        else:                   dir_str = \"w\"\r\n                        sys.stdout.write(\"<%03x:%s>%s \" %\r\n                            (((last_data0 << 7) & 0x300) | (data[i] & 0xff),\r\n                            dir_str,\r\n                            nack_str\r\n                            ))\r\n\r\n                # Normal data\r\n                elif (last_data0 != AA_I2C_MONITOR_CMD_START):\r\n                    if display:\r\n                        sys.stdout.write(\"%02x%s \" % (data[i] & 0xff, nack_str))\r\n\r\n            last_data1 = last_data0\r\n            last_data0 = data[i]\r\n            sys.stdout.flush()\r\n\r\n        # print \"\\nWaiting %d ms for subsequent transaction...\" % INTERVAL_TIMEOUT\r\n\r\n        # Use aa_async_poll to wait for the next transaction\r\n        result = aa_async_poll(handle, timeout)\r\n        if (result == AA_ASYNC_NO_DATA):\r\n            print \"  No more data pending.\"\r\n            break\r\n            \r\n\r\n#==========================================================================\r\n# MAIN PROGRAM\r\n#==========================================================================\r\nif (len(sys.argv) < 4):\r\n    print \"usage: aamonitor PORT ADDR TIMEOUT\"\r\n    print \"  where:\"\r\n    print \"    PORT    is the Aardvark adapter port number\"\r\n    print \"    ADDR    is the slave address as an integer\"\r\n    print \"    TIMEOUT is the timeout interval in ms\"\r\n    sys.exit()\r\n\r\nport        = int(sys.argv[1])\r\nfilter_addr = int(sys.argv[2], 0)\r\ntimeout     = int(sys.argv[3])\r\n\r\n# Open the device\r\nhandle = aa_open(port)\r\nif (handle <= 0):\r\n    print \"Unable to open Aardvark device on port %d\" % port\r\n    print \"Error code = %d\" % handle\r\n    sys.exit()\r\n    \r\n# Ensure that the I2C subsystem is enabled\r\naa_configure(handle,  AA_CONFIG_SPI_I2C)\r\n    \r\n# Disable the I2C bus pullup resistors (2.2k resistors).\r\n# This command is only effective on v2.0 hardware or greater.\r\n# The pullup resistors on the v1.02 hardware are enabled by default.\r\naa_i2c_pullup(handle, AA_I2C_PULLUP_NONE)\r\n\r\n# Disable the Aardvark adapter's power pins.\r\n# This command is only effective on v2.0 hardware or greater.\r\n# The power pins on the v1.02 hardware are not enabled by default.\r\naa_target_power(handle, AA_TARGET_POWER_NONE)\r\n\r\n# Enable the monitor\r\nresult = aa_i2c_monitor_enable(handle)\r\nif (result < 0):\r\n    print \"error: %s\\n\" % aa_status_string(result)\r\n    sys.exit()\r\n    \r\nprint \"Enabled I2C monitor.\"\r\n\r\n# Watch the I2C port\r\ndump(handle, filter_addr, timeout)\r\n\r\n# Disable the slave and close the device\r\naa_i2c_monitor_disable(handle)\r\naa_close(handle)\r\n\r\n# Print a message to confirm that the I2C monitor is no longer active.\r\nprint \"I2C monitor disabled.\"\r\n\r\n# Exit the program.\r\nsys.exit(0)\r\n```"
  },
  "feature_stats": {
    "indices": [
      0,
      9087,
      4139,
      3494,
      5518,
      5669,
      6750,
      7890,
      361,
      7048,
      6699
    ],
    "f_before": [
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "f_after": [
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "g_before": [
      0.0,
      0.0,
      0.0,
      0.018671024590730667,
      0.03190642222762108,
      0.0,
      0.0,
      0.0019491618731990457,
      0.0,
      0.0,
      0.0
    ],
    "g_after": [
      0.0,
      0.0,
      0.0,
      0.018671024590730667,
      0.03190642222762108,
      0.0,
      0.0,
      0.0019491618731990457,
      0.0,
      0.0,
      0.0
    ],
    "num_batches_for_stats": 10
  },
  "loss_summary": {
    "train_mean_loss": 8.356310415834189,
    "train_mean_l2": 5.661456496983766,
    "train_mean_l1": 2.6948540791869164,
    "num_steps": 2000,
    "num_batches": 2000
  },
  "feature_std_summary": {
    "plot_path": "outputs/plots/20251128-014034/feature_std_layer_12.html",
    "mean_std": 0.9815042614936829,
    "max_std": 25.413209915161133
  }
}