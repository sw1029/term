{
  "model_name": "google/gemma-2-2b-it",
  "layer_idx": 12,
  "command": "main.py sae.loss_option=1 sae.loss_module=option1_loss experiment.use_multi_contrast=true",
  "sae": {
    "input_dim": 2304,
    "sae_dim": 9216,
    "fixed_v_cnt": 3,
    "batch_size": 4,
    "epochs": 1,
    "max_steps": 1000,
    "concept_samples_per_label": 250,
    "loss_option": 1,
    "loss_module": "option1_loss"
  },
  "gnn": {
    "use_gnn": true,
    "top_k": 10
  },
  "steering": {
    "label": "code",
    "feature_idx": 0,
    "strength": 15.0
  },
  "prompt": "#!/usr/bin/python3\n# mari von steinkirch @2013\n# steinkirch at gmail\n\n\ndef find_edit_distance(str1, str2):\n\t''' computes the edit distance between two strings '''\n\tm = len(str1)\n\tn = len(str2)\n\tdiff = lambda c1, c2: 0 if c1 == c2 else 1\n\tE = [[0] * (n + 1) for i in range(m + 1)]\n\tfor i in range(m + 1):\n\t\tE[i][0] = i\n\tfor j in range(1, n + 1):\n\t\tE[0][j] = j\n\tfor i in range(1, m + 1):\n\t\tfor j in range(1, n + 1):\n\t\t\tE[i][j] = min(E[i-1][j] + 1, E[i][j-1] + 1, E[i-1][j-1] + diff(str1[i-1], str2[j-1]))\n\treturn E[m][n]\n\n\ndef test_find_edit_distance():\n    s = 'sunday'\n    t = 'saturday'\n    assert(find_edit_distance(s, t) == 3)\n    print('Tests passed!')\n\n\nif __name__ == '__main__':\n    test_find_edit_distance()\n\n\n\n\n",
  "output": {
    "before": "#!/usr/bin/python3\n# mari von steinkirch @2013\n# steinkirch at gmail\n\n\ndef find_edit_distance(str1, str2):\n\t''' computes the edit distance between two strings '''\n\tm = len(str1)\n\tn = len(str2)\n\tdiff = lambda c1, c2: 0 if c1 == c2 else 1\n\tE = [[0] * (n + 1) for i in range(m + 1)]\n\tfor i in range(m + 1):\n\t\tE[i][0] = i\n\tfor j in range(1, n + 1):\n\t\tE[0][j] = j\n\tfor i in range(1, m + 1):\n\t\tfor j in range(1, n + 1):\n\t\t\tE[i][j] = min(E[i-1][j] + 1, E[i][j-1] + 1, E[i-1][j-1] + diff(str1[i-1], str2[j-1]))\n\treturn E[m][n]\n\n\ndef test_find_edit_distance():\n    s = 'sunday'\n    t = 'saturday'\n    assert(find_edit_distance(s, t) == 3)\n    print('Tests passed!')\n\n\nif __name__ == '__main__':\n    test_find_edit_distance()\n\n\n\n\n```\n\n**Explanation:**\n\nThis Python code calculates the edit distance between two strings using dynamic programming. Here's a breakdown:\n\n**1. `find_edit_distance(str1, str2)` Function:**\n\n   - **Input",
    "after": "#!/usr/bin/python3\n# mari von steinkirch @2013\n# steinkirch at gmail\n\n\ndef find_edit_distance(str1, str2):\n\t''' computes the edit distance between two strings '''\n\tm = len(str1)\n\tn = len(str2)\n\tdiff = lambda c1, c2: 0 if c1 == c2 else 1\n\tE = [[0] * (n + 1) for i in range(m + 1)]\n\tfor i in range(m + 1):\n\t\tE[i][0] = i\n\tfor j in range(1, n + 1):\n\t\tE[0][j] = j\n\tfor i in range(1, m + 1):\n\t\tfor j in range(1, n + 1):\n\t\t\tE[i][j] = min(E[i-1][j] + 1, E[i][j-1] + 1, E[i-1][j-1] + diff(str1[i-1], str2[j-1]))\n\treturn E[m][n]\n\n\ndef test_find_edit_distance():\n    s = 'sunday'\n    t = 'saturday'\n    assert(find_edit_distance(s, t) == 3)\n    print('Tests passed!')\n\n\nif __name__ == '__main__':\n    test_find_edit_distance()\n\n\n\n\n# \n# This is a test\n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# "
  },
  "feature_stats": {
    "indices": [
      0,
      2,
      418,
      1641,
      5597,
      8372,
      4662,
      3238,
      3787,
      5933,
      3814
    ],
    "f_before": [
      0.0,
      0.0,
      0.0,
      0.03690101206302643,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "f_after": [
      0.0,
      0.0,
      0.0,
      0.03690101206302643,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "g_before": [
      0.0019347709603607655,
      9.794543266296387,
      0.0,
      0.02638408914208412,
      0.0,
      0.0,
      0.0,
      0.0,
      0.07055743038654327,
      0.0,
      0.0
    ],
    "g_after": [
      0.0019347709603607655,
      9.794543266296387,
      0.0,
      0.02638408914208412,
      0.0,
      0.0,
      0.0,
      0.0,
      0.07055743038654327,
      0.0,
      0.0
    ],
    "num_batches_for_stats": 10
  },
  "loss_summary": {
    "train_mean_loss": 15.652211345553399,
    "train_mean_l2": 11.55342114698887,
    "train_mean_l1": 4.098790381908417,
    "num_steps": 1000,
    "num_batches": 1000
  },
  "feature_std_summary": {
    "plot_path": "outputs/plots/20251126-175135/feature_std_layer_12.html",
    "mean_std": 1.074162483215332,
    "max_std": 22.999488830566406
  }
}