{
  "model_name": "google/gemma-2-2b-it",
  "layer_idx": 12,
  "command": "main.py sae.loss_option=1 sae.loss_module=option1_loss experiment.use_multi_contrast=true",
  "sae": {
    "input_dim": 2304,
    "sae_dim": 9216,
    "fixed_v_cnt": 3,
    "batch_size": 4,
    "epochs": 1,
    "max_steps": 1000,
    "concept_samples_per_label": 250,
    "loss_option": 1,
    "loss_module": "option1_loss"
  },
  "gnn": {
    "use_gnn": true,
    "top_k": 10
  },
  "steering": {
    "label": "code",
    "feature_idx": 0,
    "strength": 15.0
  },
  "prompt": "import numpy as np\nfrom PyQt5 import QtCore, QtGui, QtWidgets\nfrom sscanss.config import path_for, settings\nfrom sscanss.core.math import Plane, Matrix33, Vector3, clamp, map_range, trunc, VECTOR_EPS\nfrom sscanss.core.geometry import mesh_plane_intersection\nfrom sscanss.core.util import Primitives, DockFlag, StrainComponents, PointType, PlaneOptions, Attributes\nfrom sscanss.ui.widgets import (FormGroup, FormControl, GraphicsView, GraphicsScene, create_tool_button, FormTitle,\n                                create_scroll_area, CompareValidator, GraphicsPointItem, Grid, create_icon)\nfrom .managers import PointManager\n\n\nclass InsertPrimitiveDialog(QtWidgets.QWidget):\n    \"\"\"Provides UI for typing in measurement/fiducial points\n\n    :param primitive: primitive type\n    :type primitive: Primitives\n    :param parent: Main window\n    :type parent: MainWindow\n    \"\"\"\n    dock_flag = DockFlag.Upper\n\n    def __init__(self, primitive, parent):\n        super().__init__(parent)\n        self.parent = parent\n        self.parent_model = self.parent.presenter.model\n        self.parent.scenes.switchToSampleScene()\n        self.primitive = primitive\n\n        self.main_layout = QtWidgets.QVBoxLayout()\n\n        self.textboxes = {}\n        name = self.parent_model.uniqueKey(self.primitive.value)\n        self.mesh_args = {'name': name}\n        if self.primitive == Primitives.Tube:\n            self.mesh_args.update({'outer_radius': 100.000, 'inner_radius': 50.000, 'height': 200.000})\n        elif self.primitive == Primitives.Sphere:\n            self.mesh_args.update({'radius': 100.000})\n        elif self.primitive == Primitives.Cylinder:\n            self.mesh_args.update({'radius': 100.000, 'height': 200.000})\n        else:\n            self.mesh_args.update({'width': 50.000, 'height': 100.000, 'depth': 200.000})\n\n        self.createPrimitiveSwitcher()\n        self.createFormInputs()\n\n        button_layout = QtWidgets.QHBoxLayout()\n        self.create_primitive_button = QtWidgets.QPushButton('Create')\n        self.create_primitive_button.clicked.connect(self.createPrimiviteButtonClicked)\n        button_layout.addWidget(self.create_primitive_button)\n        button_layout.addStretch(1)\n\n        self.main_layout.addLayout(button_layout)\n        self.main_layout.addStretch(1)\n\n        self.setLayout(self.main_layout)\n\n        self.title = 'Insert {}'.format(self.primitive.value)\n        self.setMinimumWidth(450)\n        self.textboxes['name'].setFocus()\n\n    def createPrimitiveSwitcher(self):\n        switcher_layout = QtWidgets.QHBoxLayout()\n        switcher = create_tool_button(style_name='MenuButton', status_tip='Open dialog for a different primitive')\n        switcher.setArrowType(QtCore.Qt.DownArrow)\n        switcher.setPopupMode(QtWidgets.QToolButton.InstantPopup)\n        switcher.setMenu(self.parent.primitives_menu)\n        switcher_layout.addStretch(1)\n        switcher_layout.addWidget(switcher)\n        self.main_layout.addLayout(switcher_layout)\n\n    def createFormInputs(self):\n        self.form_group = FormGroup()\n        for key, value in self.mesh_args.items():\n            pretty_label = key.replace('_', ' ').title()\n\n            if key == 'name':\n                control = FormControl(pretty_label, value, required=True)\n                control.form_lineedit.textChanged.connect(self.nameCheck)\n            else:\n                control = FormControl(pretty_label, value, desc='mm', required=True, number=True)\n                control.range(0, None, min_exclusive=True)\n\n            self.textboxes[key] = control\n            self.form_group.addControl(control)\n\n        if self.primitive == Primitives.Tube:\n            outer_radius = self.textboxes['outer_radius']\n            inner_radius = self.textboxes['inner_radius']\n\n            outer_radius.compareWith(inner_radius, CompareValidator.Operator.Greater)\n            inner_radius.compareWith(outer_radius, CompareValidator.Operator.Less)\n\n        self.main_layout.addWidget(self.form_group)\n        self.form_group.groupValidation.connect(self.formValidation)\n\n    def nameCheck(self, value):\n        if self.parent_model.all_sample_key == value:\n            self.textboxes['name'].isInvalid(f'\"{self.parent_model.all_sample_key}\" is a reserved name')\n\n    def formValidation(self, is_valid):\n        if is_valid:\n            self.create_primitive_button.setEnabled(True)\n        else:\n            self.create_primitive_button.setDisabled(True)\n\n    def createPrimiviteButtonClicked(self):\n        for key, textbox in self.textboxes.items():\n            value = textbox.value\n            self.mesh_args[key] = value\n\n        self.parent.presenter.addPrimitive(self.primitive, self.mesh_args)\n        new_name = self.parent_model.uniqueKey(self.primitive.value)\n        self.textboxes['name'].value = new_name\n\n\nclass InsertPointDialog(QtWidgets.QWidget):\n    \"\"\"Provides UI for typing in measurement/fiducial points\n\n    :param point_type: point type\n    :type point_type: PointType\n    :param parent: Main window\n    :type parent: MainWindow\n    \"\"\"\n    dock_flag = DockFlag.Upper\n\n    def __init__(self, point_type, parent):\n        super().__init__(parent)\n        self.parent = parent\n        self.parent_model = parent.presenter.model\n        self.parent.scenes.switchToSampleScene()\n        self.point_type = point_type\n        self.title = 'Add {} Point'.format(point_type.value)\n        self.main_layout = QtWidgets.QVBoxLayout()\n        unit = 'mm'\n        self.form_group = FormGroup()\n        self.x_axis = FormControl('X', 0.0, required=True, desc=unit, number=True)\n        self.y_axis = FormControl('Y', 0.0, required=True, desc=unit, number=True)\n        self.z_axis = FormControl('Z', 0.0, required=True, desc=unit, number=True)\n        self.form_group.addControl(self.x_axis)\n        self.form_group.addControl(self.y_axis)\n        self.form_group.addControl(self.z_axis)\n        self.form_group.groupValidation.connect(self.formValidation)\n        button_layout = QtWidgets.QHBoxLayout()\n        self.execute_button = QtWidgets.QPushButton(self.title)\n        self.execute_button.clicked.connect(self.executeButtonClicked)\n        button_layout.addWidget(self.execute_button)\n        button_layout.addStretch(1)\n\n        self.main_layout.addWidget(self.form_group)\n        self.main_layout.addLayout(button_layout)\n        self.main_layout.addStretch(1)\n        self.setLayout(self.main_layout)\n\n        self.setMinimumWidth(450)\n\n    def formValidation(self, is_valid):\n        if is_valid:\n            self.execute_button.setEnabled(True)\n        else:\n            self.execute_button.setDisabled(True)\n\n    def executeButtonClicked(self):\n        point = [self.x_axis.value, self.y_axis.value, self.z_axis.value]\n        self.parent.presenter.addPoints([(point, True)], self.point_type)\n\n\nclass InsertVectorDialog(QtWidgets.QWidget):\n    \"\"\"Provides UI for adding measurement vectors using a variety of methods\n\n    :param parent: Main window\n    :type parent: MainWindow\n    \"\"\"\n    dock_flag = DockFlag.Upper\n\n    def __init__(self, parent):\n        super().__init__(parent)\n        self.parent = parent\n        self.parent_model = parent.presenter.model\n        self.parent.scenes.switchToSampleScene()\n        self.title = 'Add Measurement Vectors'\n        self.main_layout = QtWidgets.QVBoxLayout()\n        spacing = 10\n        self.main_layout.addSpacing(spacing)\n        self.main_layout.addWidget(QtWidgets.QLabel('Measurement Point:'))\n        self.points_combobox = QtWidgets.QComboBox()\n        self.points_combobox.setView(QtWidgets.QListView())\n        self.main_layout.addWidget(self.points_combobox)\n        self.updatePointList()\n        self.main_layout.addSpacing(spacing)\n\n        layout = QtWidgets.QHBoxLayout()\n        alignment_layout = QtWidgets.QVBoxLayout()\n        alignment_layout.addWidget(QtWidgets.QLabel('Alignment:'))\n        self.alignment_combobox = QtWidgets.QComboBox()\n        self.alignment_combobox.setView(QtWidgets.QListView())\n        self.alignment_combobox.setInsertPolicy(QtWidgets.QComboBox.InsertAtCurrent)\n        self.updateAlignment()\n        self.alignment_combobox.activated.connect(self.addNewAlignment)\n        self.alignment_combobox.currentIndexChanged.connect(self.changeRenderedAlignment)\n        alignment_layout.addWidget(self.alignment_combobox)\n        alignment_layout.addSpacing(spacing)\n        layout.addLayout(alignment_layout)\n\n        self.detector_combobox = QtWidgets.QComboBox()\n        self.detector_combobox.setView(QtWidgets.QListView())\n        self.detector_combobox.addItems(list(self.parent_model.instrument.detectors.keys()))\n        if len(self.parent_model.instrument.detectors) > 1:\n            detector_layout = QtWidgets.QVBoxLayout()\n            detector_layout.addWidget(QtWidgets.QLabel('Detector:'))\n            detector_layout.addWidget(self.detector_combobox)\n            size = self.detector_combobox.iconSize()\n            self.detector_combobox.setItemIcon(0, create_icon(settings.value(settings.Key.Vector_1_Colour), size))\n            self.detector_combobox.setItemIcon(1, create_icon(settings.value(settings.Key.Vector_2_Colour), size))\n            detector_layout.addSpacing(spacing)\n            layout.addSpacing(spacing)\n            layout.addLayout(detector_layout)\n\n        self.main_layout.addLayout(layout)\n\n        self.main_layout.addWidget(QtWidgets.QLabel('Strain Component:'))\n        self.component_combobox = QtWidgets.QComboBox()\n        self.component_combobox.setView(QtWidgets.QListView())\n        strain_components = [s.value for s in StrainComponents]\n        self.component_combobox.addItems(strain_components)\n        self.component_combobox.currentTextChanged.connect(self.toggleKeyInBox)\n        self.main_layout.addWidget(self.component_combobox)\n        self.main_layout.addSpacing(spacing)\n\n        button_layout = QtWidgets.QHBoxLayout()\n        self.execute_button = QtWidgets.QPushButton(self.title)\n        self.execute_button.clicked.connect(self.executeButtonClicked)\n        button_layout.addWidget(self.execute_button)\n        button_layout.addStretch(1)\n\n        self.createKeyInBox()\n\n        self.reverse_checkbox = QtWidgets.QCheckBox('Reverse Direction of Vector')\n        self.main_layout.addWidget(self.reverse_checkbox)\n        self.main_layout.addSpacing(spacing)\n\n        self.main_layout.addLayout(button_layout)\n        self.main_layout.addStretch(1)\n        self.setLayout(self.main_layout)\n        self.parent_model.measurement_points_changed.connect(self.updatePointList)\n        self.parent_model.measurement_vectors_changed.connect(self.updateAlignment)\n        self.parent.scenes.rendered_alignment_changed.connect(self.alignment_combobox.setCurrentIndex)\n        self.setMinimumWidth(450)\n\n    def updatePointList(self):\n        self.points_combobox.clear()\n        point_list = ['All Points']\n        point_list.extend(['{}'.format(i+1) for i in range(self.parent_model.measurement_points.size)])\n        self.points_combobox.addItems(point_list)\n\n    def updateAlignment(self):\n        align_count = self.parent_model.measurement_vectors.shape[2]\n        if align_count != self.alignment_combobox.count() - 1:\n            self.alignment_combobox.clear()\n            alignment_list = ['{}'.format(i + 1) for i in range(align_count)]\n            alignment_list.append('Add New...')\n            self.alignment_combobox.addItems(alignment_list)\n\n        self.alignment_combobox.setCurrentIndex(self.parent.scenes.rendered_alignment)\n\n    def addNewAlignment(self, index):\n        if index == self.alignment_combobox.count() - 1:\n            self.alignment_combobox.insertItem(index, '{}'.format(index + 1))\n            self.alignment_combobox.setCurrentIndex(index)\n\n    def changeRenderedAlignment(self, index):\n        align_count = self.parent_model.measurement_vectors.shape[2]\n        if 0 <= index < align_count:\n            self.parent.scenes.changeRenderedAlignment(index)\n        elif index >= align_count:\n            self.parent.scenes.changeVisibility(Attributes.Vectors, False)\n\n    def toggleKeyInBox(self, selected_text):\n        strain_component = StrainComponents(selected_text)\n        if strain_component == StrainComponents.custom:\n            self.key_in_box.setVisible(True)\n            self.form_group.validateGroup()\n        else:\n            self.key_in_box.setVisible(False)\n            self.execute_button.setEnabled(True)\n\n    def createKeyInBox(self):\n        self.key_in_box = QtWidgets.QWidget(self)\n        layout = QtWidgets.QVBoxLayout()\n\n        self.form_group = FormGroup(FormGroup.Layout.Horizontal)\n        self.x_axis = FormControl('X', 1.0, required=True, number=True, decimals=7)\n        self.x_axis.range(-1.0, 1.0)\n        self.y_axis = FormControl('Y', 0.0, required=True, number=True, decimals=7)\n        self.y_axis.range(-1.0, 1.0)\n        self.z_axis = FormControl('Z', 0.0, required=True, number=True, decimals=7)\n        self.z_axis.range(-1.0, 1.0)\n        self.form_group.addControl(self.x_axis)\n        self.form_group.addControl(self.y_axis)\n        self.form_group.addControl(self.z_axis)\n        self.form_group.groupValidation.connect(self.formValidation)\n\n        layout.addWidget(self.form_group)\n        self.key_in_box.setLayout(layout)\n        self.main_layout.addWidget(self.key_in_box)\n        self.toggleKeyInBox(self.component_combobox.currentText())\n\n    def formValidation(self, is_valid):\n        self.execute_button.setDisabled(True)\n        if is_valid:\n            if np.linalg.norm([self.x_axis.value, self.y_axis.value, self.z_axis.value]) > VECTOR_EPS:\n                self.x_axis.validation_label.setText('')\n                self.execute_button.setEnabled(True)\n            else:\n                self.x_axis.validation_label.setText('Bad Normal')\n\n    def executeButtonClicked(self):\n        points = self.points_combobox.currentIndex() - 1\n\n        selected_text = self.component_combobox.currentText()\n        strain_component = StrainComponents(selected_text)\n\n        alignment = self.alignment_combobox.currentIndex()\n        detector = self.detector_combobox.currentIndex()\n        check_state = self.reverse_checkbox.checkState()\n        reverse = True if check_state == QtCore.Qt.Checked else False\n\n        if strain_component == StrainComponents.custom:\n            vector = [self.x_axis.value, self.y_axis.value, self.z_axis.value]\n        else:\n            vector = None\n\n        self.parent.presenter.addVectors(points, strain_component, alignment, detector,\n                                         key_in=vector, reverse=reverse)\n        # New vectors are drawn by the scene manager after function ends\n        self.parent.scenes._rendered_alignment = alignment\n\n    def closeEvent(self, event):\n        self.parent.scenes.changeRenderedAlignment(0)\n        event.accept()\n\n\nclass PickPointDialog(QtWidgets.QWidget):\n    \"\"\"Provides UI for selecting measurement points on a cross section of the sample\n\n    :param parent: Main window\n    :type parent: MainWindow\n    \"\"\"\n    dock_flag = DockFlag.Full\n\n    def __init__(self, parent):\n        super().__init__(parent)\n        self.parent = parent\n        self.parent_model = parent.presenter.model\n        self.parent.scenes.switchToSampleScene()\n        self.title = 'Add Measurement Points Graphically'\n        self.setMinimumWidth(500)\n\n        self.plane_offset_range = (-1., 1.)\n        self.slider_range = (-10000000, 10000000)\n\n        self.sample_scale = 20\n        self.path_pen = QtGui.QPen(QtGui.QColor(255, 0, 0),  0)\n        self.point_pen = QtGui.QPen(QtGui.QColor(200, 0, 0),  0)\n\n        self.main_layout = QtWidgets.QVBoxLayout()\n        self.setLayout(self.main_layout)\n        button_layout = QtWidgets.QHBoxLayout()\n        self.help_button = create_tool_button(tooltip='Help', style_name='ToolButton',\n                                              status_tip='Display shortcuts for the cross-section view',\n                                              icon_path=path_for('question.png'))\n        self.help_button.clicked.connect(self.showHelp)\n\n        self.reset_button = create_tool_button(tooltip='Reset View', style_name='ToolButton',\n                                               status_tip='Reset camera transformation of the cross-section view',\n                                               icon_path=path_for('refresh.png'))\n        self.execute_button = QtWidgets.QPushButton('Add Points')\n        self.execute_button.clicked.connect(self.addPoints)\n        button_layout.addWidget(self.help_button)\n        button_layout.addWidget(self.reset_button)\n        button_layout.addStretch(1)\n        button_layout.addWidget(self.execute_button)\n        self.main_layout.addLayout(button_layout)\n\n        self.splitter = QtWidgets.QSplitter(QtCore.Qt.Vertical)\n        self.splitter.setChildrenCollapsible(False)\n        self.main_layout.addWidget(self.splitter)\n        self.createGraphicsView()\n        self.reset_button.clicked.connect(self.view.reset)\n        self.createControlPanel()\n\n        self.prepareMesh()\n        self.parent_model.sample_changed.connect(self.prepareMesh)\n        self.parent_model.measurement_points_changed.connect(self.updateCrossSection)\n        self.initializing = True\n\n    def showEvent(self, event):\n        if self.initializing:\n            self.view.fitInView(self.view.anchor, QtCore.Qt.KeepAspectRatio)\n            self.initializing = False\n\n        super().showEvent(event)\n\n    def closeEvent(self, event):\n        self.parent.scenes.removePlane()\n        event.accept()\n\n    def prepareMesh(self):\n        self.mesh = None\n        samples = self.parent_model.sample\n        for _, sample in samples.items():\n            if self.mesh is None:\n                self.mesh = sample.copy()\n            else:\n                self.mesh.append(sample)\n\n        self.scene.clear()\n        self.tabs.setEnabled(self.mesh is not None)\n        if self.mesh is not None:\n            self.setPlane(self.plane_combobox.currentText())\n        else:\n            self.parent.scenes.removePlane()\n        self.view.reset()\n\n    def updateStatusBar(self, point):\n        if self.view.rect().contains(point):\n            transform = self.view.scene_transform.inverted()[0]\n            scene_pt = transform.map(self.view.mapToScene(point)) / self.sample_scale\n            world_pt = [scene_pt.x(), scene_pt.y(), -self.old_distance] @ self.matrix.transpose()\n            cursor_text = f'X:   {world_pt[0]:.3f}        Y:   {world_pt[1]:.3f}        Z:   {world_pt[2]:.3f}'\n            self.parent.cursor_label.setText(cursor_text)\n        else:\n            self.parent.cursor_label.clear()\n\n    def createGraphicsView(self):\n        self.scene = GraphicsScene(self.sample_scale, self)\n        self.view = GraphicsView(self.scene)\n        self.view.mouse_moved.connect(self.updateStatusBar)\n        self.view.setMinimumHeight(350)\n        self.splitter.addWidget(self.view)\n\n    def createControlPanel(self):\n        self.tabs = QtWidgets.QTabWidget()\n        self.tabs.setMinimumHeight(250)\n        self.tabs.setTabPosition(QtWidgets.QTabWidget.South)\n        self.splitter.addWidget(self.tabs)\n\n        self.createPlaneTab()\n        self.createSelectionToolsTab()\n        self.createGridOptionsTab()\n        point_manager = PointManager(PointType.Measurement, self.parent)\n        self.tabs.addTab(create_scroll_area(point_manager), 'Point Manager')\n\n    def createPlaneTab(self):\n        layout = QtWidgets.QVBoxLayout()\n        layout.addWidget(QtWidgets.QLabel('Specify Plane:'))\n        self.plane_combobox = QtWidgets.QComboBox()\n        self.plane_combobox.setView(QtWidgets.QListView())\n        self.plane_combobox.addItems([p.value for p in PlaneOptions])\n        self.plane_combobox.currentTextChanged.connect(self.setPlane)\n        self.createCustomPlaneBox()\n        layout.addWidget(self.plane_combobox)\n        layout.addWidget(self.custom_plane_widget)\n        layout.addSpacing(20)\n\n        slider_layout = QtWidgets.QHBoxLayout()\n        slider_layout.addWidget(QtWidgets.QLabel('Plane Distance from Origin (mm):'))\n        self.plane_lineedit = QtWidgets.QLineEdit()\n        validator = QtGui.QDoubleValidator(self.plane_lineedit)\n        validator.setNotation(QtGui.QDoubleValidator.StandardNotation)\n        validator.setDecimals(3)\n        self.plane_lineedit.setValidator(validator)\n        self.plane_lineedit.textEdited.connect(self.updateSlider)\n        self.plane_lineedit.editingFinished.connect(self.movePlane)\n        slider_layout.addStretch(1)\n        slider_layout.addWidget(self.plane_lineedit)\n        layout.addLayout(slider_layout)\n        self.plane_slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n        self.plane_slider.setMinimum(self.slider_range[0])\n        self.plane_slider.setMaximum(self.slider_range[1])\n        self.plane_slider.setFocusPolicy(QtCore.Qt.StrongFocus)\n        self.plane_slider.setSingleStep(1)\n        self.plane_slider.sliderMoved.connect(self.updateLineEdit)\n        self.plane_slider.sliderReleased.connect(self.movePlane)\n        layout.addWidget(self.plane_slider)\n        layout.addStretch(1)\n\n        plane_tab = QtWidgets.QWidget()\n        plane_tab.setLayout(layout)\n        self.tabs.addTab(create_scroll_area(plane_tab), 'Define Plane')\n\n    def createSelectionToolsTab(self):\n        layout = QtWidgets.QVBoxLayout()\n        selector_layout = QtWidgets.QHBoxLayout()\n        selector_layout.addWidget(QtWidgets.QLabel('Select Geometry of Points: '))\n        self.button_group = QtWidgets.QButtonGroup()\n        self.button_group.buttonClicked[int].connect(self.changeSceneMode)\n\n        self.object_selector = create_tool_button(checkable=True, checked=True, tooltip='Select Points',\n                                                  status_tip='Select movable points from the cross-section view',\n                                                  style_name='MidToolButton', icon_path=path_for('select.png'))\n        self.point_selector = create_tool_button(checkable=True, tooltip='Draw a Point',\n                                                 status_tip='Draw a single point at the selected position',\n                                                 style_name='MidToolButton', icon_path=path_for('point.png'))\n        self.line_selector = create_tool_button(checkable=True, tooltip='Draw Points on Line',\n                                                status_tip='Draw equally spaced points on the selected line',\n                                                style_name='MidToolButton', icon_path=path_for('line_tool.png'))\n        self.area_selector = create_tool_button(checkable=True, tooltip='Draw Points on Area',\n                                                status_tip='Draw a grid of points on the selected area',\n                                                style_name='MidToolButton', icon_path=path_for('area_tool.png'))\n\n        self.button_group.addButton(self.object_selector, GraphicsScene.Mode.Select.value)\n        self.button_group.addButton(self.point_selector, GraphicsScene.Mode.Draw_point.value)\n        self.button_group.addButton(self.line_selector, GraphicsScene.Mode.Draw_line.value)\n        self.button_group.addButton(self.area_selector, GraphicsScene.Mode.Draw_area.value)\n        selector_layout.addWidget(self.object_selector)\n        selector_layout.addWidget(self.point_selector)\n        selector_layout.addWidget(self.line_selector)\n        selector_layout.addWidget(self.area_selector)\n        selector_layout.addStretch(1)\n\n        self.createLineToolWidget()\n        self.createAreaToolWidget()\n\n        layout.addLayout(selector_layout)\n        layout.addWidget(self.line_tool_widget)\n        layout.addWidget(self.area_tool_widget)\n        layout.addStretch(1)\n\n        select_tab = QtWidgets.QWidget()\n        select_tab.setLayout(layout)\n        self.tabs.addTab(create_scroll_area(select_tab), 'Selection Tools')\n\n    def createGridOptionsTab(self):\n        layout = QtWidgets.QVBoxLayout()\n        self.show_grid_checkbox = QtWidgets.QCheckBox('Show Grid')\n        self.show_grid_checkbox.stateChanged.connect(self.showGrid)\n        self.snap_to_grid_checkbox = QtWidgets.QCheckBox('Snap Selection to Grid')\n        self.snap_to_grid_checkbox.stateChanged.connect(self.snapToGrid)\n        self.snap_to_grid_checkbox.setEnabled(self.view.show_grid)\n        layout.addWidget(self.show_grid_checkbox)\n        layout.addWidget(self.snap_to_grid_checkbox)\n        self.createGridWidget()\n        layout.addWidget(self.grid_widget)\n        layout.addStretch(1)\n\n        grid_tab = QtWidgets.QWidget()\n        grid_tab.setLayout(layout)\n        self.tabs.addTab(create_scroll_area(grid_tab), 'Grid Options')\n\n    def createCustomPlaneBox(self):\n        self.custom_plane_widget = QtWidgets.QWidget(self)\n        layout = QtWidgets.QVBoxLayout()\n\n        self.form_group = FormGroup(FormGroup.Layout.Horizontal)\n        self.x_axis = FormControl('X', 1.0, required=True, number=True)\n        self.x_axis.range(-1.0, 1.0)\n        self.y_axis = FormControl('Y', 0.0, required=True, number=True)\n        self.y_axis.range(-1.0, 1.0)\n        self.z_axis = FormControl('Z', 0.0, required=True, number=True)\n        self.z_axis.range(-1.0, 1.0)\n        self.form_group.addControl(self.x_axis)\n        self.form_group.addControl(self.y_axis)\n        self.form_group.addControl(self.z_axis)\n        self.form_group.groupValidation.connect(self.setCustomPlane)\n\n        layout.addWidget(self.form_group)\n        self.custom_plane_widget.setLayout(layout)\n\n    def createLineToolWidget(self):\n        self.line_tool_widget = QtWidgets.QWidget(self)\n        layout = QtWidgets.QHBoxLayout()\n        layout.setContentsMargins(0, 20, 0, 0)\n        layout.addWidget(QtWidgets.QLabel('Number of Points: '))\n        self.line_point_count_spinbox = QtWidgets.QSpinBox()\n        self.line_point_count_spinbox.setValue(self.scene.line_tool_size)\n        self.line_point_count_spinbox.setRange(2, 100)\n        self.line_point_count_spinbox.valueChanged.connect(self.scene.setLineToolSize)\n\n        layout.addWidget(self.line_point_count_spinbox)\n        self.line_tool_widget.setVisible(False)\n        self.line_tool_widget.setLayout(layout)\n\n    def createAreaToolWidget(self):\n        self.area_tool_widget = QtWidgets.QWidget(self)\n        layout = QtWidgets.QHBoxLayout()\n        layout.setContentsMargins(0, 20, 0, 0)\n        layout.addWidget(QtWidgets.QLabel('Number of Points: '))\n        self.area_x_spinbox = QtWidgets.QSpinBox()\n        self.area_x_spinbox.setValue(self.scene.area_tool_size[0])\n        self.area_x_spinbox.setRange(2, 100)\n        self.area_y_spinbox = QtWidgets.QSpinBox()\n        self.area_y_spinbox.setValue(self.scene.area_tool_size[1])\n        self.area_y_spinbox.setRange(2, 100)\n\n        stretch_factor = 3\n        layout.addStretch(1)\n        layout.addWidget(QtWidgets.QLabel('X: '))\n        self.area_x_spinbox.valueChanged.connect(lambda: self.scene.setAreaToolSize(self.area_x_spinbox.value(),\n                                                                                    self.area_y_spinbox.value()))\n        layout.addWidget(self.area_x_spinbox, stretch_factor)\n        layout.addStretch(1)\n        layout.addWidget(QtWidgets.QLabel('Y: '))\n        self.area_y_spinbox.valueChanged.connect(lambda: self.scene.setAreaToolSize(self.area_x_spinbox.value(),\n                                                                                    self.area_y_spinbox.value()))\n        layout.addWidget(self.area_y_spinbox, stretch_factor)\n        self.area_tool_widget.setVisible(False)\n        self.area_tool_widget.setLayout(layout)\n\n    def createGridWidget(self):\n        self.grid_widget = QtWidgets.QWidget(self)\n        main_layout = QtWidgets.QVBoxLayout()\n        main_layout.setContentsMargins(0, 20, 0, 0)\n        layout = QtWidgets.QHBoxLayout()\n        layout.addWidget(QtWidgets.QLabel('Grid Type: '))\n        grid_combobox = QtWidgets.QComboBox()\n        grid_combobox.setView(QtWidgets.QListView())\n        grid_combobox.addItems([g.value for g in Grid.Type])\n        grid_combobox.currentTextChanged.connect(lambda value: self.setGridType(Grid.Type(value)))\n        layout.addWidget(grid_combobox)\n        main_layout.addLayout(layout)\n        main_layout.addSpacing(20)\n\n        layout = QtWidgets.QHBoxLayout()\n        layout.addWidget(QtWidgets.QLabel('Grid Size: '))\n        self.grid_x_label = QtWidgets.QLabel('')\n        self.grid_x_spinbox = QtWidgets.QDoubleSpinBox()\n        self.grid_x_spinbox.setDecimals(1)\n        self.grid_x_spinbox.setSingleStep(0.1)\n        self.grid_x_spinbox.valueChanged.connect(self.changeGridSize)\n        self.grid_y_label = QtWidgets.QLabel('')\n        self.grid_y_spinbox = QtWidgets.QDoubleSpinBox()\n        self.grid_y_spinbox.setDecimals(1)\n        self.grid_y_spinbox.setSingleStep(0.1)\n        self.grid_y_spinbox.valueChanged.connect(self.changeGridSize)\n        stretch_factor = 3\n        layout.addStretch(1)\n        layout.addWidget(self.grid_x_label)\n        layout.addWidget(self.grid_x_spinbox, stretch_factor)\n        layout.addStretch(1)\n        layout.addWidget(self.grid_y_label)\n        layout.addWidget(self.grid_y_spinbox, stretch_factor)\n        main_layout.addLayout(layout)\n        self.setGridType(self.view.grid.type)\n        self.grid_widget.setVisible(False)\n        self.grid_widget.setLayout(main_layout)\n\n    def changeGridSize(self):\n        if self.view.grid.type == Grid.Type.Box:\n            grid_x = int(self.grid_x_spinbox.value() * self.sample_scale)\n            grid_y = int(self.grid_y_spinbox.value() * self.sample_scale)\n        else:\n            grid_x = int(self.grid_x_spinbox.value() * self.sample_scale)\n            grid_y = self.grid_y_spinbox.value()\n        self.view.setGridSize((grid_x, grid_y))\n\n    def setGridType(self, grid_type):\n        self.view.setGridType(grid_type)\n        size = self.view.grid.size\n        if grid_type == Grid.Type.Box:\n            self.grid_x_label.setText('X (mm): ')\n            self.grid_y_label.setText('Y (mm): ')\n            self.grid_x_spinbox.setValue(size[0])\n            self.grid_y_spinbox.setValue(size[1])\n            self.grid_x_spinbox.setRange(0.1, 1000)\n            self.grid_y_spinbox.setRange(0.1, 1000)\n        else:\n            self.grid_x_label.setText('Radius (mm): ')\n            self.grid_y_label.setText('Angle (degree): ')\n            self.grid_x_spinbox.setValue(size[0])\n            self.grid_y_spinbox.setValue(size[1])\n            self.grid_x_spinbox.setRange(0.1, 1000)\n            self.grid_y_spinbox.setRange(0.1, 360)\n\n    def changeSceneMode(self, button_id):\n        self.scene.mode = GraphicsScene.Mode(button_id)\n        self.line_tool_widget.setVisible(self.scene.mode == GraphicsScene.Mode.Draw_line)\n        self.area_tool_widget.setVisible(self.scene.mode == GraphicsScene.Mode.Draw_area)\n\n    def showHelp(self):\n        self.view.show_help = False if self.view.has_foreground else True\n        self.scene.update()\n\n    def showGrid(self, state):\n        self.view.show_grid = True if state == QtCore.Qt.Checked else False\n        self.snap_to_grid_checkbox.setEnabled(self.view.show_grid)\n        self.grid_widget.setVisible(self.view.show_grid)\n        self.scene.update()\n\n    def snapToGrid(self, state):\n        self.view.snap_to_grid = True if state == QtCore.Qt.Checked else False\n\n    def updateSlider(self, value):\n        if not self.plane_lineedit.hasAcceptableInput():\n            return\n\n        new_distance = clamp(float(value), *self.plane_offset_range)\n        slider_value = int(map_range(*self.plane_offset_range, *self.slider_range, new_distance))\n        self.plane_slider.setValue(slider_value)\n\n        offset = new_distance - self.old_distance\n        self.parent.scenes.movePlane(offset * self.plane.normal)\n        self.old_distance = new_distance\n\n    def updateLineEdit(self, value):\n        new_distance = trunc(map_range(*self.slider_range, *self.plane_offset_range, value), 3)\n        self.plane_lineedit.setText('{:.3f}'.format(new_distance))\n\n        offset = new_distance - self.old_distance\n        self.parent.scenes.movePlane(offset * self.plane.normal)\n        self.old_distance = new_distance\n\n    def movePlane(self):\n        distance = clamp(float(self.plane_lineedit.text()), *self.plane_offset_range)\n        self.plane_lineedit.setText('{:.3f}'.format(distance))\n        point = distance * self.plane.normal\n        self.plane = Plane(self.plane.normal, point)\n        self.updateCrossSection()\n\n    def setCustomPlane(self, is_valid):\n        if is_valid:\n            normal = np.array([self.x_axis.value, self.y_axis.value, self.z_axis.value])\n            try:\n                self.initializePlane(normal, self.mesh.bounding_box.center)\n            except ValueError:\n                self.x_axis.validation_label.setText('Bad Normal')\n\n    def setPlane(self, selected_text):\n        if selected_text == PlaneOptions.Custom.value:\n            self.custom_plane_widget.setVisible(True)\n            self.form_group.validateGroup()\n            return\n        else:\n            self.custom_plane_widget.setVisible(False)\n\n        if selected_text == PlaneOptions.XY.value:\n            plane_normal = np.array([0., 0., 1.])\n        elif selected_text == PlaneOptions.XZ.value:\n            plane_normal = np.array([0., 1., 0.])\n        else:\n            plane_normal = np.array([1., 0., 0.])\n\n        self.initializePlane(plane_normal, self.mesh.bounding_box.center)\n\n    def initializePlane(self, plane_normal, plane_point):\n        self.plane = Plane(plane_normal, plane_point)\n        plane_size = self.mesh.bounding_box.radius\n\n        self.parent.scenes.drawPlane(self.plane, 2 * plane_size, 2 * plane_size)\n        distance = self.plane.distanceFromOrigin()\n        self.plane_offset_range = (distance - plane_size, distance + plane_size)\n        slider_value = int(map_range(*self.plane_offset_range, *self.slider_range, distance))\n        self.plane_slider.setValue(slider_value)\n        self.plane_lineedit.setText('{:.3f}'.format(distance))\n        self.old_distance = distance\n        # inverted the normal so that the y-axis is flipped\n        self.matrix = self.__lookAt(-Vector3(self.plane.normal))\n        self.view.resetTransform()\n        self.updateCrossSection()\n\n    def updateCrossSection(self):\n        self.scene.clear()\n        segments = mesh_plane_intersection(self.mesh, self.plane)\n        if len(segments) == 0:\n            return\n        segments = np.array(segments)\n\n        item = QtWidgets.QGraphicsPathItem()\n        cross_section_path = QtGui.QPainterPath()\n        rotated_segments = self.sample_scale * (segments @ self.matrix)\n        for i in range(0, rotated_segments.shape[0], 2):\n            start = rotated_segments[i, :]\n            cross_section_path.moveTo(start[0], start[1])\n            end = rotated_segments[i + 1, :]\n            cross_section_path.lineTo(end[0], end[1])\n        item.setPath(cross_section_path)\n        item.setPen(self.path_pen)\n        item.setTransform(self.view.scene_transform)\n        self.scene.addItem(item)\n        rect = item.boundingRect()\n        anchor = rect.center()\n\n        ab = self.plane.point - self.parent_model.measurement_points.points\n        d = np.einsum('ij,ij->i', np.expand_dims(self.plane.normal, axis=0), ab)\n        index = np.where(np.abs(d) < VECTOR_EPS)[0]\n        rotated_points = self.parent_model.measurement_points.points[index, :]\n        rotated_points = rotated_points @ self.matrix\n\n        for i, p in zip(index, rotated_points):\n            point = QtCore.QPointF(p[0], p[1]) * self.sample_scale\n            point = self.view.scene_transform.map(point)\n            item = GraphicsPointItem(point, size=self.scene.point_size)\n            item.setToolTip(f'Point {i + 1}')\n            item.fixed = True\n            item.makeControllable(self.scene.mode == GraphicsScene.Mode.Select)\n            item.setPen(self.point_pen)\n            self.scene.addItem(item)\n            rect = rect.united(item.boundingRect().translated(point))\n\n        # calculate new rectangle that encloses original rect with a different anchor\n        rect.united(rect.translated(anchor - rect.center()))\n        self.view.setSceneRect(rect)\n        self.view.fitInView(rect, QtCore.Qt.KeepAspectRatio)\n        self.view.anchor = rect\n\n    @staticmethod\n    def __lookAt(forward):\n        rot_matrix = Matrix33.identity()\n        up = Vector3([0., -1., 0.]) if -VECTOR_EPS < forward[1] < VECTOR_EPS else Vector3([0., 0., 1.])\n        left = up ^ forward\n        left.normalize()\n        up = forward ^ left\n\n        rot_matrix.c1[:3] = left\n        rot_matrix.c2[:3] = up\n        rot_matrix.c3[:3] = forward\n\n        return rot_matrix\n\n    def addPoints(self):\n        if len(self.scene.items()) < 2:\n            return\n\n        points_2d = []\n        transform = self.view.scene_transform.inverted()[0]\n        for item in self.scene.items():\n            if isinstance(item, GraphicsPointItem) and not item.fixed:\n                pos = transform.map(item.pos()) / self.sample_scale\n                # negate distance due to inverted normal when creating matrix\n                points_2d.append([pos.x(), pos.y(), -self.old_distance])\n                self.scene.removeItem(item)\n\n        if not points_2d:\n            return\n\n        points = points_2d[::-1] @ self.matrix.transpose()\n        enabled = [True] * points.shape[0]\n        self.parent.presenter.addPoints(list(zip(points, enabled)), PointType.Measurement, False)\n\n\nclass AlignSample(QtWidgets.QWidget):\n    \"\"\"Provides UI for aligning sample on instrument with 6D pose\n\n    :param parent: Main window\n    :type parent: MainWindow\n    \"\"\"\n    dock_flag = DockFlag.Upper\n\n    def __init__(self, parent):\n        super().__init__(parent)\n        self.parent = parent\n        self.parent.scenes.switchToInstrumentScene()\n        self.title = 'Align Sample with 6D pose'\n        self.setMinimumWidth(450)\n\n        self.main_layout = QtWidgets.QVBoxLayout()\n        self.setLayout(self.main_layout)\n        self.main_layout.addSpacing(20)\n        self.main_layout.addWidget(FormTitle('Create Transformation for Alignment'))\n        self.main_layout.addSpacing(10)\n\n        self.main_layout.addWidget(QtWidgets.QLabel('Translation along the X, Y, and Z axis (mm):'))\n        self.position_form_group = FormGroup(FormGroup.Layout.Horizontal)\n        self.x_position = FormControl('X', 0.0, required=True, number=True)\n        self.y_position = FormControl('Y', 0.0, required=True, number=True)\n        self.z_position = FormControl('Z', 0.0, required=True, number=True)\n        self.position_form_group.addControl(self.x_position)\n        self.position_form_group.addControl(self.y_position)\n        self.position_form_group.addControl(self.z_position)\n        self.position_form_group.groupValidation.connect(self.formValidation)\n        self.main_layout.addWidget(self.position_form_group)\n\n        self.main_layout.addWidget(QtWidgets.QLabel('Rotation around the X, Y, and Z axis (degrees):'))\n        self.orientation_form_group = FormGroup(FormGroup.Layout.Horizontal)\n        self.x_rotation = FormControl('X', 0.0, required=True, number=True)\n        self.x_rotation.range(-360.0, 360.0)\n        self.y_rotation = FormControl('Y', 0.0, required=True, number=True)\n        self.y_rotation.range(-360.0, 360.0)\n        self.z_rotation = FormControl('Z', 0.0, required=True, number=True)\n        self.z_rotation.range(-360.0, 360.0)\n        self.orientation_form_group.addControl(self.x_rotation)\n        self.orientation_form_group.addControl(self.y_rotation)\n        self.orientation_form_group.addControl(self.z_rotation)\n        self.orientation_form_group.groupValidation.connect(self.formValidation)\n        self.main_layout.addWidget(self.orientation_form_group)\n\n        button_layout = QtWidgets.QHBoxLayout()\n        self.execute_button = QtWidgets.QPushButton('Align Sample')\n        self.execute_button.clicked.connect(self.executeButtonClicked)\n        button_layout.addWidget(self.execute_button)\n        button_layout.addStretch(1)\n        self.main_layout.addLayout(button_layout)\n        self.main_layout.addStretch(1)\n\n    def formValidation(self):\n        if self.position_form_group.valid and self.orientation_form_group.valid:\n            self.execute_button.setEnabled(True)\n        else:\n            self.execute_button.setDisabled(True)\n\n    def executeButtonClicked(self):\n        pose = [self.x_position.value, self.y_position.value, self.z_position.value,\n                self.z_rotation.value, self.y_rotation.value, self.x_rotation.value]\n\n        self.parent.presenter.alignSampleWithPose(pose)\n",
  "output": {
    "before": "import numpy as np\nfrom PyQt5 import QtCore, QtGui, QtWidgets\nfrom sscanss.config import path_for, settings\nfrom sscanss.core.math import Plane, Matrix33, Vector3, clamp, map_range, trunc, VECTOR_EPS\nfrom sscanss.core.geometry import mesh_plane_intersection\nfrom sscanss.core.util import Primitives, DockFlag, StrainComponents, PointType, PlaneOptions, Attributes\nfrom sscanss.ui.widgets import (FormGroup, FormControl, GraphicsView, GraphicsScene, create_tool_button, FormTitle,\n                                create_scroll_area, CompareValidator, GraphicsPointItem, Grid, create_icon)\nfrom .managers import PointManager\n\n\nclass InsertPrimitiveDialog(QtWidgets.QWidget):\n    \"\"\"Provides UI for typing in measurement/fiducial points\n\n    :param primitive: primitive type\n    :type primitive: Primitives\n    :param parent: Main window\n    :type parent: MainWindow\n    \"\"\"\n    dock_flag = DockFlag.Upper\n\n    def __init__(self, primitive, parent):\n        super().__init__(parent)\n        self.parent = parent\n        self.parent_model = self.parent.presenter.model\n        self.parent.scenes.switchToSampleScene()\n        self.primitive = primitive\n\n        self.main_layout = QtWidgets.QVBoxLayout()\n\n        self.textboxes = {}\n        name = self.parent_model.uniqueKey(self.primitive.value)\n        self.mesh_args = {'name': name}\n        if self.primitive == Primitives.Tube:\n            self.mesh_args.update({'outer_radius': 100.000, 'inner_radius': 50.000, 'height': 200.000})\n        elif self.primitive == Primitives.Sphere:\n            self.mesh_args.update({'radius': 100.000})\n        elif self.primitive == Primitives.Cylinder:\n            self.mesh_args.update({'radius': 100.000, 'height': 200.000})\n        else:\n            self.mesh_args.update({'width': 50.000, 'height': 100.000, 'depth': 200.000})\n\n        self.createPrimitiveSwitcher()\n        self.createFormInputs()\n\n        button_layout = QtWidgets.QHBoxLayout()\n        self.create_primitive_button = QtWidgets.QPushButton('Create')\n        self.create_primitive_button.clicked.connect(self.createPrimiviteButtonClicked)\n        button_layout.addWidget(self.create_primitive_button)\n        button_layout.addStretch(1)\n\n        self.main_layout.addLayout(button_layout)\n        self.main_layout.addStretch(1)\n\n        self.setLayout(self.main_layout)\n\n        self.title = 'Insert {}'.format(self.primitive.value)\n        self.setMinimumWidth(450)\n        self.textboxes['name'].setFocus()\n\n    def createPrimitiveSwitcher(self):\n        switcher_layout = QtWidgets.QHBoxLayout()\n        switcher = create_tool_button(style_name='MenuButton', status_tip='Open dialog for a different primitive')\n        switcher.setArrowType(QtCore.Qt.DownArrow)\n        switcher.setPopupMode(QtWidgets.QToolButton.InstantPopup)\n        switcher.setMenu(self.parent.primitives_menu)\n        switcher_layout.addStretch(1)\n        switcher_layout.addWidget(switcher)\n        self.main_layout.addLayout(switcher_layout)\n\n    def createFormInputs(self):\n        self.form_group = FormGroup()\n        for key, value in self.mesh_args.items():\n            pretty_label = key.replace('_', ' ').title()\n\n            if key == 'name':\n                control = FormControl(pretty_label, value, required=True)\n                control.form_lineedit.textChanged.connect(self.nameCheck)\n            else:\n                control = FormControl(pretty_label, value, desc='mm', required=True, number=True)\n                control.range(0, None, min_exclusive=True)\n\n            self.textboxes[key] = control\n            self.form_group.addControl(control)\n\n        if self.primitive == Primitives.Tube:\n            outer_radius = self.textboxes['outer_radius']\n            inner_radius = self.textboxes['inner_radius']\n\n            outer_radius.compareWith(inner_radius, CompareValidator.Operator.Greater)\n            inner_radius.compareWith(outer_radius, CompareValidator.Operator.Less)\n\n        self.main_layout.addWidget(self.form_group)\n        self.form_group.groupValidation.connect(self.formValidation)\n\n    def nameCheck(self, value):\n        if self.parent_model.all_sample_key == value:\n            self.textboxes['name'].isInvalid(f'\"{self.parent_model.all_sample_key}\" is a reserved name')\n\n    def formValidation(self, is_valid):\n        if is_valid:\n            self.create_primitive_button.setEnabled(True)\n        else:\n            self.create_primitive_button.setDisabled(True)\n\n    def createPrimiviteButtonClicked(self):\n        for key, textbox in self.textboxes.items():\n            value = textbox.value\n            self.mesh_args[key] = value\n\n        self.parent.presenter.addPrimitive(self.primitive, self.mesh_args)\n        new_name = self.parent_model.uniqueKey(self.primitive.value)\n        self.textboxes['name'].value = new_name\n\n\nclass InsertPointDialog(QtWidgets.QWidget):\n    \"\"\"Provides UI for typing in measurement/fiducial points\n\n    :param point_type: point type\n    :type point_type: PointType\n    :param parent: Main window\n    :type parent: MainWindow\n    \"\"\"\n    dock_flag = DockFlag.Upper\n\n    def __init__(self, point_type, parent):\n        super().__init__(parent)\n        self.parent = parent\n        self.parent_model = parent.presenter.model\n        self.parent.scenes.switchToSampleScene()\n        self.point_type = point_type\n        self.title = 'Add {} Point'.format(point_type.value)\n        self.main_layout = QtWidgets.QVBoxLayout()\n        unit = 'mm'\n        self.form_group = FormGroup()\n        self.x_axis = FormControl('X', 0.0, required=True, desc=unit, number=True)\n        self.y_axis = FormControl('Y', 0.0, required=True, desc=unit, number=True)\n        self.z_axis = FormControl('Z', 0.0, required=True, desc=unit, number=True)\n        self.form_group.addControl(self.x_axis)\n        self.form_group.addControl(self.y_axis)\n        self.form_group.addControl(self.z_axis)\n        self.form_group.groupValidation.connect(self.formValidation)\n        button_layout = QtWidgets.QHBoxLayout()\n        self.execute_button = QtWidgets.QPushButton(self.title)\n        self.execute_button.clicked.connect(self.executeButtonClicked)\n        button_layout.addWidget(self.execute_button)\n        button_layout.addStretch(1)\n\n        self.main_layout.addWidget(self.form_group)\n        self.main_layout.addLayout(button_layout)\n        self.main_layout.addStretch(1)\n        self.setLayout(self.main_layout)\n\n        self.setMinimumWidth(450)\n\n    def formValidation(self, is_valid):\n        if is_valid:\n            self.execute_button.setEnabled(True)\n        else:\n            self.execute_button.setDisabled(True)\n\n    def executeButtonClicked(self):\n        point = [self.x_axis.value, self.y_axis.value, self.z_axis.value]\n        self.parent.presenter.addPoints([(point, True)], self.point_type)\n\n\nclass InsertVectorDialog(QtWidgets.QWidget):\n    \"\"\"Provides UI for adding measurement vectors using a variety of methods\n\n    :param parent: Main window\n    :type parent: MainWindow\n    \"\"\"\n    dock_flag = DockFlag.Upper\n\n    def __init__(self, parent):\n        super().__init__(parent)\n        self.parent = parent\n        self.parent_model = parent.presenter.model\n        self.parent.scenes.switchToSampleScene()\n        self.title = 'Add Measurement Vectors'\n        self.main_layout = QtWidgets.QVBoxLayout()\n        spacing = 10\n        self.main_layout.addSpacing(spacing)\n        self.main_layout.addWidget(QtWidgets.QLabel('Measurement Point:'))\n        self.points_combobox = QtWidgets.QComboBox()\n        self.points_combobox.setView(QtWidgets.QListView())\n        self.main_layout.addWidget(self.points_combobox)\n        self.updatePointList()\n        self.main_layout.addSpacing(spacing)\n\n        layout = QtWidgets.QHBoxLayout()\n        alignment_layout = QtWidgets.QVBoxLayout()\n        alignment_layout.addWidget(QtWidgets.QLabel('Alignment:'))\n        self.alignment_combobox = QtWidgets.QComboBox()\n        self.alignment_combobox.setView(QtWidgets.QListView())\n        self.alignment_combobox.setInsertPolicy(QtWidgets.QComboBox.InsertAtCurrent)\n        self.updateAlignment()\n        self.alignment_combobox.activated.connect(self.addNewAlignment)\n        self.alignment_combobox.currentIndexChanged.connect(self.changeRenderedAlignment)\n        alignment_layout.addWidget(self.alignment_combobox)\n        alignment_layout.addSpacing(spacing)\n        layout.addLayout(alignment_layout)\n\n        self.detector_combobox = QtWidgets.QComboBox()\n        self.detector_combobox.setView(QtWidgets.QListView())\n        self.detector_combobox.addItems(list(self.parent_model.instrument.detectors.keys()))\n        if len(self.parent_model.instrument.detectors) > 1:\n            detector_layout = QtWidgets.QVBoxLayout()\n            detector_layout.addWidget(QtWidgets.QLabel('Detector:'))\n            detector_layout.addWidget(self.detector_combobox)\n            size = self.detector_combobox.iconSize()\n            self.detector_combobox.setItemIcon(0, create_icon(settings.value(settings.Key.Vector_1_Colour), size))\n            self.detector_combobox.setItemIcon(1, create_icon(settings.value(settings.Key.Vector_2_Colour), size))\n            detector_layout.addSpacing(spacing)\n            layout.addSpacing(spacing)\n            layout.addLayout(detector_layout)\n\n        self.main_layout.addLayout(layout)\n\n        self.main_layout.addWidget(QtWidgets.QLabel('Strain Component:'))\n        self.component_combobox = QtWidgets.QComboBox()\n        self.component_combobox.setView(QtWidgets.QListView())\n        strain_components = [s.value for s in StrainComponents]\n        self.component_combobox.addItems(strain_components)\n        self.component_combobox.currentTextChanged.connect(self.toggleKeyInBox)\n        self.main_layout.addWidget(self.component_combobox)\n        self.main_layout.addSpacing(spacing)\n\n        button_layout = QtWidgets.QHBoxLayout()\n        self.execute_button = QtWidgets.QPushButton(self.title)\n        self.execute_button.clicked.connect(self.executeButtonClicked)\n        button_layout.addWidget(self.execute_button)\n        button_layout.addStretch(1)\n\n        self.createKeyInBox()\n\n        self.reverse_checkbox = QtWidgets.QCheckBox('Reverse Direction of Vector')\n        self.main_layout.addWidget(self.reverse_checkbox)\n        self.main_layout.addSpacing(spacing)\n\n        self.main_layout.addLayout(button_layout)\n        self.main_layout.addStretch(1)\n        self.setLayout(self.main_layout)\n        self.parent_model.measurement_points_changed.connect(self.updatePointList)\n        self.parent_model.measurement_vectors_changed.connect(self.updateAlignment)\n        self.parent.scenes.rendered_alignment_changed.connect(self.alignment_combobox.setCurrentIndex)\n        self.setMinimumWidth(450)\n\n    def updatePointList(self):\n        self.points_combobox.clear()\n        point_list = ['All Points']\n        point_list.extend(['{}'.format(i+1) for i in range(self.parent_model.measurement_points.size)])\n        self.points_combobox.addItems(point_list)\n\n    def updateAlignment(self):\n        align_count = self.parent_model.measurement_vectors.shape[2]\n        if align_count != self.alignment_combobox.count() - 1:\n            self.alignment_combobox.clear()\n            alignment_list = ['{}'.format(i + 1) for i in range(align_count)]\n            alignment_list.append('Add New...')\n            self.alignment_combobox.addItems(alignment_list)\n\n        self.alignment_combobox.setCurrentIndex(self.parent.scenes.rendered_alignment)\n\n    def addNewAlignment(self, index):\n        if index == self.alignment_combobox.count() - 1:\n            self.alignment_combobox.insertItem(index, '{}'.format(index + 1))\n            self.alignment_combobox.setCurrentIndex(index)\n\n    def changeRenderedAlignment(self, index):\n        align_count = self.parent_model.measurement_vectors.shape[2]\n        if 0 <= index < align_count:\n            self.parent.scenes.changeRenderedAlignment(index)\n        elif index >= align_count:\n            self.parent.scenes.changeVisibility(Attributes.Vectors, False)\n\n    def toggleKeyInBox(self, selected_text):\n        strain_component = StrainComponents(selected_text)\n        if strain_component == StrainComponents.custom:\n            self.key_in_box.setVisible(True)\n            self.form_group.validateGroup()\n        else:\n            self.key_in_box.setVisible(False)\n            self.execute_button.setEnabled(True)\n\n    def createKeyInBox(self):\n        self.key_in_box = QtWidgets.QWidget(self)\n        layout = QtWidgets.QVBoxLayout()\n\n        self.form_group = FormGroup(FormGroup.Layout.Horizontal)\n        self.x_axis = FormControl('X', 1.0, required=True, number=True, decimals=7)\n        self.x_axis.range(-1.0, 1.0)\n        self.y_axis = FormControl('Y', 0.0, required=True, number=True, decimals=7)\n        self.y_axis.range(-1.0, 1.0)\n        self.z_axis = FormControl('Z', 0.0, required=True, number=True, decimals=7)\n        self.z_axis.range(-1.0, 1.0)\n        self.form_group.addControl(self.x_axis)\n        self.form_group.addControl(self.y_axis)\n        self.form_group.addControl(self.z_axis)\n        self.form_group.groupValidation.connect(self.formValidation)\n\n        layout.addWidget(self.form_group)\n        self.key_in_box.setLayout(layout)\n        self.main_layout.addWidget(self.key_in_box)\n        self.toggleKeyInBox(self.component_combobox.currentText())\n\n    def formValidation(self, is_valid):\n        self.execute_button.setDisabled(True)\n        if is_valid:\n            if np.linalg.norm([self.x_axis.value, self.y_axis.value, self.z_axis.value]) > VECTOR_EPS:\n                self.x_axis.validation_label.setText('')\n                self.execute_button.setEnabled(True)\n            else:\n                self.x_axis.validation_label.setText('Bad Normal')\n\n    def executeButtonClicked(self):\n        points = self.points_combobox.currentIndex() - 1\n\n        selected_text = self.component_combobox.currentText()\n        strain_component = StrainComponents(selected_text)\n\n        alignment = self.alignment_combobox.currentIndex()\n        detector = self.detector_combobox.currentIndex()\n        check_state = self.reverse_checkbox.checkState()\n        reverse = True if check_state == QtCore.Qt.Checked else False\n\n        if strain_component == StrainComponents.custom:\n            vector = [self.x_axis.value, self.y_axis.value, self.z_axis.value]\n        else:\n            vector = None\n\n        self.parent.presenter.addVectors(points, strain_component, alignment, detector,\n                                         key_in=vector, reverse=reverse)\n        # New vectors are drawn by the scene manager after function ends\n        self.parent.scenes._rendered_alignment = alignment\n\n    def closeEvent(self, event):\n        self.parent.scenes.changeRenderedAlignment(0)\n        event.accept()\n\n\nclass PickPointDialog(QtWidgets.QWidget):\n    \"\"\"Provides UI for selecting measurement points on a cross section of the sample\n\n    :param parent: Main window\n    :type parent: MainWindow\n    \"\"\"\n    dock_flag = DockFlag.Full\n\n    def __init__(self, parent):\n        super().__init__(parent)\n        self.parent = parent\n        self.parent_model = parent.presenter.model\n        self.parent.scenes.switchToSampleScene()\n        self.title = 'Add Measurement Points Graphically'\n        self.setMinimumWidth(500)\n\n        self.plane_offset_range = (-1., 1.)\n        self.slider_range = (-10000000, 10000000)\n\n        self.sample_scale = 20\n        self.path_pen = QtGui.QPen(QtGui.QColor(255, 0, 0),  0)\n        self.point_pen = QtGui.QPen(QtGui.QColor(200, 0, 0),  0)\n\n        self.main_layout = QtWidgets.QVBoxLayout()\n        self.setLayout(self.main_layout)\n        button_layout = QtWidgets.QHBoxLayout()\n        self.help_button = create_tool_button(tooltip='Help', style_name='ToolButton',\n                                              status_tip='Display shortcuts for the cross-section view',\n                                              icon_path=path_for('question.png'))\n        self.help_button.clicked.connect(self.showHelp)\n\n        self.reset_button = create_tool_button(tooltip='Reset View', style_name='ToolButton',\n                                               status_tip='Reset camera transformation of the cross-section view',\n                                               icon_path=path_for('refresh.png'))\n        self.execute_button = QtWidgets.QPushButton('Add Points')\n        self.execute_button.clicked.connect(self.addPoints)\n        button_layout.addWidget(self.help_button)\n        button_layout.addWidget(self.reset_button)\n        button_layout.addStretch(1)\n        button_layout.addWidget(self.execute_button)\n        self.main_layout.addLayout(button_layout)\n\n        self.splitter = QtWidgets.QSplitter(QtCore.Qt.Vertical)\n        self.splitter.setChildrenCollapsible(False)\n        self.main_layout.addWidget(self.splitter)\n        self.createGraphicsView()\n        self.reset_button.clicked.connect(self.view.reset)\n        self.createControlPanel()\n\n        self.prepareMesh()\n        self.parent_model.sample_changed.connect(self.prepareMesh)\n        self.parent_model.measurement_points_changed.connect(self.updateCrossSection)\n        self.initializing = True\n\n    def showEvent(self, event):\n        if self.initializing:\n            self.view.fitInView(self.view.anchor, QtCore.Qt.KeepAspectRatio)\n            self.initializing = False\n\n        super().showEvent(event)\n\n    def closeEvent(self, event):\n        self.parent.scenes.removePlane()\n        event.accept()\n\n    def prepareMesh(self):\n        self.mesh = None\n        samples = self.parent_model.sample\n        for _, sample in samples.items():\n            if self.mesh is None:\n                self.mesh = sample.copy()\n            else:\n                self.mesh.append(sample)\n\n        self.scene.clear()\n        self.tabs.setEnabled(self.mesh is not None)\n        if self.mesh is not None:\n            self.setPlane(self.plane_combobox.currentText())\n        else:\n            self.parent.scenes.removePlane()\n        self.view.reset()\n\n    def updateStatusBar(self, point):\n        if self.view.rect().contains(point):\n            transform = self.view.scene_transform.inverted()[0]\n            scene_pt = transform.map(self.view.mapToScene(point)) / self.sample_scale\n            world_pt = [scene_pt.x(), scene_pt.y(), -self.old_distance] @ self.matrix.transpose()\n            cursor_text = f'X:   {world_pt[0]:.3f}        Y:   {world_pt[1]:.3f}        Z:   {world_pt[2]:.3f}'\n            self.parent.cursor_label.setText(cursor_text)\n        else:\n            self.parent.cursor_label.clear()\n\n    def createGraphicsView(self):\n        self.scene = GraphicsScene(self.sample_scale, self)\n        self.view = GraphicsView(self.scene)\n        self.view.mouse_moved.connect(self.updateStatusBar)\n        self.view.setMinimumHeight(350)\n        self.splitter.addWidget(self.view)\n\n    def createControlPanel(self):\n        self.tabs = QtWidgets.QTabWidget()\n        self.tabs.setMinimumHeight(250)\n        self.tabs.setTabPosition(QtWidgets.QTabWidget.South)\n        self.splitter.addWidget(self.tabs)\n\n        self.createPlaneTab()\n        self.createSelectionToolsTab()\n        self.createGridOptionsTab()\n        point_manager = PointManager(PointType.Measurement, self.parent)\n        self.tabs.addTab(create_scroll_area(point_manager), 'Point Manager')\n\n    def createPlaneTab(self):\n        layout = QtWidgets.QVBoxLayout()\n        layout.addWidget(QtWidgets.QLabel('Specify Plane:'))\n        self.plane_combobox = QtWidgets.QComboBox()\n        self.plane_combobox.setView(QtWidgets.QListView())\n        self.plane_combobox.addItems([p.value for p in PlaneOptions])\n        self.plane_combobox.currentTextChanged.connect(self.setPlane)\n        self.createCustomPlaneBox()\n        layout.addWidget(self.plane_combobox)\n        layout.addWidget(self.custom_plane_widget)\n        layout.addSpacing(20)\n\n        slider_layout = QtWidgets.QHBoxLayout()\n        slider_layout.addWidget(QtWidgets.QLabel('Plane Distance from Origin (mm):'))\n        self.plane_lineedit = QtWidgets.QLineEdit()\n        validator = QtGui.QDoubleValidator(self.plane_lineedit)\n        validator.setNotation(QtGui.QDoubleValidator.StandardNotation)\n        validator.setDecimals(3)\n        self.plane_lineedit.setValidator(validator)\n        self.plane_lineedit.textEdited.connect(self.updateSlider)\n        self.plane_lineedit.editingFinished.connect(self.movePlane)\n        slider_layout.addStretch(1)\n        slider_layout.addWidget(self.plane_lineedit)\n        layout.addLayout(slider_layout)\n        self.plane_slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n        self.plane_slider.setMinimum(self.slider_range[0])\n        self.plane_slider.setMaximum(self.slider_range[1])\n        self.plane_slider.setFocusPolicy(QtCore.Qt.StrongFocus)\n        self.plane_slider.setSingleStep(1)\n        self.plane_slider.sliderMoved.connect(self.updateLineEdit)\n        self.plane_slider.sliderReleased.connect(self.movePlane)\n        layout.addWidget(self.plane_slider)\n        layout.addStretch(1)\n\n        plane_tab = QtWidgets.QWidget()\n        plane_tab.setLayout(layout)\n        self.tabs.addTab(create_scroll_area(plane_tab), 'Define Plane')\n\n    def createSelectionToolsTab(self):\n        layout = QtWidgets.QVBoxLayout()\n        selector_layout = QtWidgets.QHBoxLayout()\n        selector_layout.addWidget(QtWidgets.QLabel('Select Geometry of Points: '))\n        self.button_group = QtWidgets.QButtonGroup()\n        self.button_group.buttonClicked[int].connect(self.changeSceneMode)\n\n        self.object_selector = create_tool_button(checkable=True, checked=True, tooltip='Select Points',\n                                                  status_tip='Select movable points from the cross-section view',\n                                                  style_name='MidToolButton', icon_path=path_for('select.png'))\n        self.point_selector = create_tool_button(checkable=True, tooltip='Draw a Point',\n                                                 status_tip='Draw a single point at the selected position',\n                                                 style_name='MidToolButton', icon_path=path_for('point.png'))\n        self.line_selector = create_tool_button(checkable=True, tooltip='Draw Points on Line',\n                                                status_tip='Draw equally spaced points on the selected line',\n                                                style_name='MidToolButton', icon_path=path_for('line_tool.png'))\n        self.area_selector = create_tool_button(checkable=True, tooltip='Draw Points on Area',\n                                                status_tip='Draw a grid of points on the selected area',\n                                                style_name='MidToolButton', icon_path=path_for('area_tool.png'))\n\n        self.button_group.addButton(self.object_selector, GraphicsScene.Mode.Select.value)\n        self.button_group.addButton(self.point_selector, GraphicsScene.Mode.Draw_point.value)\n        self.button_group.addButton(self.line_selector, GraphicsScene.Mode.Draw_line.value)\n        self.button_group.addButton(self.area_selector, GraphicsScene.Mode.Draw_area.value)\n        selector_layout.addWidget(self.object_selector)\n        selector_layout.addWidget(self.point_selector)\n        selector_layout.addWidget(self.line_selector)\n        selector_layout.addWidget(self.area_selector)\n        selector_layout.addStretch(1)\n\n        self.createLineToolWidget()\n        self.createAreaToolWidget()\n\n        layout.addLayout(selector_layout)\n        layout.addWidget(self.line_tool_widget)\n        layout.addWidget(self.area_tool_widget)\n        layout.addStretch(1)\n\n        select_tab = QtWidgets.QWidget()\n        select_tab.setLayout(layout)\n        self.tabs.addTab(create_scroll_area(select_tab), 'Selection Tools')\n\n    def createGridOptionsTab(self):\n        layout = QtWidgets.QVBoxLayout()\n        self.show_grid_checkbox = QtWidgets.QCheckBox('Show Grid')\n        self.show_grid_checkbox.stateChanged.connect(self.showGrid)\n        self.snap_to_grid_checkbox = QtWidgets.QCheckBox('Snap Selection to Grid')\n        self.snap_to_grid_checkbox.stateChanged.connect(self.snapToGrid)\n        self.snap_to_grid_checkbox.setEnabled(self.view.show_grid)\n        layout.addWidget(self.show_grid_checkbox)\n        layout.addWidget(self.snap_to_grid_checkbox)\n        self.createGridWidget()\n        layout.addWidget(self.grid_widget)\n        layout.addStretch(1)\n\n        grid_tab = QtWidgets.QWidget()\n        grid_tab.setLayout(layout)\n        self.tabs.addTab(create_scroll_area(grid_tab), 'Grid Options')\n\n    def createCustomPlaneBox(self):\n        self.custom_plane_widget = QtWidgets.QWidget(self)\n        layout = QtWidgets.QVBoxLayout()\n\n        self.form_group = FormGroup(FormGroup.Layout.Horizontal)\n        self.x_axis = FormControl('X', 1.0, required=True, number=True)\n        self.x_axis.range(-1.0, 1.0)\n        self.y_axis = FormControl('Y', 0.0, required=True, number=True)\n        self.y_axis.range(-1.0, 1.0)\n        self.z_axis = FormControl('Z', 0.0, required=True, number=True)\n        self.z_axis.range(-1.0, 1.0)\n        self.form_group.addControl(self.x_axis)\n        self.form_group.addControl(self.y_axis)\n        self.form_group.addControl(self.z_axis)\n        self.form_group.groupValidation.connect(self.setCustomPlane)\n\n        layout.addWidget(self.form_group)\n        self.custom_plane_widget.setLayout(layout)\n\n    def createLineToolWidget(self):\n        self.line_tool_widget = QtWidgets.QWidget(self)\n        layout = QtWidgets.QHBoxLayout()\n        layout.setContentsMargins(0, 20, 0, 0)\n        layout.addWidget(QtWidgets.QLabel('Number of Points: '))\n        self.line_point_count_spinbox = QtWidgets.QSpinBox()\n        self.line_point_count_spinbox.setValue(self.scene.line_tool_size)\n        self.line_point_count_spinbox.setRange(2, 100)\n        self.line_point_count_spinbox.valueChanged.connect(self.scene.setLineToolSize)\n\n        layout.addWidget(self.line_point_count_spinbox)\n        self.line_tool_widget.setVisible(False)\n        self.line_tool_widget.setLayout(layout)\n\n    def createAreaToolWidget(self):\n        self.area_tool_widget = QtWidgets.QWidget(self)\n        layout = QtWidgets.QHBoxLayout()\n        layout.setContentsMargins(0, 20, 0, 0)\n        layout.addWidget(QtWidgets.QLabel('Number of Points: '))\n        self.area_x_spinbox = QtWidgets.QSpinBox()\n        self.area_x_spinbox.setValue(self.scene.area_tool_size[0])\n        self.area_x_spinbox.setRange(2, 100)\n        self.area_y_spinbox = QtWidgets.QSpinBox()\n        self.area_y_spinbox.setValue(self.scene.area_tool_size[1])\n        self.area_y_spinbox.setRange(2, 100)\n\n        stretch_factor = 3\n        layout.addStretch(1)\n        layout.addWidget(QtWidgets.QLabel('X: '))\n        self.area_x_spinbox.valueChanged.connect(lambda: self.scene.setAreaToolSize(self.area_x_spinbox.value(),\n                                                                                    self.area_y_spinbox.value()))\n        layout.addWidget(self.area_x_spinbox, stretch_factor)\n        layout.addStretch(1)\n        layout.addWidget(QtWidgets.QLabel('Y: '))\n        self.area_y_spinbox.valueChanged.connect(lambda: self.scene.setAreaToolSize(self.area_x_spinbox.value(),\n                                                                                    self.area_y_spinbox.value()))\n        layout.addWidget(self.area_y_spinbox, stretch_factor)\n        self.area_tool_widget.setVisible(False)\n        self.area_tool_widget.setLayout(layout)\n\n    def createGridWidget(self):\n        self.grid_widget = QtWidgets.QWidget(self)\n        main_layout = QtWidgets.QVBoxLayout()\n        main_layout.setContentsMargins(0, 20, 0, 0)\n        layout = QtWidgets.QHBoxLayout()\n        layout.addWidget(QtWidgets.QLabel('Grid Type: '))\n        grid_combobox = QtWidgets.QComboBox()\n        grid_combobox.setView(QtWidgets.QListView())\n        grid_combobox.addItems([g.value for g in Grid.Type])\n        grid_combobox.currentTextChanged.connect(lambda value: self.setGridType(Grid.Type(value)))\n        layout.addWidget(grid_combobox)\n        main_layout.addLayout(layout)\n        main_layout.addSpacing(20)\n\n        layout = QtWidgets.QHBoxLayout()\n        layout.addWidget(QtWidgets.QLabel('Grid Size: '))\n        self.grid_x_label = QtWidgets.QLabel('')\n        self.grid_x_spinbox = QtWidgets.QDoubleSpinBox()\n        self.grid_x_spinbox.setDecimals(1)\n        self.grid_x_spinbox.setSingleStep(0.1)\n        self.grid_x_spinbox.valueChanged.connect(self.changeGridSize)\n        self.grid_y_label = QtWidgets.QLabel('')\n        self.grid_y_spinbox = QtWidgets.QDoubleSpinBox()\n        self.grid_y_spinbox.setDecimals(1)\n        self.grid_y_spinbox.setSingleStep(0.1)\n        self.grid_y_spinbox.valueChanged.connect(self.changeGridSize)\n        stretch_factor = 3\n        layout.addStretch(1)\n        layout.addWidget(self.grid_x_label)\n        layout.addWidget(self.grid_x_spinbox, stretch_factor)\n        layout.addStretch(1)\n        layout.addWidget(self.grid_y_label)\n        layout.addWidget(self.grid_y_spinbox, stretch_factor)\n        main_layout.addLayout(layout)\n        self.setGridType(self.view.grid.type)\n        self.grid_widget.setVisible(False)\n        self.grid_widget.setLayout(main_layout)\n\n    def changeGridSize(self):\n        if self.view.grid.type == Grid.Type.Box:\n            grid_x = int(self.grid_x_spinbox.value() * self.sample_scale)\n            grid_y = int(self.grid_y_spinbox.value() * self.sample_scale)\n        else:\n            grid_x = int(self.grid_x_spinbox.value() * self.sample_scale)\n            grid_y = self.grid_y_spinbox.value()\n        self.view.setGridSize((grid_x, grid_y))\n\n    def setGridType(self, grid_type):\n        self.view.setGridType(grid_type)\n        size = self.view.grid.size\n        if grid_type == Grid.Type.Box:\n            self.grid_x_label.setText('X (mm): ')\n            self.grid_y_label.setText('Y (mm): ')\n            self.grid_x_spinbox.setValue(size[0])\n            self.grid_y_spinbox.setValue(size[1])\n            self.grid_x_spinbox.setRange(0.1, 1000)\n            self.grid_y_spinbox.setRange(0.1, 1000)\n        else:\n            self.grid_x_label.setText('Radius (mm): ')\n            self.grid_y_label.setText('Angle (degree): ')\n            self.grid_x_spinbox.setValue(size[0])\n            self.grid_y_spinbox.setValue(size[1])\n            self.grid_x_spinbox.setRange(0.1, 1000)\n            self.grid_y_spinbox.setRange(0.1, 360)\n\n    def changeSceneMode(self, button_id):\n        self.scene.mode = GraphicsScene.Mode(button_id)\n        self.line_tool_widget.setVisible(self.scene.mode == GraphicsScene.Mode.Draw_line)\n        self.area_tool_widget.setVisible(self.scene.mode == GraphicsScene.Mode.Draw_area)\n\n    def showHelp(self):\n        self.view.show_help = False if self.view.has_foreground else True\n        self.scene.update()\n\n    def showGrid(self, state):\n        self.view.show_grid = True if state == QtCore.Qt.Checked else False\n        self.snap_to_grid_checkbox.setEnabled(self.view.show_grid)\n        self.grid_widget.setVisible(self.view.show_grid)\n        self.scene.update()\n\n    def snapToGrid(self, state):\n        self.view.snap_to_grid = True if state == QtCore.Qt.Checked else False\n\n    def updateSlider(self, value):\n        if not self.plane_lineedit.hasAcceptableInput():\n            return\n\n        new_distance = clamp(float(value), *self.plane_offset_range)\n        slider_value = int(map_range(*self.plane_offset_range, *self.slider_range, new_distance))\n        self.plane_slider.setValue(slider_value)\n\n        offset = new_distance - self.old_distance\n        self.parent.scenes.movePlane(offset * self.plane.normal)\n        self.old_distance = new_distance\n\n    def updateLineEdit(self, value):\n        new_distance = trunc(map_range(*self.slider_range, *self.plane_offset_range, value), 3)\n        self.plane_lineedit.setText('{:.3f}'.format(new_distance))\n\n        offset = new_distance - self.old_distance\n        self.parent.scenes.movePlane(offset * self.plane.normal)\n        self.old_distance = new_distance\n\n    def movePlane(self):\n        distance = clamp(float(self.plane_lineedit.text()), *self.plane_offset_range)\n        self.plane_lineedit.setText('{:.3f}'.format(distance))\n        point = distance * self.plane.normal\n        self.plane = Plane(self.plane.normal, point)\n        self.updateCrossSection()\n\n    def setCustomPlane(self, is_valid):\n        if is_valid:\n            normal = np.array([self.x_axis.value, self.y_axis.value, self.z_axis.value])\n            try:\n                self.initializePlane(normal, self.mesh.bounding_box.center)\n            except ValueError:\n                self.x_axis.validation_label.setText('Bad Normal')\n\n    def setPlane(self, selected_text):\n        if selected_text == PlaneOptions.Custom.value:\n            self.custom_plane_widget.setVisible(True)\n            self.form_group.validateGroup()\n            return\n        else:\n            self.custom_plane_widget.setVisible(False)\n\n        if selected_text == PlaneOptions.XY.value:\n            plane_normal = np.array([0., 0., 1.])\n        elif selected_text == PlaneOptions.XZ.value:\n            plane_normal = np.array([0., 1., 0.])\n        else:\n            plane_normal = np.array([1., 0., 0.])\n\n        self.initializePlane(plane_normal, self.mesh.bounding_box.center)\n\n    def initializePlane(self, plane_normal, plane_point):\n        self.plane = Plane(plane_normal, plane_point)\n        plane_size = self.mesh.bounding_box.radius\n\n        self.parent.scenes.drawPlane(self.plane, 2 * plane_size, 2 * plane_size)\n        distance = self.plane.distanceFromOrigin()\n        self.plane_offset_range = (distance - plane_size, distance + plane_size)\n        slider_value = int(map_range(*self.plane_offset_range, *self.slider_range, distance))\n        self.plane_slider.setValue(slider_value)\n        self.plane_lineedit.setText('{:.3f}'.format(distance))\n        self.old_distance = distance\n        # inverted the normal so that the y-axis is flipped\n        self.matrix = self.__lookAt(-Vector3(self.plane.normal))\n        self.view.resetTransform()\n        self.updateCrossSection()\n\n    def updateCrossSection(self):\n        self.scene.clear()\n        segments = mesh_plane_intersection(self.mesh, self.plane)\n        if len(segments) == 0:\n            return\n        segments = np.array(segments)\n\n        item = QtWidgets.QGraphicsPathItem()\n        cross_section_path = QtGui.QPainterPath()\n        rotated_segments = self.sample_scale * (segments @ self.matrix)\n        for i in range(0, rotated_segments.shape[0], 2):\n            start = rotated_segments[i, :]\n            cross_section_path.moveTo(start[0], start[1])\n            end = rotated_segments[i + 1, :]\n            cross_section_path.lineTo(end[0], end[1])\n        item.setPath(cross_section_path)\n        item.setPen(self.path_pen)\n        item.setTransform(self.view.scene_transform)\n        self.scene.addItem(item)\n        rect = item.boundingRect()\n        anchor = rect.center()\n\n        ab = self.plane.point - self.parent_model.measurement_points.points\n        d = np.einsum('ij,ij->i', np.expand_dims(self.plane.normal, axis=0), ab)\n        index = np.where(np.abs(d) < VECTOR_EPS)[0]\n        rotated_points = self.parent_model.measurement_points.points[index, :]\n        rotated_points = rotated_points @ self.matrix\n\n        for i, p in zip(index, rotated_points):\n            point = QtCore.QPointF(p[0], p[1]) * self.sample_scale\n            point = self.view.scene_transform.map(point)\n            item = GraphicsPointItem(point, size=self.scene.point_size)\n            item.setToolTip(f'Point {i + 1}')\n            item.fixed = True\n            item.makeControllable(self.scene.mode == GraphicsScene.Mode.Select)\n            item.setPen(self.point_pen)\n            self.scene.addItem(item)\n            rect = rect.united(item.boundingRect().translated(point))\n\n        # calculate new rectangle that encloses original rect with a different anchor\n        rect.united(rect.translated(anchor - rect.center()))\n        self.view.setSceneRect(rect)\n        self.view.fitInView(rect, QtCore.Qt.KeepAspectRatio)\n        self.view.anchor = rect\n\n    @staticmethod\n    def __lookAt(forward):\n        rot_matrix = Matrix33.identity()\n        up = Vector3([0., -1., 0.]) if -VECTOR_EPS < forward[1] < VECTOR_EPS else Vector3([0., 0., 1.])\n        left = up ^ forward\n        left.normalize()\n        up = forward ^ left\n\n        rot_matrix.c1[:3] = left\n        rot_matrix.c2[:3] = up\n        rot_matrix.c3[:3] = forward\n\n        return rot_matrix\n\n    def addPoints(self):\n        if len(self.scene.items()) < 2:\n            return\n\n        points_2d = []\n        transform = self.view.scene_transform.inverted()[0]\n        for item in self.scene.items():\n            if isinstance(item, GraphicsPointItem) and not item.fixed:\n                pos = transform.map(item.pos()) / self.sample_scale\n                # negate distance due to inverted normal when creating matrix\n                points_2d.append([pos.x(), pos.y(), -self.old_distance])\n                self.scene.removeItem(item)\n\n        if not points_2d:\n            return\n\n        points = points_2d[::-1] @ self.matrix.transpose()\n        enabled = [True] * points.shape[0]\n        self.parent.presenter.addPoints(list(zip(points, enabled)), PointType.Measurement, False)\n\n\nclass AlignSample(QtWidgets.QWidget):\n    \"\"\"Provides UI for aligning sample on instrument with 6D pose\n\n    :param parent: Main window\n    :type parent: MainWindow\n    \"\"\"\n    dock_flag = DockFlag.Upper\n\n    def __init__(self, parent):\n        super().__init__(parent)\n        self.parent = parent\n        self.parent.scenes.switchToInstrumentScene()\n        self.title = 'Align Sample with 6D pose'\n        self.setMinimumWidth(450)\n\n        self.main_layout = QtWidgets.QVBoxLayout()\n        self.setLayout(self.main_layout)\n        self.main_layout.addSpacing(20)\n        self.main_layout.addWidget(FormTitle('Create Transformation for Alignment'))\n        self.main_layout.addSpacing(10)\n\n        self.main_layout.addWidget(QtWidgets.QLabel('Translation along the X, Y, and Z axis (mm):'))\n        self.position_form_group = FormGroup(FormGroup.Layout.Horizontal)\n        self.x_position = FormControl('X', 0.0, required=True, number=True)\n        self.y_position = FormControl('Y', 0.0, required=True, number=True)\n        self.z_position = FormControl('Z', 0.0, required=True, number=True)\n        self.position_form_group.addControl(self.x_position)\n        self.position_form_group.addControl(self.y_position)\n        self.position_form_group.addControl(self.z_position)\n        self.position_form_group.groupValidation.connect(self.formValidation)\n        self.main_layout.addWidget(self.position_form_group)\n\n        self.main_layout.addWidget(QtWidgets.QLabel('Rotation around the X, Y, and Z axis (degrees):'))\n        self.orientation_form_group = FormGroup(FormGroup.Layout.Horizontal)\n        self.x_rotation = FormControl('X', 0.0, required=True, number=True)\n        self.x_rotation.range(-360.0, 360.0)\n        self.y_rotation = FormControl('Y', 0.0, required=True, number=True)\n        self.y_rotation.range(-360.0, 360.0)\n        self.z_rotation = FormControl('Z', 0.0, required=True, number=True)\n        self.z_rotation.range(-360.0, 360.0)\n        self.orientation_form_group.addControl(self.x_rotation)\n        self.orientation_form_group.addControl(self.y_rotation)\n        self.orientation_form_group.addControl(self.z_rotation)\n        self.orientation_form_group.groupValidation.connect(self.formValidation)\n        self.main_layout.addWidget(self.orientation_form_group)\n\n        button_layout = QtWidgets.QHBoxLayout()\n        self.execute_button = QtWidgets.QPushButton('Align Sample')\n        self.execute_button.clicked.connect(self.executeButtonClicked)\n        button_layout.addWidget(self.execute_button)\n        button_layout.addStretch(1)\n        self.main_layout.addLayout(button_layout)\n        self.main_layout.addStretch(1)\n\n    def formValidation(self):\n        if self.position_form_group.valid and self.orientation_form_group.valid:\n            self.execute_button.setEnabled(True)\n        else:\n            self.execute_button.setDisabled(True)\n\n    def executeButtonClicked(self):\n        pose = [self.x_position.value, self.y_position.value, self.z_position.value,\n                self.z_rotation.value, self.y_rotation.value, self.x_rotation.value]\n\n        self.parent.presenter.alignSampleWithPose(pose)\n        \n\n        \n        self.\n        \n        self.\n        \n        \n\n        \n        \n\n        )\n\n        \n        \n        \n        \n        \n\n        \n\n        \n        )\n\n        return\n        )\n        \n\n",
    "after": "import numpy as np\nfrom PyQt5 import QtCore, QtGui, QtWidgets\nfrom sscanss.config import path_for, settings\nfrom sscanss.core.math import Plane, Matrix33, Vector3, clamp, map_range, trunc, VECTOR_EPS\nfrom sscanss.core.geometry import mesh_plane_intersection\nfrom sscanss.core.util import Primitives, DockFlag, StrainComponents, PointType, PlaneOptions, Attributes\nfrom sscanss.ui.widgets import (FormGroup, FormControl, GraphicsView, GraphicsScene, create_tool_button, FormTitle,\n                                create_scroll_area, CompareValidator, GraphicsPointItem, Grid, create_icon)\nfrom .managers import PointManager\n\n\nclass InsertPrimitiveDialog(QtWidgets.QWidget):\n    \"\"\"Provides UI for typing in measurement/fiducial points\n\n    :param primitive: primitive type\n    :type primitive: Primitives\n    :param parent: Main window\n    :type parent: MainWindow\n    \"\"\"\n    dock_flag = DockFlag.Upper\n\n    def __init__(self, primitive, parent):\n        super().__init__(parent)\n        self.parent = parent\n        self.parent_model = self.parent.presenter.model\n        self.parent.scenes.switchToSampleScene()\n        self.primitive = primitive\n\n        self.main_layout = QtWidgets.QVBoxLayout()\n\n        self.textboxes = {}\n        name = self.parent_model.uniqueKey(self.primitive.value)\n        self.mesh_args = {'name': name}\n        if self.primitive == Primitives.Tube:\n            self.mesh_args.update({'outer_radius': 100.000, 'inner_radius': 50.000, 'height': 200.000})\n        elif self.primitive == Primitives.Sphere:\n            self.mesh_args.update({'radius': 100.000})\n        elif self.primitive == Primitives.Cylinder:\n            self.mesh_args.update({'radius': 100.000, 'height': 200.000})\n        else:\n            self.mesh_args.update({'width': 50.000, 'height': 100.000, 'depth': 200.000})\n\n        self.createPrimitiveSwitcher()\n        self.createFormInputs()\n\n        button_layout = QtWidgets.QHBoxLayout()\n        self.create_primitive_button = QtWidgets.QPushButton('Create')\n        self.create_primitive_button.clicked.connect(self.createPrimiviteButtonClicked)\n        button_layout.addWidget(self.create_primitive_button)\n        button_layout.addStretch(1)\n\n        self.main_layout.addLayout(button_layout)\n        self.main_layout.addStretch(1)\n\n        self.setLayout(self.main_layout)\n\n        self.title = 'Insert {}'.format(self.primitive.value)\n        self.setMinimumWidth(450)\n        self.textboxes['name'].setFocus()\n\n    def createPrimitiveSwitcher(self):\n        switcher_layout = QtWidgets.QHBoxLayout()\n        switcher = create_tool_button(style_name='MenuButton', status_tip='Open dialog for a different primitive')\n        switcher.setArrowType(QtCore.Qt.DownArrow)\n        switcher.setPopupMode(QtWidgets.QToolButton.InstantPopup)\n        switcher.setMenu(self.parent.primitives_menu)\n        switcher_layout.addStretch(1)\n        switcher_layout.addWidget(switcher)\n        self.main_layout.addLayout(switcher_layout)\n\n    def createFormInputs(self):\n        self.form_group = FormGroup()\n        for key, value in self.mesh_args.items():\n            pretty_label = key.replace('_', ' ').title()\n\n            if key == 'name':\n                control = FormControl(pretty_label, value, required=True)\n                control.form_lineedit.textChanged.connect(self.nameCheck)\n            else:\n                control = FormControl(pretty_label, value, desc='mm', required=True, number=True)\n                control.range(0, None, min_exclusive=True)\n\n            self.textboxes[key] = control\n            self.form_group.addControl(control)\n\n        if self.primitive == Primitives.Tube:\n            outer_radius = self.textboxes['outer_radius']\n            inner_radius = self.textboxes['inner_radius']\n\n            outer_radius.compareWith(inner_radius, CompareValidator.Operator.Greater)\n            inner_radius.compareWith(outer_radius, CompareValidator.Operator.Less)\n\n        self.main_layout.addWidget(self.form_group)\n        self.form_group.groupValidation.connect(self.formValidation)\n\n    def nameCheck(self, value):\n        if self.parent_model.all_sample_key == value:\n            self.textboxes['name'].isInvalid(f'\"{self.parent_model.all_sample_key}\" is a reserved name')\n\n    def formValidation(self, is_valid):\n        if is_valid:\n            self.create_primitive_button.setEnabled(True)\n        else:\n            self.create_primitive_button.setDisabled(True)\n\n    def createPrimiviteButtonClicked(self):\n        for key, textbox in self.textboxes.items():\n            value = textbox.value\n            self.mesh_args[key] = value\n\n        self.parent.presenter.addPrimitive(self.primitive, self.mesh_args)\n        new_name = self.parent_model.uniqueKey(self.primitive.value)\n        self.textboxes['name'].value = new_name\n\n\nclass InsertPointDialog(QtWidgets.QWidget):\n    \"\"\"Provides UI for typing in measurement/fiducial points\n\n    :param point_type: point type\n    :type point_type: PointType\n    :param parent: Main window\n    :type parent: MainWindow\n    \"\"\"\n    dock_flag = DockFlag.Upper\n\n    def __init__(self, point_type, parent):\n        super().__init__(parent)\n        self.parent = parent\n        self.parent_model = parent.presenter.model\n        self.parent.scenes.switchToSampleScene()\n        self.point_type = point_type\n        self.title = 'Add {} Point'.format(point_type.value)\n        self.main_layout = QtWidgets.QVBoxLayout()\n        unit = 'mm'\n        self.form_group = FormGroup()\n        self.x_axis = FormControl('X', 0.0, required=True, desc=unit, number=True)\n        self.y_axis = FormControl('Y', 0.0, required=True, desc=unit, number=True)\n        self.z_axis = FormControl('Z', 0.0, required=True, desc=unit, number=True)\n        self.form_group.addControl(self.x_axis)\n        self.form_group.addControl(self.y_axis)\n        self.form_group.addControl(self.z_axis)\n        self.form_group.groupValidation.connect(self.formValidation)\n        button_layout = QtWidgets.QHBoxLayout()\n        self.execute_button = QtWidgets.QPushButton(self.title)\n        self.execute_button.clicked.connect(self.executeButtonClicked)\n        button_layout.addWidget(self.execute_button)\n        button_layout.addStretch(1)\n\n        self.main_layout.addWidget(self.form_group)\n        self.main_layout.addLayout(button_layout)\n        self.main_layout.addStretch(1)\n        self.setLayout(self.main_layout)\n\n        self.setMinimumWidth(450)\n\n    def formValidation(self, is_valid):\n        if is_valid:\n            self.execute_button.setEnabled(True)\n        else:\n            self.execute_button.setDisabled(True)\n\n    def executeButtonClicked(self):\n        point = [self.x_axis.value, self.y_axis.value, self.z_axis.value]\n        self.parent.presenter.addPoints([(point, True)], self.point_type)\n\n\nclass InsertVectorDialog(QtWidgets.QWidget):\n    \"\"\"Provides UI for adding measurement vectors using a variety of methods\n\n    :param parent: Main window\n    :type parent: MainWindow\n    \"\"\"\n    dock_flag = DockFlag.Upper\n\n    def __init__(self, parent):\n        super().__init__(parent)\n        self.parent = parent\n        self.parent_model = parent.presenter.model\n        self.parent.scenes.switchToSampleScene()\n        self.title = 'Add Measurement Vectors'\n        self.main_layout = QtWidgets.QVBoxLayout()\n        spacing = 10\n        self.main_layout.addSpacing(spacing)\n        self.main_layout.addWidget(QtWidgets.QLabel('Measurement Point:'))\n        self.points_combobox = QtWidgets.QComboBox()\n        self.points_combobox.setView(QtWidgets.QListView())\n        self.main_layout.addWidget(self.points_combobox)\n        self.updatePointList()\n        self.main_layout.addSpacing(spacing)\n\n        layout = QtWidgets.QHBoxLayout()\n        alignment_layout = QtWidgets.QVBoxLayout()\n        alignment_layout.addWidget(QtWidgets.QLabel('Alignment:'))\n        self.alignment_combobox = QtWidgets.QComboBox()\n        self.alignment_combobox.setView(QtWidgets.QListView())\n        self.alignment_combobox.setInsertPolicy(QtWidgets.QComboBox.InsertAtCurrent)\n        self.updateAlignment()\n        self.alignment_combobox.activated.connect(self.addNewAlignment)\n        self.alignment_combobox.currentIndexChanged.connect(self.changeRenderedAlignment)\n        alignment_layout.addWidget(self.alignment_combobox)\n        alignment_layout.addSpacing(spacing)\n        layout.addLayout(alignment_layout)\n\n        self.detector_combobox = QtWidgets.QComboBox()\n        self.detector_combobox.setView(QtWidgets.QListView())\n        self.detector_combobox.addItems(list(self.parent_model.instrument.detectors.keys()))\n        if len(self.parent_model.instrument.detectors) > 1:\n            detector_layout = QtWidgets.QVBoxLayout()\n            detector_layout.addWidget(QtWidgets.QLabel('Detector:'))\n            detector_layout.addWidget(self.detector_combobox)\n            size = self.detector_combobox.iconSize()\n            self.detector_combobox.setItemIcon(0, create_icon(settings.value(settings.Key.Vector_1_Colour), size))\n            self.detector_combobox.setItemIcon(1, create_icon(settings.value(settings.Key.Vector_2_Colour), size))\n            detector_layout.addSpacing(spacing)\n            layout.addSpacing(spacing)\n            layout.addLayout(detector_layout)\n\n        self.main_layout.addLayout(layout)\n\n        self.main_layout.addWidget(QtWidgets.QLabel('Strain Component:'))\n        self.component_combobox = QtWidgets.QComboBox()\n        self.component_combobox.setView(QtWidgets.QListView())\n        strain_components = [s.value for s in StrainComponents]\n        self.component_combobox.addItems(strain_components)\n        self.component_combobox.currentTextChanged.connect(self.toggleKeyInBox)\n        self.main_layout.addWidget(self.component_combobox)\n        self.main_layout.addSpacing(spacing)\n\n        button_layout = QtWidgets.QHBoxLayout()\n        self.execute_button = QtWidgets.QPushButton(self.title)\n        self.execute_button.clicked.connect(self.executeButtonClicked)\n        button_layout.addWidget(self.execute_button)\n        button_layout.addStretch(1)\n\n        self.createKeyInBox()\n\n        self.reverse_checkbox = QtWidgets.QCheckBox('Reverse Direction of Vector')\n        self.main_layout.addWidget(self.reverse_checkbox)\n        self.main_layout.addSpacing(spacing)\n\n        self.main_layout.addLayout(button_layout)\n        self.main_layout.addStretch(1)\n        self.setLayout(self.main_layout)\n        self.parent_model.measurement_points_changed.connect(self.updatePointList)\n        self.parent_model.measurement_vectors_changed.connect(self.updateAlignment)\n        self.parent.scenes.rendered_alignment_changed.connect(self.alignment_combobox.setCurrentIndex)\n        self.setMinimumWidth(450)\n\n    def updatePointList(self):\n        self.points_combobox.clear()\n        point_list = ['All Points']\n        point_list.extend(['{}'.format(i+1) for i in range(self.parent_model.measurement_points.size)])\n        self.points_combobox.addItems(point_list)\n\n    def updateAlignment(self):\n        align_count = self.parent_model.measurement_vectors.shape[2]\n        if align_count != self.alignment_combobox.count() - 1:\n            self.alignment_combobox.clear()\n            alignment_list = ['{}'.format(i + 1) for i in range(align_count)]\n            alignment_list.append('Add New...')\n            self.alignment_combobox.addItems(alignment_list)\n\n        self.alignment_combobox.setCurrentIndex(self.parent.scenes.rendered_alignment)\n\n    def addNewAlignment(self, index):\n        if index == self.alignment_combobox.count() - 1:\n            self.alignment_combobox.insertItem(index, '{}'.format(index + 1))\n            self.alignment_combobox.setCurrentIndex(index)\n\n    def changeRenderedAlignment(self, index):\n        align_count = self.parent_model.measurement_vectors.shape[2]\n        if 0 <= index < align_count:\n            self.parent.scenes.changeRenderedAlignment(index)\n        elif index >= align_count:\n            self.parent.scenes.changeVisibility(Attributes.Vectors, False)\n\n    def toggleKeyInBox(self, selected_text):\n        strain_component = StrainComponents(selected_text)\n        if strain_component == StrainComponents.custom:\n            self.key_in_box.setVisible(True)\n            self.form_group.validateGroup()\n        else:\n            self.key_in_box.setVisible(False)\n            self.execute_button.setEnabled(True)\n\n    def createKeyInBox(self):\n        self.key_in_box = QtWidgets.QWidget(self)\n        layout = QtWidgets.QVBoxLayout()\n\n        self.form_group = FormGroup(FormGroup.Layout.Horizontal)\n        self.x_axis = FormControl('X', 1.0, required=True, number=True, decimals=7)\n        self.x_axis.range(-1.0, 1.0)\n        self.y_axis = FormControl('Y', 0.0, required=True, number=True, decimals=7)\n        self.y_axis.range(-1.0, 1.0)\n        self.z_axis = FormControl('Z', 0.0, required=True, number=True, decimals=7)\n        self.z_axis.range(-1.0, 1.0)\n        self.form_group.addControl(self.x_axis)\n        self.form_group.addControl(self.y_axis)\n        self.form_group.addControl(self.z_axis)\n        self.form_group.groupValidation.connect(self.formValidation)\n\n        layout.addWidget(self.form_group)\n        self.key_in_box.setLayout(layout)\n        self.main_layout.addWidget(self.key_in_box)\n        self.toggleKeyInBox(self.component_combobox.currentText())\n\n    def formValidation(self, is_valid):\n        self.execute_button.setDisabled(True)\n        if is_valid:\n            if np.linalg.norm([self.x_axis.value, self.y_axis.value, self.z_axis.value]) > VECTOR_EPS:\n                self.x_axis.validation_label.setText('')\n                self.execute_button.setEnabled(True)\n            else:\n                self.x_axis.validation_label.setText('Bad Normal')\n\n    def executeButtonClicked(self):\n        points = self.points_combobox.currentIndex() - 1\n\n        selected_text = self.component_combobox.currentText()\n        strain_component = StrainComponents(selected_text)\n\n        alignment = self.alignment_combobox.currentIndex()\n        detector = self.detector_combobox.currentIndex()\n        check_state = self.reverse_checkbox.checkState()\n        reverse = True if check_state == QtCore.Qt.Checked else False\n\n        if strain_component == StrainComponents.custom:\n            vector = [self.x_axis.value, self.y_axis.value, self.z_axis.value]\n        else:\n            vector = None\n\n        self.parent.presenter.addVectors(points, strain_component, alignment, detector,\n                                         key_in=vector, reverse=reverse)\n        # New vectors are drawn by the scene manager after function ends\n        self.parent.scenes._rendered_alignment = alignment\n\n    def closeEvent(self, event):\n        self.parent.scenes.changeRenderedAlignment(0)\n        event.accept()\n\n\nclass PickPointDialog(QtWidgets.QWidget):\n    \"\"\"Provides UI for selecting measurement points on a cross section of the sample\n\n    :param parent: Main window\n    :type parent: MainWindow\n    \"\"\"\n    dock_flag = DockFlag.Full\n\n    def __init__(self, parent):\n        super().__init__(parent)\n        self.parent = parent\n        self.parent_model = parent.presenter.model\n        self.parent.scenes.switchToSampleScene()\n        self.title = 'Add Measurement Points Graphically'\n        self.setMinimumWidth(500)\n\n        self.plane_offset_range = (-1., 1.)\n        self.slider_range = (-10000000, 10000000)\n\n        self.sample_scale = 20\n        self.path_pen = QtGui.QPen(QtGui.QColor(255, 0, 0),  0)\n        self.point_pen = QtGui.QPen(QtGui.QColor(200, 0, 0),  0)\n\n        self.main_layout = QtWidgets.QVBoxLayout()\n        self.setLayout(self.main_layout)\n        button_layout = QtWidgets.QHBoxLayout()\n        self.help_button = create_tool_button(tooltip='Help', style_name='ToolButton',\n                                              status_tip='Display shortcuts for the cross-section view',\n                                              icon_path=path_for('question.png'))\n        self.help_button.clicked.connect(self.showHelp)\n\n        self.reset_button = create_tool_button(tooltip='Reset View', style_name='ToolButton',\n                                               status_tip='Reset camera transformation of the cross-section view',\n                                               icon_path=path_for('refresh.png'))\n        self.execute_button = QtWidgets.QPushButton('Add Points')\n        self.execute_button.clicked.connect(self.addPoints)\n        button_layout.addWidget(self.help_button)\n        button_layout.addWidget(self.reset_button)\n        button_layout.addStretch(1)\n        button_layout.addWidget(self.execute_button)\n        self.main_layout.addLayout(button_layout)\n\n        self.splitter = QtWidgets.QSplitter(QtCore.Qt.Vertical)\n        self.splitter.setChildrenCollapsible(False)\n        self.main_layout.addWidget(self.splitter)\n        self.createGraphicsView()\n        self.reset_button.clicked.connect(self.view.reset)\n        self.createControlPanel()\n\n        self.prepareMesh()\n        self.parent_model.sample_changed.connect(self.prepareMesh)\n        self.parent_model.measurement_points_changed.connect(self.updateCrossSection)\n        self.initializing = True\n\n    def showEvent(self, event):\n        if self.initializing:\n            self.view.fitInView(self.view.anchor, QtCore.Qt.KeepAspectRatio)\n            self.initializing = False\n\n        super().showEvent(event)\n\n    def closeEvent(self, event):\n        self.parent.scenes.removePlane()\n        event.accept()\n\n    def prepareMesh(self):\n        self.mesh = None\n        samples = self.parent_model.sample\n        for _, sample in samples.items():\n            if self.mesh is None:\n                self.mesh = sample.copy()\n            else:\n                self.mesh.append(sample)\n\n        self.scene.clear()\n        self.tabs.setEnabled(self.mesh is not None)\n        if self.mesh is not None:\n            self.setPlane(self.plane_combobox.currentText())\n        else:\n            self.parent.scenes.removePlane()\n        self.view.reset()\n\n    def updateStatusBar(self, point):\n        if self.view.rect().contains(point):\n            transform = self.view.scene_transform.inverted()[0]\n            scene_pt = transform.map(self.view.mapToScene(point)) / self.sample_scale\n            world_pt = [scene_pt.x(), scene_pt.y(), -self.old_distance] @ self.matrix.transpose()\n            cursor_text = f'X:   {world_pt[0]:.3f}        Y:   {world_pt[1]:.3f}        Z:   {world_pt[2]:.3f}'\n            self.parent.cursor_label.setText(cursor_text)\n        else:\n            self.parent.cursor_label.clear()\n\n    def createGraphicsView(self):\n        self.scene = GraphicsScene(self.sample_scale, self)\n        self.view = GraphicsView(self.scene)\n        self.view.mouse_moved.connect(self.updateStatusBar)\n        self.view.setMinimumHeight(350)\n        self.splitter.addWidget(self.view)\n\n    def createControlPanel(self):\n        self.tabs = QtWidgets.QTabWidget()\n        self.tabs.setMinimumHeight(250)\n        self.tabs.setTabPosition(QtWidgets.QTabWidget.South)\n        self.splitter.addWidget(self.tabs)\n\n        self.createPlaneTab()\n        self.createSelectionToolsTab()\n        self.createGridOptionsTab()\n        point_manager = PointManager(PointType.Measurement, self.parent)\n        self.tabs.addTab(create_scroll_area(point_manager), 'Point Manager')\n\n    def createPlaneTab(self):\n        layout = QtWidgets.QVBoxLayout()\n        layout.addWidget(QtWidgets.QLabel('Specify Plane:'))\n        self.plane_combobox = QtWidgets.QComboBox()\n        self.plane_combobox.setView(QtWidgets.QListView())\n        self.plane_combobox.addItems([p.value for p in PlaneOptions])\n        self.plane_combobox.currentTextChanged.connect(self.setPlane)\n        self.createCustomPlaneBox()\n        layout.addWidget(self.plane_combobox)\n        layout.addWidget(self.custom_plane_widget)\n        layout.addSpacing(20)\n\n        slider_layout = QtWidgets.QHBoxLayout()\n        slider_layout.addWidget(QtWidgets.QLabel('Plane Distance from Origin (mm):'))\n        self.plane_lineedit = QtWidgets.QLineEdit()\n        validator = QtGui.QDoubleValidator(self.plane_lineedit)\n        validator.setNotation(QtGui.QDoubleValidator.StandardNotation)\n        validator.setDecimals(3)\n        self.plane_lineedit.setValidator(validator)\n        self.plane_lineedit.textEdited.connect(self.updateSlider)\n        self.plane_lineedit.editingFinished.connect(self.movePlane)\n        slider_layout.addStretch(1)\n        slider_layout.addWidget(self.plane_lineedit)\n        layout.addLayout(slider_layout)\n        self.plane_slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n        self.plane_slider.setMinimum(self.slider_range[0])\n        self.plane_slider.setMaximum(self.slider_range[1])\n        self.plane_slider.setFocusPolicy(QtCore.Qt.StrongFocus)\n        self.plane_slider.setSingleStep(1)\n        self.plane_slider.sliderMoved.connect(self.updateLineEdit)\n        self.plane_slider.sliderReleased.connect(self.movePlane)\n        layout.addWidget(self.plane_slider)\n        layout.addStretch(1)\n\n        plane_tab = QtWidgets.QWidget()\n        plane_tab.setLayout(layout)\n        self.tabs.addTab(create_scroll_area(plane_tab), 'Define Plane')\n\n    def createSelectionToolsTab(self):\n        layout = QtWidgets.QVBoxLayout()\n        selector_layout = QtWidgets.QHBoxLayout()\n        selector_layout.addWidget(QtWidgets.QLabel('Select Geometry of Points: '))\n        self.button_group = QtWidgets.QButtonGroup()\n        self.button_group.buttonClicked[int].connect(self.changeSceneMode)\n\n        self.object_selector = create_tool_button(checkable=True, checked=True, tooltip='Select Points',\n                                                  status_tip='Select movable points from the cross-section view',\n                                                  style_name='MidToolButton', icon_path=path_for('select.png'))\n        self.point_selector = create_tool_button(checkable=True, tooltip='Draw a Point',\n                                                 status_tip='Draw a single point at the selected position',\n                                                 style_name='MidToolButton', icon_path=path_for('point.png'))\n        self.line_selector = create_tool_button(checkable=True, tooltip='Draw Points on Line',\n                                                status_tip='Draw equally spaced points on the selected line',\n                                                style_name='MidToolButton', icon_path=path_for('line_tool.png'))\n        self.area_selector = create_tool_button(checkable=True, tooltip='Draw Points on Area',\n                                                status_tip='Draw a grid of points on the selected area',\n                                                style_name='MidToolButton', icon_path=path_for('area_tool.png'))\n\n        self.button_group.addButton(self.object_selector, GraphicsScene.Mode.Select.value)\n        self.button_group.addButton(self.point_selector, GraphicsScene.Mode.Draw_point.value)\n        self.button_group.addButton(self.line_selector, GraphicsScene.Mode.Draw_line.value)\n        self.button_group.addButton(self.area_selector, GraphicsScene.Mode.Draw_area.value)\n        selector_layout.addWidget(self.object_selector)\n        selector_layout.addWidget(self.point_selector)\n        selector_layout.addWidget(self.line_selector)\n        selector_layout.addWidget(self.area_selector)\n        selector_layout.addStretch(1)\n\n        self.createLineToolWidget()\n        self.createAreaToolWidget()\n\n        layout.addLayout(selector_layout)\n        layout.addWidget(self.line_tool_widget)\n        layout.addWidget(self.area_tool_widget)\n        layout.addStretch(1)\n\n        select_tab = QtWidgets.QWidget()\n        select_tab.setLayout(layout)\n        self.tabs.addTab(create_scroll_area(select_tab), 'Selection Tools')\n\n    def createGridOptionsTab(self):\n        layout = QtWidgets.QVBoxLayout()\n        self.show_grid_checkbox = QtWidgets.QCheckBox('Show Grid')\n        self.show_grid_checkbox.stateChanged.connect(self.showGrid)\n        self.snap_to_grid_checkbox = QtWidgets.QCheckBox('Snap Selection to Grid')\n        self.snap_to_grid_checkbox.stateChanged.connect(self.snapToGrid)\n        self.snap_to_grid_checkbox.setEnabled(self.view.show_grid)\n        layout.addWidget(self.show_grid_checkbox)\n        layout.addWidget(self.snap_to_grid_checkbox)\n        self.createGridWidget()\n        layout.addWidget(self.grid_widget)\n        layout.addStretch(1)\n\n        grid_tab = QtWidgets.QWidget()\n        grid_tab.setLayout(layout)\n        self.tabs.addTab(create_scroll_area(grid_tab), 'Grid Options')\n\n    def createCustomPlaneBox(self):\n        self.custom_plane_widget = QtWidgets.QWidget(self)\n        layout = QtWidgets.QVBoxLayout()\n\n        self.form_group = FormGroup(FormGroup.Layout.Horizontal)\n        self.x_axis = FormControl('X', 1.0, required=True, number=True)\n        self.x_axis.range(-1.0, 1.0)\n        self.y_axis = FormControl('Y', 0.0, required=True, number=True)\n        self.y_axis.range(-1.0, 1.0)\n        self.z_axis = FormControl('Z', 0.0, required=True, number=True)\n        self.z_axis.range(-1.0, 1.0)\n        self.form_group.addControl(self.x_axis)\n        self.form_group.addControl(self.y_axis)\n        self.form_group.addControl(self.z_axis)\n        self.form_group.groupValidation.connect(self.setCustomPlane)\n\n        layout.addWidget(self.form_group)\n        self.custom_plane_widget.setLayout(layout)\n\n    def createLineToolWidget(self):\n        self.line_tool_widget = QtWidgets.QWidget(self)\n        layout = QtWidgets.QHBoxLayout()\n        layout.setContentsMargins(0, 20, 0, 0)\n        layout.addWidget(QtWidgets.QLabel('Number of Points: '))\n        self.line_point_count_spinbox = QtWidgets.QSpinBox()\n        self.line_point_count_spinbox.setValue(self.scene.line_tool_size)\n        self.line_point_count_spinbox.setRange(2, 100)\n        self.line_point_count_spinbox.valueChanged.connect(self.scene.setLineToolSize)\n\n        layout.addWidget(self.line_point_count_spinbox)\n        self.line_tool_widget.setVisible(False)\n        self.line_tool_widget.setLayout(layout)\n\n    def createAreaToolWidget(self):\n        self.area_tool_widget = QtWidgets.QWidget(self)\n        layout = QtWidgets.QHBoxLayout()\n        layout.setContentsMargins(0, 20, 0, 0)\n        layout.addWidget(QtWidgets.QLabel('Number of Points: '))\n        self.area_x_spinbox = QtWidgets.QSpinBox()\n        self.area_x_spinbox.setValue(self.scene.area_tool_size[0])\n        self.area_x_spinbox.setRange(2, 100)\n        self.area_y_spinbox = QtWidgets.QSpinBox()\n        self.area_y_spinbox.setValue(self.scene.area_tool_size[1])\n        self.area_y_spinbox.setRange(2, 100)\n\n        stretch_factor = 3\n        layout.addStretch(1)\n        layout.addWidget(QtWidgets.QLabel('X: '))\n        self.area_x_spinbox.valueChanged.connect(lambda: self.scene.setAreaToolSize(self.area_x_spinbox.value(),\n                                                                                    self.area_y_spinbox.value()))\n        layout.addWidget(self.area_x_spinbox, stretch_factor)\n        layout.addStretch(1)\n        layout.addWidget(QtWidgets.QLabel('Y: '))\n        self.area_y_spinbox.valueChanged.connect(lambda: self.scene.setAreaToolSize(self.area_x_spinbox.value(),\n                                                                                    self.area_y_spinbox.value()))\n        layout.addWidget(self.area_y_spinbox, stretch_factor)\n        self.area_tool_widget.setVisible(False)\n        self.area_tool_widget.setLayout(layout)\n\n    def createGridWidget(self):\n        self.grid_widget = QtWidgets.QWidget(self)\n        main_layout = QtWidgets.QVBoxLayout()\n        main_layout.setContentsMargins(0, 20, 0, 0)\n        layout = QtWidgets.QHBoxLayout()\n        layout.addWidget(QtWidgets.QLabel('Grid Type: '))\n        grid_combobox = QtWidgets.QComboBox()\n        grid_combobox.setView(QtWidgets.QListView())\n        grid_combobox.addItems([g.value for g in Grid.Type])\n        grid_combobox.currentTextChanged.connect(lambda value: self.setGridType(Grid.Type(value)))\n        layout.addWidget(grid_combobox)\n        main_layout.addLayout(layout)\n        main_layout.addSpacing(20)\n\n        layout = QtWidgets.QHBoxLayout()\n        layout.addWidget(QtWidgets.QLabel('Grid Size: '))\n        self.grid_x_label = QtWidgets.QLabel('')\n        self.grid_x_spinbox = QtWidgets.QDoubleSpinBox()\n        self.grid_x_spinbox.setDecimals(1)\n        self.grid_x_spinbox.setSingleStep(0.1)\n        self.grid_x_spinbox.valueChanged.connect(self.changeGridSize)\n        self.grid_y_label = QtWidgets.QLabel('')\n        self.grid_y_spinbox = QtWidgets.QDoubleSpinBox()\n        self.grid_y_spinbox.setDecimals(1)\n        self.grid_y_spinbox.setSingleStep(0.1)\n        self.grid_y_spinbox.valueChanged.connect(self.changeGridSize)\n        stretch_factor = 3\n        layout.addStretch(1)\n        layout.addWidget(self.grid_x_label)\n        layout.addWidget(self.grid_x_spinbox, stretch_factor)\n        layout.addStretch(1)\n        layout.addWidget(self.grid_y_label)\n        layout.addWidget(self.grid_y_spinbox, stretch_factor)\n        main_layout.addLayout(layout)\n        self.setGridType(self.view.grid.type)\n        self.grid_widget.setVisible(False)\n        self.grid_widget.setLayout(main_layout)\n\n    def changeGridSize(self):\n        if self.view.grid.type == Grid.Type.Box:\n            grid_x = int(self.grid_x_spinbox.value() * self.sample_scale)\n            grid_y = int(self.grid_y_spinbox.value() * self.sample_scale)\n        else:\n            grid_x = int(self.grid_x_spinbox.value() * self.sample_scale)\n            grid_y = self.grid_y_spinbox.value()\n        self.view.setGridSize((grid_x, grid_y))\n\n    def setGridType(self, grid_type):\n        self.view.setGridType(grid_type)\n        size = self.view.grid.size\n        if grid_type == Grid.Type.Box:\n            self.grid_x_label.setText('X (mm): ')\n            self.grid_y_label.setText('Y (mm): ')\n            self.grid_x_spinbox.setValue(size[0])\n            self.grid_y_spinbox.setValue(size[1])\n            self.grid_x_spinbox.setRange(0.1, 1000)\n            self.grid_y_spinbox.setRange(0.1, 1000)\n        else:\n            self.grid_x_label.setText('Radius (mm): ')\n            self.grid_y_label.setText('Angle (degree): ')\n            self.grid_x_spinbox.setValue(size[0])\n            self.grid_y_spinbox.setValue(size[1])\n            self.grid_x_spinbox.setRange(0.1, 1000)\n            self.grid_y_spinbox.setRange(0.1, 360)\n\n    def changeSceneMode(self, button_id):\n        self.scene.mode = GraphicsScene.Mode(button_id)\n        self.line_tool_widget.setVisible(self.scene.mode == GraphicsScene.Mode.Draw_line)\n        self.area_tool_widget.setVisible(self.scene.mode == GraphicsScene.Mode.Draw_area)\n\n    def showHelp(self):\n        self.view.show_help = False if self.view.has_foreground else True\n        self.scene.update()\n\n    def showGrid(self, state):\n        self.view.show_grid = True if state == QtCore.Qt.Checked else False\n        self.snap_to_grid_checkbox.setEnabled(self.view.show_grid)\n        self.grid_widget.setVisible(self.view.show_grid)\n        self.scene.update()\n\n    def snapToGrid(self, state):\n        self.view.snap_to_grid = True if state == QtCore.Qt.Checked else False\n\n    def updateSlider(self, value):\n        if not self.plane_lineedit.hasAcceptableInput():\n            return\n\n        new_distance = clamp(float(value), *self.plane_offset_range)\n        slider_value = int(map_range(*self.plane_offset_range, *self.slider_range, new_distance))\n        self.plane_slider.setValue(slider_value)\n\n        offset = new_distance - self.old_distance\n        self.parent.scenes.movePlane(offset * self.plane.normal)\n        self.old_distance = new_distance\n\n    def updateLineEdit(self, value):\n        new_distance = trunc(map_range(*self.slider_range, *self.plane_offset_range, value), 3)\n        self.plane_lineedit.setText('{:.3f}'.format(new_distance))\n\n        offset = new_distance - self.old_distance\n        self.parent.scenes.movePlane(offset * self.plane.normal)\n        self.old_distance = new_distance\n\n    def movePlane(self):\n        distance = clamp(float(self.plane_lineedit.text()), *self.plane_offset_range)\n        self.plane_lineedit.setText('{:.3f}'.format(distance))\n        point = distance * self.plane.normal\n        self.plane = Plane(self.plane.normal, point)\n        self.updateCrossSection()\n\n    def setCustomPlane(self, is_valid):\n        if is_valid:\n            normal = np.array([self.x_axis.value, self.y_axis.value, self.z_axis.value])\n            try:\n                self.initializePlane(normal, self.mesh.bounding_box.center)\n            except ValueError:\n                self.x_axis.validation_label.setText('Bad Normal')\n\n    def setPlane(self, selected_text):\n        if selected_text == PlaneOptions.Custom.value:\n            self.custom_plane_widget.setVisible(True)\n            self.form_group.validateGroup()\n            return\n        else:\n            self.custom_plane_widget.setVisible(False)\n\n        if selected_text == PlaneOptions.XY.value:\n            plane_normal = np.array([0., 0., 1.])\n        elif selected_text == PlaneOptions.XZ.value:\n            plane_normal = np.array([0., 1., 0.])\n        else:\n            plane_normal = np.array([1., 0., 0.])\n\n        self.initializePlane(plane_normal, self.mesh.bounding_box.center)\n\n    def initializePlane(self, plane_normal, plane_point):\n        self.plane = Plane(plane_normal, plane_point)\n        plane_size = self.mesh.bounding_box.radius\n\n        self.parent.scenes.drawPlane(self.plane, 2 * plane_size, 2 * plane_size)\n        distance = self.plane.distanceFromOrigin()\n        self.plane_offset_range = (distance - plane_size, distance + plane_size)\n        slider_value = int(map_range(*self.plane_offset_range, *self.slider_range, distance))\n        self.plane_slider.setValue(slider_value)\n        self.plane_lineedit.setText('{:.3f}'.format(distance))\n        self.old_distance = distance\n        # inverted the normal so that the y-axis is flipped\n        self.matrix = self.__lookAt(-Vector3(self.plane.normal))\n        self.view.resetTransform()\n        self.updateCrossSection()\n\n    def updateCrossSection(self):\n        self.scene.clear()\n        segments = mesh_plane_intersection(self.mesh, self.plane)\n        if len(segments) == 0:\n            return\n        segments = np.array(segments)\n\n        item = QtWidgets.QGraphicsPathItem()\n        cross_section_path = QtGui.QPainterPath()\n        rotated_segments = self.sample_scale * (segments @ self.matrix)\n        for i in range(0, rotated_segments.shape[0], 2):\n            start = rotated_segments[i, :]\n            cross_section_path.moveTo(start[0], start[1])\n            end = rotated_segments[i + 1, :]\n            cross_section_path.lineTo(end[0], end[1])\n        item.setPath(cross_section_path)\n        item.setPen(self.path_pen)\n        item.setTransform(self.view.scene_transform)\n        self.scene.addItem(item)\n        rect = item.boundingRect()\n        anchor = rect.center()\n\n        ab = self.plane.point - self.parent_model.measurement_points.points\n        d = np.einsum('ij,ij->i', np.expand_dims(self.plane.normal, axis=0), ab)\n        index = np.where(np.abs(d) < VECTOR_EPS)[0]\n        rotated_points = self.parent_model.measurement_points.points[index, :]\n        rotated_points = rotated_points @ self.matrix\n\n        for i, p in zip(index, rotated_points):\n            point = QtCore.QPointF(p[0], p[1]) * self.sample_scale\n            point = self.view.scene_transform.map(point)\n            item = GraphicsPointItem(point, size=self.scene.point_size)\n            item.setToolTip(f'Point {i + 1}')\n            item.fixed = True\n            item.makeControllable(self.scene.mode == GraphicsScene.Mode.Select)\n            item.setPen(self.point_pen)\n            self.scene.addItem(item)\n            rect = rect.united(item.boundingRect().translated(point))\n\n        # calculate new rectangle that encloses original rect with a different anchor\n        rect.united(rect.translated(anchor - rect.center()))\n        self.view.setSceneRect(rect)\n        self.view.fitInView(rect, QtCore.Qt.KeepAspectRatio)\n        self.view.anchor = rect\n\n    @staticmethod\n    def __lookAt(forward):\n        rot_matrix = Matrix33.identity()\n        up = Vector3([0., -1., 0.]) if -VECTOR_EPS < forward[1] < VECTOR_EPS else Vector3([0., 0., 1.])\n        left = up ^ forward\n        left.normalize()\n        up = forward ^ left\n\n        rot_matrix.c1[:3] = left\n        rot_matrix.c2[:3] = up\n        rot_matrix.c3[:3] = forward\n\n        return rot_matrix\n\n    def addPoints(self):\n        if len(self.scene.items()) < 2:\n            return\n\n        points_2d = []\n        transform = self.view.scene_transform.inverted()[0]\n        for item in self.scene.items():\n            if isinstance(item, GraphicsPointItem) and not item.fixed:\n                pos = transform.map(item.pos()) / self.sample_scale\n                # negate distance due to inverted normal when creating matrix\n                points_2d.append([pos.x(), pos.y(), -self.old_distance])\n                self.scene.removeItem(item)\n\n        if not points_2d:\n            return\n\n        points = points_2d[::-1] @ self.matrix.transpose()\n        enabled = [True] * points.shape[0]\n        self.parent.presenter.addPoints(list(zip(points, enabled)), PointType.Measurement, False)\n\n\nclass AlignSample(QtWidgets.QWidget):\n    \"\"\"Provides UI for aligning sample on instrument with 6D pose\n\n    :param parent: Main window\n    :type parent: MainWindow\n    \"\"\"\n    dock_flag = DockFlag.Upper\n\n    def __init__(self, parent):\n        super().__init__(parent)\n        self.parent = parent\n        self.parent.scenes.switchToInstrumentScene()\n        self.title = 'Align Sample with 6D pose'\n        self.setMinimumWidth(450)\n\n        self.main_layout = QtWidgets.QVBoxLayout()\n        self.setLayout(self.main_layout)\n        self.main_layout.addSpacing(20)\n        self.main_layout.addWidget(FormTitle('Create Transformation for Alignment'))\n        self.main_layout.addSpacing(10)\n\n        self.main_layout.addWidget(QtWidgets.QLabel('Translation along the X, Y, and Z axis (mm):'))\n        self.position_form_group = FormGroup(FormGroup.Layout.Horizontal)\n        self.x_position = FormControl('X', 0.0, required=True, number=True)\n        self.y_position = FormControl('Y', 0.0, required=True, number=True)\n        self.z_position = FormControl('Z', 0.0, required=True, number=True)\n        self.position_form_group.addControl(self.x_position)\n        self.position_form_group.addControl(self.y_position)\n        self.position_form_group.addControl(self.z_position)\n        self.position_form_group.groupValidation.connect(self.formValidation)\n        self.main_layout.addWidget(self.position_form_group)\n\n        self.main_layout.addWidget(QtWidgets.QLabel('Rotation around the X, Y, and Z axis (degrees):'))\n        self.orientation_form_group = FormGroup(FormGroup.Layout.Horizontal)\n        self.x_rotation = FormControl('X', 0.0, required=True, number=True)\n        self.x_rotation.range(-360.0, 360.0)\n        self.y_rotation = FormControl('Y', 0.0, required=True, number=True)\n        self.y_rotation.range(-360.0, 360.0)\n        self.z_rotation = FormControl('Z', 0.0, required=True, number=True)\n        self.z_rotation.range(-360.0, 360.0)\n        self.orientation_form_group.addControl(self.x_rotation)\n        self.orientation_form_group.addControl(self.y_rotation)\n        self.orientation_form_group.addControl(self.z_rotation)\n        self.orientation_form_group.groupValidation.connect(self.formValidation)\n        self.main_layout.addWidget(self.orientation_form_group)\n\n        button_layout = QtWidgets.QHBoxLayout()\n        self.execute_button = QtWidgets.QPushButton('Align Sample')\n        self.execute_button.clicked.connect(self.executeButtonClicked)\n        button_layout.addWidget(self.execute_button)\n        button_layout.addStretch(1)\n        self.main_layout.addLayout(button_layout)\n        self.main_layout.addStretch(1)\n\n    def formValidation(self):\n        if self.position_form_group.valid and self.orientation_form_group.valid:\n            self.execute_button.setEnabled(True)\n        else:\n            self.execute_button.setDisabled(True)\n\n    def executeButtonClicked(self):\n        pose = [self.x_position.value, self.y_position.value, self.z_position.value,\n                self.z_rotation.value, self.y_rotation.value, self.x_rotation.value]\n\n        self.parent.presenter.alignSampleWithPose(pose)\n        \n\n        \n        \n        \n        \n\n        \n\n        \n        \n        \n        \n        \n\n        \n        \n        \n        \n\n    \n\n    \n        \n        \n\n\n        \n        \n\n    \n        \n        \n\n        \n\n"
  },
  "feature_stats": {
    "indices": [
      0,
      2,
      418,
      1641,
      5597,
      8372,
      4662,
      3238,
      3787,
      5933,
      3814
    ],
    "f_before": [
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "f_after": [
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "g_before": [
      0.0,
      6.246404647827148,
      0.0,
      0.0,
      0.002256605541333556,
      0.0,
      0.012102323584258556,
      0.0,
      0.04028056189417839,
      0.03782601282000542,
      0.030125604942440987
    ],
    "g_after": [
      0.0,
      6.246404647827148,
      0.0,
      0.0,
      0.002256605541333556,
      0.0,
      0.012102323584258556,
      0.0,
      0.04028056189417839,
      0.03782601282000542,
      0.030125604942440987
    ],
    "num_batches_for_stats": 10
  },
  "loss_summary": {
    "train_mean_loss": 15.652211345553399,
    "train_mean_l2": 11.55342114698887,
    "train_mean_l1": 4.098790381908417,
    "num_steps": 1000,
    "num_batches": 1000
  },
  "feature_std_summary": {
    "plot_path": "outputs/plots/20251126-175135/feature_std_layer_12.html",
    "mean_std": 1.074162483215332,
    "max_std": 22.999488830566406
  }
}