{
  "model_name": "google/gemma-2-2b-it",
  "layer_idx": 12,
  "command": "python main.py experiment.use_multi_contrast=true sae.loss_option=2 sae.loss_module=option2_loss sae.guidance_method=contrastive sae.guidance_coeff=1.0 sae.alpha_concept.code=0.05 sae.alpha_concept.harm=0.03 sae.alpha_concept.struct=0.0 sae.use_l0=true sae.l0_coeff=0.00037731631260996427 sae.role_sep_coeff=0.0095",
  "sae": {
    "input_dim": 2304,
    "sae_dim": 9216,
    "fixed_v_cnt": 3,
    "batch_size": 3,
    "epochs": 2,
    "max_steps": 2000,
    "l1_coeff": 0.005,
    "l0_coeff": 0.00037731631260996427,
    "use_l0": true,
    "concept_samples_per_label": 100,
    "loss_option": 2,
    "loss_module": "option2_loss",
    "concept_feature_indices": {
      "code": 0,
      "harm": 1,
      "struct": 2
    },
    "alpha_concept": {
      "code": 0.05,
      "harm": 0.03,
      "struct": 0.0
    },
    "positive_targets": {
      "code": 1,
      "harm": 1,
      "struct": 1
    },
    "guidance_method": "contrastive",
    "guidance_margin": 0.0,
    "guidance_coeff": 1.0,
    "guidance_mse_pos_value": 1.0,
    "guidance_mse_neg_value": 0.0,
    "jumprelu_bandwidth": 0.001,
    "jumprelu_init_threshold": 0.001,
    "role_sep_coeff": 0.0095
  },
  "gnn": {
    "use_gnn": true,
    "top_k": 10
  },
  "experiment": {
    "device": "cuda",
    "dataset_name": "wikitext",
    "dataset_config": "wikitext-2-raw-v1",
    "use_multi_contrast": true,
    "num_steering_samples_per_label": 10,
    "top_k_for_plot": 10,
    "layer_sweep": [
      12
    ],
    "strength_sweep": [
      15.0
    ]
  },
  "steering": {
    "label": "code",
    "feature_idx": 0,
    "strength": 15.0
  },
  "prompt": "\"\"\" A Qt API selector that can be used to switch between PyQt and PySide.\n\"\"\"\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\n\nimport os\nfrom matplotlib import rcParams, verbose\n\n# Available APIs.\nQT_API_PYQT = 'PyQt4'       # API is not set here; Python 2.x default is V 1\nQT_API_PYQTv2 = 'PyQt4v2'   # forced to Version 2 API\nQT_API_PYSIDE = 'PySide'    # only supports Version 2 API\nQT_API_PYQT5 = 'PyQt5'       # use PyQt5 API; Version 2 with module shim\n\nETS = dict(pyqt=(QT_API_PYQTv2, 4), pyside=(QT_API_PYSIDE, 4),\n           pyqt5=(QT_API_PYQT5, 5))\n# ETS is a dict of env variable to (QT_API, QT_MAJOR_VERSION)\n# If the ETS QT_API environment variable is set, use it, but only\n# if the varible if of the same major QT version.  Note that\n# ETS requires the version 2 of PyQt4, which is not the platform\n# default for Python 2.x.\n\nQT_API_ENV = os.environ.get('QT_API')\n\nif rcParams['backend'] == 'Qt5Agg':\n    QT_RC_MAJOR_VERSION = 5\nelse:\n    QT_RC_MAJOR_VERSION = 4\n\nQT_API = None\n\nif (QT_API_ENV is not None):\n    try:\n        QT_ENV_MAJOR_VERSION = ETS[QT_API_ENV][1]\n    except KeyError:\n        raise RuntimeError(\n            ('Unrecognized environment variable %r, valid values are:'\n             ' %r, %r or %r' % (QT_API_ENV, 'pyqt', 'pyside', 'pyqt5')))\n    if QT_ENV_MAJOR_VERSION == QT_RC_MAJOR_VERSION:\n        # Only if backend and env qt major version are\n        # compatible use the env variable.\n        QT_API = ETS[QT_API_ENV][0]\n\nif QT_API is None:\n    # No ETS environment or incompatible so use rcParams.\n    if rcParams['backend'] == 'Qt5Agg':\n        QT_API = rcParams['backend.qt5']\n    else:\n        QT_API = rcParams['backend.qt4']\n\n# We will define an appropriate wrapper for the differing versions\n# of file dialog.\n_getSaveFileName = None\n\n# Flag to check if sip could be imported\n_sip_imported = False\n\n# Now perform the imports.\nif QT_API in (QT_API_PYQT, QT_API_PYQTv2, QT_API_PYQT5):\n    try:\n        import sip\n        _sip_imported = True\n    except ImportError:\n        # Try using PySide\n        QT_API = QT_API_PYSIDE\n        cond = (\"Could not import sip; falling back on PySide\\n\"\n                \"in place of PyQt4 or PyQt5.\\n\")\n        verbose.report(cond, 'helpful')\n\nif _sip_imported:\n    if QT_API == QT_API_PYQTv2:\n        if QT_API_ENV == 'pyqt':\n            cond = (\"Found 'QT_API=pyqt' environment variable. \"\n                    \"Setting PyQt4 API accordingly.\\n\")\n        else:\n            cond = \"PyQt API v2 specified.\"\n        try:\n            sip.setapi('QString', 2)\n        except:\n            res = 'QString API v2 specification failed. Defaulting to v1.'\n            verbose.report(cond + res, 'helpful')\n            # condition has now been reported, no need to repeat it:\n            cond = \"\"\n        try:\n            sip.setapi('QVariant', 2)\n        except:\n            res = 'QVariant API v2 specification failed. Defaulting to v1.'\n            verbose.report(cond + res, 'helpful')\n\n    if QT_API in [QT_API_PYQT, QT_API_PYQTv2]:  # PyQt4 API\n\n        from PyQt4 import QtCore, QtGui\n\n        try:\n            if sip.getapi(\"QString\") > 1:\n                # Use new getSaveFileNameAndFilter()\n                _getSaveFileName = QtGui.QFileDialog.getSaveFileNameAndFilter\n            else:\n\n                # Use old getSaveFileName()\n                def _getSaveFileName(*args, **kwargs):\n                    return (QtGui.QFileDialog.getSaveFileName(*args, **kwargs),\n                            None)\n\n        except (AttributeError, KeyError):\n\n            # call to getapi() can fail in older versions of sip\n            def _getSaveFileName(*args, **kwargs):\n                return QtGui.QFileDialog.getSaveFileName(*args, **kwargs), None\n\n    else:  # PyQt5 API\n        from PyQt5 import QtCore, QtGui, QtWidgets\n        _getSaveFileName = QtWidgets.QFileDialog.getSaveFileName\n\n    # Alias PyQt-specific functions for PySide compatibility.\n    QtCore.Signal = QtCore.pyqtSignal\n    try:\n        QtCore.Slot = QtCore.pyqtSlot\n    except AttributeError:\n        # Not a perfect match but works in simple cases\n        QtCore.Slot = QtCore.pyqtSignature\n\n    QtCore.Property = QtCore.pyqtProperty\n    __version__ = QtCore.PYQT_VERSION_STR\n\nelse:  # try importing pyside\n    try:\n        from PySide import QtCore, QtGui, __version__, __version_info__\n    except ImportError:\n        raise ImportError(\n            \"Matplotlib qt-based backends require an external PyQt4, PyQt5,\\n\"\n            \"or PySide package to be installed, but it was not found.\")\n\n    if __version_info__ < (1, 0, 3):\n        raise ImportError(\n            \"Matplotlib backend_qt4 and backend_qt4agg require PySide >=1.0.3\")\n\n    _getSaveFileName = QtGui.QFileDialog.getSaveFileName\n\n\n# Apply shim to Qt4 APIs to make them look like Qt5\nif QT_API in (QT_API_PYQT, QT_API_PYQTv2, QT_API_PYSIDE):\n    '''Import all used QtGui objects into QtWidgets\n\n    Here I've opted to simple copy QtGui into QtWidgets as that\n    achieves the same result as copying over the objects, and will\n    continue to work if other objects are used.\n\n    '''\n    QtWidgets = QtGui\n",
  "output": {
    "before": "\"\"\" A Qt API selector that can be used to switch between PyQt and PySide.\n\"\"\"\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\n\nimport os\nfrom matplotlib import rcParams, verbose\n\n# Available APIs.\nQT_API_PYQT = 'PyQt4'       # API is not set here; Python 2.x default is V 1\nQT_API_PYQTv2 = 'PyQt4v2'   # forced to Version 2 API\nQT_API_PYSIDE = 'PySide'    # only supports Version 2 API\nQT_API_PYQT5 = 'PyQt5'       # use PyQt5 API; Version 2 with module shim\n\nETS = dict(pyqt=(QT_API_PYQTv2, 4), pyside=(QT_API_PYSIDE, 4),\n           pyqt5=(QT_API_PYQT5, 5))\n# ETS is a dict of env variable to (QT_API, QT_MAJOR_VERSION)\n# If the ETS QT_API environment variable is set, use it, but only\n# if the varible if of the same major QT version.  Note that\n# ETS requires the version 2 of PyQt4, which is not the platform\n# default for Python 2.x.\n\nQT_API_ENV = os.environ.get('QT_API')\n\nif rcParams['backend'] == 'Qt5Agg':\n    QT_RC_MAJOR_VERSION = 5\nelse:\n    QT_RC_MAJOR_VERSION = 4\n\nQT_API = None\n\nif (QT_API_ENV is not None):\n    try:\n        QT_ENV_MAJOR_VERSION = ETS[QT_API_ENV][1]\n    except KeyError:\n        raise RuntimeError(\n            ('Unrecognized environment variable %r, valid values are:'\n             ' %r, %r or %r' % (QT_API_ENV, 'pyqt', 'pyside', 'pyqt5')))\n    if QT_ENV_MAJOR_VERSION == QT_RC_MAJOR_VERSION:\n        # Only if backend and env qt major version are\n        # compatible use the env variable.\n        QT_API = ETS[QT_API_ENV][0]\n\nif QT_API is None:\n    # No ETS environment or incompatible so use rcParams.\n    if rcParams['backend'] == 'Qt5Agg':\n        QT_API = rcParams['backend.qt5']\n    else:\n        QT_API = rcParams['backend.qt4']\n\n# We will define an appropriate wrapper for the differing versions\n# of file dialog.\n_getSaveFileName = None\n\n# Flag to check if sip could be imported\n_sip_imported = False\n\n# Now perform the imports.\nif QT_API in (QT_API_PYQT, QT_API_PYQTv2, QT_API_PYQT5):\n    try:\n        import sip\n        _sip_imported = True\n    except ImportError:\n        # Try using PySide\n        QT_API = QT_API_PYSIDE\n        cond = (\"Could not import sip; falling back on PySide\\n\"\n                \"in place of PyQt4 or PyQt5.\\n\")\n        verbose.report(cond, 'helpful')\n\nif _sip_imported:\n    if QT_API == QT_API_PYQTv2:\n        if QT_API_ENV == 'pyqt':\n            cond = (\"Found 'QT_API=pyqt' environment variable. \"\n                    \"Setting PyQt4 API accordingly.\\n\")\n        else:\n            cond = \"PyQt API v2 specified.\"\n        try:\n            sip.setapi('QString', 2)\n        except:\n            res = 'QString API v2 specification failed. Defaulting to v1.'\n            verbose.report(cond + res, 'helpful')\n            # condition has now been reported, no need to repeat it:\n            cond = \"\"\n        try:\n            sip.setapi('QVariant', 2)\n        except:\n            res = 'QVariant API v2 specification failed. Defaulting to v1.'\n            verbose.report(cond + res, 'helpful')\n\n    if QT_API in [QT_API_PYQT, QT_API_PYQTv2]:  # PyQt4 API\n\n        from PyQt4 import QtCore, QtGui\n\n        try:\n            if sip.getapi(\"QString\") > 1:\n                # Use new getSaveFileNameAndFilter()\n                _getSaveFileName = QtGui.QFileDialog.getSaveFileNameAndFilter\n            else:\n\n                # Use old getSaveFileName()\n                def _getSaveFileName(*args, **kwargs):\n                    return (QtGui.QFileDialog.getSaveFileName(*args, **kwargs),\n                            None)\n\n        except (AttributeError, KeyError):\n\n            # call to getapi() can fail in older versions of sip\n            def _getSaveFileName(*args, **kwargs):\n                return QtGui.QFileDialog.getSaveFileName(*args, **kwargs), None\n\n    else:  # PyQt5 API\n        from PyQt5 import QtCore, QtGui, QtWidgets\n        _getSaveFileName = QtWidgets.QFileDialog.getSaveFileName\n\n    # Alias PyQt-specific functions for PySide compatibility.\n    QtCore.Signal = QtCore.pyqtSignal\n    try:\n        QtCore.Slot = QtCore.pyqtSlot\n    except AttributeError:\n        # Not a perfect match but works in simple cases\n        QtCore.Slot = QtCore.pyqtSignature\n\n    QtCore.Property = QtCore.pyqtProperty\n    __version__ = QtCore.PYQT_VERSION_STR\n\nelse:  # try importing pyside\n    try:\n        from PySide import QtCore, QtGui, __version__, __version_info__\n    except ImportError:\n        raise ImportError(\n            \"Matplotlib qt-based backends require an external PyQt4, PyQt5,\\n\"\n            \"or PySide package to be installed, but it was not found.\")\n\n    if __version_info__ < (1, 0, 3):\n        raise ImportError(\n            \"Matplotlib backend_qt4 and backend_qt4agg require PySide >=1.0.3\")\n\n    _getSaveFileName = QtGui.QFileDialog.getSaveFileName\n\n\n# Apply shim to Qt4 APIs to make them look like Qt5\nif QT_API in (QT_API_PYQT, QT_API_PYQTv2, QT_API_PYSIDE):\n    '''Import all used QtGui objects into QtWidgets\n\n    Here I've opted to simple copy QtGui into QtWidgets as that\n    achieves the same result as copying over the objects, and will\n    continue to work if other objects are used.\n\n    '''\n    QtWidgets = QtGui\n    QtGui = QtWidgets\n\n\n# Handle PyQt specific signals and slots\nQtCore.pyqtSignal = QtCore.Signal\n\n\nif QT_API is None:\n    raise RuntimeError(\n        \"Could not determine PyQt or PySide API, please ensure you",
    "after": "\"\"\" A Qt API selector that can be used to switch between PyQt and PySide.\n\"\"\"\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\n\nimport os\nfrom matplotlib import rcParams, verbose\n\n# Available APIs.\nQT_API_PYQT = 'PyQt4'       # API is not set here; Python 2.x default is V 1\nQT_API_PYQTv2 = 'PyQt4v2'   # forced to Version 2 API\nQT_API_PYSIDE = 'PySide'    # only supports Version 2 API\nQT_API_PYQT5 = 'PyQt5'       # use PyQt5 API; Version 2 with module shim\n\nETS = dict(pyqt=(QT_API_PYQTv2, 4), pyside=(QT_API_PYSIDE, 4),\n           pyqt5=(QT_API_PYQT5, 5))\n# ETS is a dict of env variable to (QT_API, QT_MAJOR_VERSION)\n# If the ETS QT_API environment variable is set, use it, but only\n# if the varible if of the same major QT version.  Note that\n# ETS requires the version 2 of PyQt4, which is not the platform\n# default for Python 2.x.\n\nQT_API_ENV = os.environ.get('QT_API')\n\nif rcParams['backend'] == 'Qt5Agg':\n    QT_RC_MAJOR_VERSION = 5\nelse:\n    QT_RC_MAJOR_VERSION = 4\n\nQT_API = None\n\nif (QT_API_ENV is not None):\n    try:\n        QT_ENV_MAJOR_VERSION = ETS[QT_API_ENV][1]\n    except KeyError:\n        raise RuntimeError(\n            ('Unrecognized environment variable %r, valid values are:'\n             ' %r, %r or %r' % (QT_API_ENV, 'pyqt', 'pyside', 'pyqt5')))\n    if QT_ENV_MAJOR_VERSION == QT_RC_MAJOR_VERSION:\n        # Only if backend and env qt major version are\n        # compatible use the env variable.\n        QT_API = ETS[QT_API_ENV][0]\n\nif QT_API is None:\n    # No ETS environment or incompatible so use rcParams.\n    if rcParams['backend'] == 'Qt5Agg':\n        QT_API = rcParams['backend.qt5']\n    else:\n        QT_API = rcParams['backend.qt4']\n\n# We will define an appropriate wrapper for the differing versions\n# of file dialog.\n_getSaveFileName = None\n\n# Flag to check if sip could be imported\n_sip_imported = False\n\n# Now perform the imports.\nif QT_API in (QT_API_PYQT, QT_API_PYQTv2, QT_API_PYQT5):\n    try:\n        import sip\n        _sip_imported = True\n    except ImportError:\n        # Try using PySide\n        QT_API = QT_API_PYSIDE\n        cond = (\"Could not import sip; falling back on PySide\\n\"\n                \"in place of PyQt4 or PyQt5.\\n\")\n        verbose.report(cond, 'helpful')\n\nif _sip_imported:\n    if QT_API == QT_API_PYQTv2:\n        if QT_API_ENV == 'pyqt':\n            cond = (\"Found 'QT_API=pyqt' environment variable. \"\n                    \"Setting PyQt4 API accordingly.\\n\")\n        else:\n            cond = \"PyQt API v2 specified.\"\n        try:\n            sip.setapi('QString', 2)\n        except:\n            res = 'QString API v2 specification failed. Defaulting to v1.'\n            verbose.report(cond + res, 'helpful')\n            # condition has now been reported, no need to repeat it:\n            cond = \"\"\n        try:\n            sip.setapi('QVariant', 2)\n        except:\n            res = 'QVariant API v2 specification failed. Defaulting to v1.'\n            verbose.report(cond + res, 'helpful')\n\n    if QT_API in [QT_API_PYQT, QT_API_PYQTv2]:  # PyQt4 API\n\n        from PyQt4 import QtCore, QtGui\n\n        try:\n            if sip.getapi(\"QString\") > 1:\n                # Use new getSaveFileNameAndFilter()\n                _getSaveFileName = QtGui.QFileDialog.getSaveFileNameAndFilter\n            else:\n\n                # Use old getSaveFileName()\n                def _getSaveFileName(*args, **kwargs):\n                    return (QtGui.QFileDialog.getSaveFileName(*args, **kwargs),\n                            None)\n\n        except (AttributeError, KeyError):\n\n            # call to getapi() can fail in older versions of sip\n            def _getSaveFileName(*args, **kwargs):\n                return QtGui.QFileDialog.getSaveFileName(*args, **kwargs), None\n\n    else:  # PyQt5 API\n        from PyQt5 import QtCore, QtGui, QtWidgets\n        _getSaveFileName = QtWidgets.QFileDialog.getSaveFileName\n\n    # Alias PyQt-specific functions for PySide compatibility.\n    QtCore.Signal = QtCore.pyqtSignal\n    try:\n        QtCore.Slot = QtCore.pyqtSlot\n    except AttributeError:\n        # Not a perfect match but works in simple cases\n        QtCore.Slot = QtCore.pyqtSignature\n\n    QtCore.Property = QtCore.pyqtProperty\n    __version__ = QtCore.PYQT_VERSION_STR\n\nelse:  # try importing pyside\n    try:\n        from PySide import QtCore, QtGui, __version__, __version_info__\n    except ImportError:\n        raise ImportError(\n            \"Matplotlib qt-based backends require an external PyQt4, PyQt5,\\n\"\n            \"or PySide package to be installed, but it was not found.\")\n\n    if __version_info__ < (1, 0, 3):\n        raise ImportError(\n            \"Matplotlib backend_qt4 and backend_qt4agg require PySide >=1.0.3\")\n\n    _getSaveFileName = QtGui.QFileDialog.getSaveFileName\n\n\n# Apply shim to Qt4 APIs to make them look like Qt5\nif QT_API in (QT_API_PYQT, QT_API_PYQTv2, QT_API_PYSIDE):\n    '''Import all used QtGui objects into QtWidgets\n\n    Here I've opted to simple copy QtGui into QtWidgets as that\n    achieves the same result as copying over the objects, and will\n    continue to work if other objects are used.\n\n    '''\n    QtWidgets = QtGui\n    \n    # Set up the backend\n    rcParams['backend'] = 'Qt5Agg'\n\n    # Set up the Qt backend\n    from PyQt4.QtGui import *\n    from PyQt4.QtCore import *\n    from PyQt"
  },
  "feature_stats": {
    "indices": [
      0,
      2,
      7564,
      859,
      1114,
      4101,
      7528,
      6732,
      749,
      1047,
      5445
    ],
    "f_before": [
      59.29248809814453,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "f_after": [
      59.29248809814453,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "g_before": [
      0.0,
      34.17494583129883,
      6.626897811889648,
      6.374111652374268,
      5.7612080574035645,
      6.216245651245117,
      5.803320407867432,
      5.730223178863525,
      0.0,
      0.0,
      0.0
    ],
    "g_after": [
      0.0,
      34.17494583129883,
      6.626897811889648,
      6.374111652374268,
      5.7612080574035645,
      6.216245651245117,
      5.803320407867432,
      5.730223178863525,
      0.0,
      0.0,
      0.0
    ],
    "num_batches_for_stats": 10
  },
  "loss_summary": {
    "train_mean_loss": 10.01762550815125,
    "train_mean_l2": 7.948200629286468,
    "train_mean_l1": 2.7709025331735613,
    "num_steps": 2000,
    "num_batches": 2000
  },
  "feature_std_summary": {
    "plot_path": "outputs/plots/20251128-142149/feature_std_layer_12.html",
    "mean_std": 1.2138572931289673,
    "max_std": 39.272926330566406
  }
}