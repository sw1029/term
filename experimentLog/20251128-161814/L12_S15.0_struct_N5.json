{
  "model_name": "google/gemma-2-2b-it",
  "layer_idx": 12,
  "command": "python main.py experiment.use_multi_contrast=true sae.loss_option=2 sae.loss_module=option2_loss sae.guidance_method=contrastive sae.guidance_coeff=1.0 sae.alpha_concept.code=0.05 sae.alpha_concept.harm=0.05 sae.alpha_concept.struct=0.0 sae.use_l0=true sae.l0_coeff=0.0009195390858312656 sae.role_sep_coeff=0.0095",
  "sae": {
    "input_dim": 2304,
    "sae_dim": 9216,
    "fixed_v_cnt": 3,
    "batch_size": 3,
    "epochs": 2,
    "max_steps": 2000,
    "l1_coeff": 0.005,
    "l0_coeff": 0.0009195390858312656,
    "use_l0": true,
    "concept_samples_per_label": 100,
    "loss_option": 2,
    "loss_module": "option2_loss",
    "concept_feature_indices": {
      "code": 0,
      "harm": 1,
      "struct": 2
    },
    "alpha_concept": {
      "code": 0.05,
      "harm": 0.05,
      "struct": 0.0
    },
    "positive_targets": {
      "code": 1,
      "harm": 1,
      "struct": 1
    },
    "guidance_method": "contrastive",
    "guidance_margin": 0.0,
    "guidance_coeff": 1.0,
    "guidance_mse_pos_value": 1.0,
    "guidance_mse_neg_value": 0.0,
    "jumprelu_bandwidth": 0.001,
    "jumprelu_init_threshold": 0.001,
    "role_sep_coeff": 0.0095
  },
  "gnn": {
    "use_gnn": true,
    "top_k": 10
  },
  "experiment": {
    "device": "cuda",
    "dataset_name": "wikitext",
    "dataset_config": "wikitext-2-raw-v1",
    "use_multi_contrast": true,
    "num_steering_samples_per_label": 10,
    "top_k_for_plot": 10,
    "layer_sweep": [
      12
    ],
    "strength_sweep": [
      15.0
    ]
  },
  "steering": {
    "label": "struct",
    "feature_idx": 2,
    "strength": 15.0
  },
  "prompt": "# Copyright 2011 OpenStack Foundation\n# Copyright 2013 IBM Corp.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport mock\nfrom oslo_utils import timeutils\nimport webob\n\nfrom nova.api.openstack import common\nfrom nova.api.openstack.compute import create_backup \\\n        as create_backup_v21\nfrom nova.compute import api\nfrom nova.compute import utils as compute_utils\nfrom nova import exception\nfrom nova import test\nfrom nova.tests.unit.api.openstack.compute import admin_only_action_common\nfrom nova.tests.unit.api.openstack import fakes\nfrom nova.tests.unit import fake_instance\n\n\nclass CreateBackupTestsV21(admin_only_action_common.CommonMixin,\n                        test.NoDBTestCase):\n    create_backup = create_backup_v21\n    controller_name = 'CreateBackupController'\n    validation_error = exception.ValidationError\n\n    def setUp(self):\n        super(CreateBackupTestsV21, self).setUp()\n        self.controller = getattr(self.create_backup, self.controller_name)()\n        self.compute_api = self.controller.compute_api\n\n        patch_get = mock.patch.object(self.compute_api, 'get')\n        self.mock_get = patch_get.start()\n        self.addCleanup(patch_get.stop)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_with_metadata(self, mock_backup, mock_check_image):\n        metadata = {'123': 'asdf'}\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n                'metadata': metadata,\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties=metadata)\n\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance.uuid,\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, metadata)\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 1,\n                                              extra_properties=metadata)\n\n        self.assertEqual(202, res.status_int)\n        self.assertIn('fake-image-id', res.headers['Location'])\n\n    def test_create_backup_no_name(self):\n        # Name is required for backups.\n        body = {\n            'createBackup': {\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_name_with_leading_trailing_spaces(self):\n        body = {\n            'createBackup': {\n                'name': '  test  ',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_name_with_leading_trailing_spaces_compat_mode(\n            self, mock_backup, mock_check_image):\n        body = {\n            'createBackup': {\n                'name': '  test  ',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        self.req.set_legacy_v2()\n        self.controller._create_backup(self.req, instance.uuid,\n                                       body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'test',\n                                              'daily', 1,\n                                              extra_properties={})\n\n    def test_create_backup_no_rotation(self):\n        # Rotation is required for backup requests.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_negative_rotation(self):\n        \"\"\"Rotation must be greater than or equal to zero\n        for backup requests\n        \"\"\"\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': -1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_negative_rotation_with_string_number(self):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '-1',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_rotation_with_empty_string(self):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_no_backup_type(self):\n        # Backup Type (daily or weekly) is required for backup requests.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_non_dict_metadata(self):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n                'metadata': 'non_dict',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_bad_entity(self):\n        body = {'createBackup': 'go'}\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_rotation_is_zero(self, mock_backup,\n                                         mock_check_image):\n        # The happy path for creating backups if rotation is zero.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 0,\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance.uuid,\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 0,\n                                              extra_properties={})\n        self.assertEqual(202, res.status_int)\n        self.assertNotIn('Location', res.headers)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_rotation_is_positive(self, mock_backup,\n                                                mock_check_image):\n        # The happy path for creating backups if rotation is positive.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance.uuid,\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 1,\n                                              extra_properties={})\n\n        self.assertEqual(202, res.status_int)\n        self.assertIn('fake-image-id', res.headers['Location'])\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_rotation_is_string_number(\n                                self, mock_backup, mock_check_image):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '1',\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance['uuid'],\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 1,\n                                              extra_properties={})\n        self.assertEqual(202, res.status_int)\n        self.assertIn('fake-image-id', res.headers['Location'])\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup', return_value=dict(\n        id='fake-image-id', status='ACTIVE', name='Backup 1', properties={}))\n    def test_create_backup_v2_45(self, mock_backup, mock_check_image):\n        \"\"\"Tests the 2.45 microversion to ensure the Location header is not\n        in the response.\n        \"\"\"\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '1',\n            },\n        }\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        req = fakes.HTTPRequest.blank('', version='2.45')\n        res = self.controller._create_backup(req, instance['uuid'], body=body)\n        self.assertIsInstance(res, dict)\n        self.assertEqual('fake-image-id', res['image_id'])\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_raises_conflict_on_invalid_state(self,\n                                   mock_backup, mock_check_image):\n        body_map = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.side_effect = exception.InstanceInvalidState(\n                            attr='vm_state', instance_uuid=instance.uuid,\n                            state='foo', method='backup')\n\n        ex = self.assertRaises(webob.exc.HTTPConflict,\n                          self.controller._create_backup,\n                          self.req, instance.uuid,\n                          body=body_map)\n        self.assertIn(\"Cannot 'createBackup' instance %(id)s\"\n                      % {'id': instance.uuid}, ex.explanation)\n\n    def test_create_backup_with_non_existed_instance(self):\n        body_map = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        uuid = fakes.FAKE_UUID\n        self.mock_get.side_effect = exception.InstanceNotFound(\n                                            instance_id=uuid)\n        self.assertRaises(webob.exc.HTTPNotFound,\n                          self.controller._create_backup,\n                          self.req, uuid, body=body_map)\n\n    def test_create_backup_with_invalid_create_backup(self):\n        body = {\n            'createBackupup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(compute_utils, 'is_volume_backed_instance',\n                       return_value=True)\n    def test_backup_volume_backed_instance(self, mock_is_volume_backed,\n                                           mock_check_image):\n        body = {\n            'createBackup': {\n                'name': 'BackupMe',\n                'backup_type': 'daily',\n                'rotation': 3\n            },\n        }\n\n        updates = {'vm_state': 'active',\n                   'task_state': None,\n                   'launched_at': timeutils.utcnow()}\n        instance = fake_instance.fake_instance_obj(self.context, **updates)\n        instance.image_ref = None\n        self.mock_get.return_value = instance\n\n        ex = self.assertRaises(webob.exc.HTTPBadRequest,\n                               self.controller._create_backup,\n                               self.req, instance['uuid'], body=body)\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_is_volume_backed.assert_called_once_with(self.context, instance)\n        self.assertIn('Backup is not supported for volume-backed instances',\n                      str(ex))\n\n\nclass CreateBackupTestsV239(test.NoDBTestCase):\n\n    def setUp(self):\n        super(CreateBackupTestsV239, self).setUp()\n        self.controller = create_backup_v21.CreateBackupController()\n        self.req = fakes.HTTPRequest.blank('', version='2.39')\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(common, 'get_instance')\n    def test_create_backup_no_quota_checks(self, mock_get_instance,\n                                                 mock_check_quotas):\n        # 'mock_get_instance' helps to skip the whole logic of the action,\n        # but to make the test\n        mock_get_instance.side_effect = webob.exc.HTTPNotFound\n        metadata = {'123': 'asdf'}\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n                'metadata': metadata,\n            },\n        }\n        self.assertRaises(webob.exc.HTTPNotFound,\n                          self.controller._create_backup, self.req,\n                          fakes.FAKE_UUID, body=body)\n        # starting from version 2.39 no quota checks on Nova side are performed\n        # for 'createBackup' action after removing 'image-metadata' proxy API\n        mock_check_quotas.assert_not_called()\n",
  "output": {
    "before": "# Copyright 2011 OpenStack Foundation\n# Copyright 2013 IBM Corp.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport mock\nfrom oslo_utils import timeutils\nimport webob\n\nfrom nova.api.openstack import common\nfrom nova.api.openstack.compute import create_backup \\\n        as create_backup_v21\nfrom nova.compute import api\nfrom nova.compute import utils as compute_utils\nfrom nova import exception\nfrom nova import test\nfrom nova.tests.unit.api.openstack.compute import admin_only_action_common\nfrom nova.tests.unit.api.openstack import fakes\nfrom nova.tests.unit import fake_instance\n\n\nclass CreateBackupTestsV21(admin_only_action_common.CommonMixin,\n                        test.NoDBTestCase):\n    create_backup = create_backup_v21\n    controller_name = 'CreateBackupController'\n    validation_error = exception.ValidationError\n\n    def setUp(self):\n        super(CreateBackupTestsV21, self).setUp()\n        self.controller = getattr(self.create_backup, self.controller_name)()\n        self.compute_api = self.controller.compute_api\n\n        patch_get = mock.patch.object(self.compute_api, 'get')\n        self.mock_get = patch_get.start()\n        self.addCleanup(patch_get.stop)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_with_metadata(self, mock_backup, mock_check_image):\n        metadata = {'123': 'asdf'}\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n                'metadata': metadata,\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties=metadata)\n\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance.uuid,\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, metadata)\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 1,\n                                              extra_properties=metadata)\n\n        self.assertEqual(202, res.status_int)\n        self.assertIn('fake-image-id', res.headers['Location'])\n\n    def test_create_backup_no_name(self):\n        # Name is required for backups.\n        body = {\n            'createBackup': {\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_name_with_leading_trailing_spaces(self):\n        body = {\n            'createBackup': {\n                'name': '  test  ',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_name_with_leading_trailing_spaces_compat_mode(\n            self, mock_backup, mock_check_image):\n        body = {\n            'createBackup': {\n                'name': '  test  ',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        self.req.set_legacy_v2()\n        self.controller._create_backup(self.req, instance.uuid,\n                                       body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'test',\n                                              'daily', 1,\n                                              extra_properties={})\n\n    def test_create_backup_no_rotation(self):\n        # Rotation is required for backup requests.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_negative_rotation(self):\n        \"\"\"Rotation must be greater than or equal to zero\n        for backup requests\n        \"\"\"\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': -1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_negative_rotation_with_string_number(self):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '-1',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_rotation_with_empty_string(self):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_no_backup_type(self):\n        # Backup Type (daily or weekly) is required for backup requests.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_non_dict_metadata(self):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n                'metadata': 'non_dict',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_bad_entity(self):\n        body = {'createBackup': 'go'}\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_rotation_is_zero(self, mock_backup,\n                                         mock_check_image):\n        # The happy path for creating backups if rotation is zero.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 0,\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance.uuid,\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 0,\n                                              extra_properties={})\n        self.assertEqual(202, res.status_int)\n        self.assertNotIn('Location', res.headers)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_rotation_is_positive(self, mock_backup,\n                                                mock_check_image):\n        # The happy path for creating backups if rotation is positive.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance.uuid,\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 1,\n                                              extra_properties={})\n\n        self.assertEqual(202, res.status_int)\n        self.assertIn('fake-image-id', res.headers['Location'])\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_rotation_is_string_number(\n                                self, mock_backup, mock_check_image):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '1',\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance['uuid'],\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 1,\n                                              extra_properties={})\n        self.assertEqual(202, res.status_int)\n        self.assertIn('fake-image-id', res.headers['Location'])\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup', return_value=dict(\n        id='fake-image-id', status='ACTIVE', name='Backup 1', properties={}))\n    def test_create_backup_v2_45(self, mock_backup, mock_check_image):\n        \"\"\"Tests the 2.45 microversion to ensure the Location header is not\n        in the response.\n        \"\"\"\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '1',\n            },\n        }\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        req = fakes.HTTPRequest.blank('', version='2.45')\n        res = self.controller._create_backup(req, instance['uuid'], body=body)\n        self.assertIsInstance(res, dict)\n        self.assertEqual('fake-image-id', res['image_id'])\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_raises_conflict_on_invalid_state(self,\n                                   mock_backup, mock_check_image):\n        body_map = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.side_effect = exception.InstanceInvalidState(\n                            attr='vm_state', instance_uuid=instance.uuid,\n                            state='foo', method='backup')\n\n        ex = self.assertRaises(webob.exc.HTTPConflict,\n                          self.controller._create_backup,\n                          self.req, instance.uuid,\n                          body=body_map)\n        self.assertIn(\"Cannot 'createBackup' instance %(id)s\"\n                      % {'id': instance.uuid}, ex.explanation)\n\n    def test_create_backup_with_non_existed_instance(self):\n        body_map = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        uuid = fakes.FAKE_UUID\n        self.mock_get.side_effect = exception.InstanceNotFound(\n                                            instance_id=uuid)\n        self.assertRaises(webob.exc.HTTPNotFound,\n                          self.controller._create_backup,\n                          self.req, uuid, body=body_map)\n\n    def test_create_backup_with_invalid_create_backup(self):\n        body = {\n            'createBackupup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(compute_utils, 'is_volume_backed_instance',\n                       return_value=True)\n    def test_backup_volume_backed_instance(self, mock_is_volume_backed,\n                                           mock_check_image):\n        body = {\n            'createBackup': {\n                'name': 'BackupMe',\n                'backup_type': 'daily',\n                'rotation': 3\n            },\n        }\n\n        updates = {'vm_state': 'active',\n                   'task_state': None,\n                   'launched_at': timeutils.utcnow()}\n        instance = fake_instance.fake_instance_obj(self.context, **updates)\n        instance.image_ref = None\n        self.mock_get.return_value = instance\n\n        ex = self.assertRaises(webob.exc.HTTPBadRequest,\n                               self.controller._create_backup,\n                               self.req, instance['uuid'], body=body)\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_is_volume_backed.assert_called_once_with(self.context, instance)\n        self.assertIn('Backup is not supported for volume-backed instances',\n                      str(ex))\n\n\nclass CreateBackupTestsV239(test.NoDBTestCase):\n\n    def setUp(self):\n        super(CreateBackupTestsV239, self).setUp()\n        self.controller = create_backup_v21.CreateBackupController()\n        self.req = fakes.HTTPRequest.blank('', version='2.39')\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(common, 'get_instance')\n    def test_create_backup_no_quota_checks(self, mock_get_instance,\n                                                 mock_check_quotas):\n        # 'mock_get_instance' helps to skip the whole logic of the action,\n        # but to make the test\n        mock_get_instance.side_effect = webob.exc.HTTPNotFound\n        metadata = {'123': 'asdf'}\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n                'metadata': metadata,\n            },\n        }\n        self.assertRaises(webob.exc.HTTPNotFound,\n                          self.controller._create_backup, self.req,\n                          fakes.FAKE_UUID, body=body)\n        # starting from version 2.39 no quota checks on Nova side are performed\n        # for 'createBackup' action after removing 'image-metadata' proxy API\n        mock_check_quotas.assert_not_called()\n        mock_get_instance.assert_called_once_with(self.context,\n                                                  fakes.FAKE_UUID)\n\n```",
    "after": "# Copyright 2011 OpenStack Foundation\n# Copyright 2013 IBM Corp.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport mock\nfrom oslo_utils import timeutils\nimport webob\n\nfrom nova.api.openstack import common\nfrom nova.api.openstack.compute import create_backup \\\n        as create_backup_v21\nfrom nova.compute import api\nfrom nova.compute import utils as compute_utils\nfrom nova import exception\nfrom nova import test\nfrom nova.tests.unit.api.openstack.compute import admin_only_action_common\nfrom nova.tests.unit.api.openstack import fakes\nfrom nova.tests.unit import fake_instance\n\n\nclass CreateBackupTestsV21(admin_only_action_common.CommonMixin,\n                        test.NoDBTestCase):\n    create_backup = create_backup_v21\n    controller_name = 'CreateBackupController'\n    validation_error = exception.ValidationError\n\n    def setUp(self):\n        super(CreateBackupTestsV21, self).setUp()\n        self.controller = getattr(self.create_backup, self.controller_name)()\n        self.compute_api = self.controller.compute_api\n\n        patch_get = mock.patch.object(self.compute_api, 'get')\n        self.mock_get = patch_get.start()\n        self.addCleanup(patch_get.stop)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_with_metadata(self, mock_backup, mock_check_image):\n        metadata = {'123': 'asdf'}\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n                'metadata': metadata,\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties=metadata)\n\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance.uuid,\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, metadata)\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 1,\n                                              extra_properties=metadata)\n\n        self.assertEqual(202, res.status_int)\n        self.assertIn('fake-image-id', res.headers['Location'])\n\n    def test_create_backup_no_name(self):\n        # Name is required for backups.\n        body = {\n            'createBackup': {\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_name_with_leading_trailing_spaces(self):\n        body = {\n            'createBackup': {\n                'name': '  test  ',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_name_with_leading_trailing_spaces_compat_mode(\n            self, mock_backup, mock_check_image):\n        body = {\n            'createBackup': {\n                'name': '  test  ',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        self.req.set_legacy_v2()\n        self.controller._create_backup(self.req, instance.uuid,\n                                       body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'test',\n                                              'daily', 1,\n                                              extra_properties={})\n\n    def test_create_backup_no_rotation(self):\n        # Rotation is required for backup requests.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_negative_rotation(self):\n        \"\"\"Rotation must be greater than or equal to zero\n        for backup requests\n        \"\"\"\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': -1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_negative_rotation_with_string_number(self):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '-1',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_rotation_with_empty_string(self):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_no_backup_type(self):\n        # Backup Type (daily or weekly) is required for backup requests.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_non_dict_metadata(self):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n                'metadata': 'non_dict',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_bad_entity(self):\n        body = {'createBackup': 'go'}\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_rotation_is_zero(self, mock_backup,\n                                         mock_check_image):\n        # The happy path for creating backups if rotation is zero.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 0,\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance.uuid,\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 0,\n                                              extra_properties={})\n        self.assertEqual(202, res.status_int)\n        self.assertNotIn('Location', res.headers)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_rotation_is_positive(self, mock_backup,\n                                                mock_check_image):\n        # The happy path for creating backups if rotation is positive.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance.uuid,\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 1,\n                                              extra_properties={})\n\n        self.assertEqual(202, res.status_int)\n        self.assertIn('fake-image-id', res.headers['Location'])\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_rotation_is_string_number(\n                                self, mock_backup, mock_check_image):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '1',\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance['uuid'],\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 1,\n                                              extra_properties={})\n        self.assertEqual(202, res.status_int)\n        self.assertIn('fake-image-id', res.headers['Location'])\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup', return_value=dict(\n        id='fake-image-id', status='ACTIVE', name='Backup 1', properties={}))\n    def test_create_backup_v2_45(self, mock_backup, mock_check_image):\n        \"\"\"Tests the 2.45 microversion to ensure the Location header is not\n        in the response.\n        \"\"\"\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '1',\n            },\n        }\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        req = fakes.HTTPRequest.blank('', version='2.45')\n        res = self.controller._create_backup(req, instance['uuid'], body=body)\n        self.assertIsInstance(res, dict)\n        self.assertEqual('fake-image-id', res['image_id'])\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_raises_conflict_on_invalid_state(self,\n                                   mock_backup, mock_check_image):\n        body_map = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.side_effect = exception.InstanceInvalidState(\n                            attr='vm_state', instance_uuid=instance.uuid,\n                            state='foo', method='backup')\n\n        ex = self.assertRaises(webob.exc.HTTPConflict,\n                          self.controller._create_backup,\n                          self.req, instance.uuid,\n                          body=body_map)\n        self.assertIn(\"Cannot 'createBackup' instance %(id)s\"\n                      % {'id': instance.uuid}, ex.explanation)\n\n    def test_create_backup_with_non_existed_instance(self):\n        body_map = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        uuid = fakes.FAKE_UUID\n        self.mock_get.side_effect = exception.InstanceNotFound(\n                                            instance_id=uuid)\n        self.assertRaises(webob.exc.HTTPNotFound,\n                          self.controller._create_backup,\n                          self.req, uuid, body=body_map)\n\n    def test_create_backup_with_invalid_create_backup(self):\n        body = {\n            'createBackupup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(compute_utils, 'is_volume_backed_instance',\n                       return_value=True)\n    def test_backup_volume_backed_instance(self, mock_is_volume_backed,\n                                           mock_check_image):\n        body = {\n            'createBackup': {\n                'name': 'BackupMe',\n                'backup_type': 'daily',\n                'rotation': 3\n            },\n        }\n\n        updates = {'vm_state': 'active',\n                   'task_state': None,\n                   'launched_at': timeutils.utcnow()}\n        instance = fake_instance.fake_instance_obj(self.context, **updates)\n        instance.image_ref = None\n        self.mock_get.return_value = instance\n\n        ex = self.assertRaises(webob.exc.HTTPBadRequest,\n                               self.controller._create_backup,\n                               self.req, instance['uuid'], body=body)\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_is_volume_backed.assert_called_once_with(self.context, instance)\n        self.assertIn('Backup is not supported for volume-backed instances',\n                      str(ex))\n\n\nclass CreateBackupTestsV239(test.NoDBTestCase):\n\n    def setUp(self):\n        super(CreateBackupTestsV239, self).setUp()\n        self.controller = create_backup_v21.CreateBackupController()\n        self.req = fakes.HTTPRequest.blank('', version='2.39')\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(common, 'get_instance')\n    def test_create_backup_no_quota_checks(self, mock_get_instance,\n                                                 mock_check_quotas):\n        # 'mock_get_instance' helps to skip the whole logic of the action,\n        # but to make the test\n        mock_get_instance.side_effect = webob.exc.HTTPNotFound\n        metadata = {'123': 'asdf'}\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n                'metadata': metadata,\n            },\n        }\n        self.assertRaises(webob.exc.HTTPNotFound,\n                          self.controller._create_backup, self.req,\n                          fakes.FAKE_UUID, body=body)\n        # starting from version 2.39 no quota checks on Nova side are performed\n        # for 'createBackup' action after removing 'image-metadata' proxy API\n        mock_check_quotas.assert_not_called()\n```\n\n```python\n# Copyright 2011 OpenStack\n#\n#    Licensed under the Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0)\n#    \n#"
  },
  "feature_stats": {
    "indices": [
      2,
      0,
      2770,
      7673,
      1646,
      7798,
      6573,
      5839,
      5329,
      3030,
      6085
    ],
    "f_before": [
      0.0,
      56.174217224121094,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "f_after": [
      0.0,
      56.174217224121094,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "g_before": [
      32.907859802246094,
      0.027965806424617767,
      0.0,
      5.472072124481201,
      5.988674640655518,
      0.09872063994407654,
      0.0,
      0.017650015652179718,
      0.0,
      5.50283145904541,
      0.0
    ],
    "g_after": [
      32.907859802246094,
      0.027965806424617767,
      0.0,
      5.472072124481201,
      5.988674640655518,
      0.09872063994407654,
      0.0,
      0.017650015652179718,
      0.0,
      5.50283145904541,
      0.0
    ],
    "num_batches_for_stats": 10
  },
  "loss_summary": {
    "train_mean_loss": 8.755375345926732,
    "train_mean_l2": 5.643428234145046,
    "train_mean_l1": 3.491124365925789,
    "num_steps": 2000,
    "num_batches": 2000
  },
  "feature_std_summary": {
    "plot_path": "outputs/plots/20251128-161814/feature_std_layer_12.html",
    "mean_std": 1.2764151096343994,
    "max_std": 34.51808166503906
  }
}