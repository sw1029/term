{
  "model_name": "google/gemma-2-2b-it",
  "layer_idx": 12,
  "command": "python main.py experiment.use_multi_contrast=true sae.loss_option=2 sae.loss_module=option2_loss sae.guidance_method=contrastive sae.guidance_coeff=1.0 sae.alpha_concept.code=0.05 sae.alpha_concept.harm=0.05 sae.alpha_concept.struct=0.0 sae.use_l0=true sae.l0_coeff=0.0009195390858312656 sae.role_sep_coeff=0.0095",
  "sae": {
    "input_dim": 2304,
    "sae_dim": 9216,
    "fixed_v_cnt": 3,
    "batch_size": 3,
    "epochs": 2,
    "max_steps": 2000,
    "l1_coeff": 0.005,
    "l0_coeff": 0.0009195390858312656,
    "use_l0": true,
    "concept_samples_per_label": 100,
    "loss_option": 2,
    "loss_module": "option2_loss",
    "concept_feature_indices": {
      "code": 0,
      "harm": 1,
      "struct": 2
    },
    "alpha_concept": {
      "code": 0.05,
      "harm": 0.05,
      "struct": 0.0
    },
    "positive_targets": {
      "code": 1,
      "harm": 1,
      "struct": 1
    },
    "guidance_method": "contrastive",
    "guidance_margin": 0.0,
    "guidance_coeff": 1.0,
    "guidance_mse_pos_value": 1.0,
    "guidance_mse_neg_value": 0.0,
    "jumprelu_bandwidth": 0.001,
    "jumprelu_init_threshold": 0.001,
    "role_sep_coeff": 0.0095
  },
  "gnn": {
    "use_gnn": true,
    "top_k": 10
  },
  "experiment": {
    "device": "cuda",
    "dataset_name": "wikitext",
    "dataset_config": "wikitext-2-raw-v1",
    "use_multi_contrast": true,
    "num_steering_samples_per_label": 10,
    "top_k_for_plot": 10,
    "layer_sweep": [
      12
    ],
    "strength_sweep": [
      15.0
    ]
  },
  "steering": {
    "label": "code",
    "feature_idx": 0,
    "strength": 15.0
  },
  "prompt": "#\n# Copyright 2015 Quantopian, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nTests for the zipline.assets package\n\"\"\"\n\nimport sys\nfrom unittest import TestCase\n\nfrom datetime import datetime, timedelta\nimport pickle\nimport uuid\nimport warnings\n\nimport pandas as pd\nfrom pandas.tseries.tools import normalize_date\nfrom pandas.util.testing import assert_frame_equal\n\nfrom nose_parameterized import parameterized\nfrom numpy import full\n\nfrom zipline.assets import Asset, Equity, Future, AssetFinder\nfrom zipline.assets.futures import FutureChain\nfrom zipline.errors import (\n    SymbolNotFound,\n    MultipleSymbolsFound,\n    SidAssignmentError,\n    RootSymbolNotFound,\n)\nfrom zipline.finance.trading import with_environment\nfrom zipline.utils.test_utils import (\n    all_subindices,\n    make_rotating_asset_info,\n)\n\n\ndef build_lookup_generic_cases():\n    \"\"\"\n    Generate test cases for AssetFinder test_lookup_generic.\n    \"\"\"\n\n    unique_start = pd.Timestamp('2013-01-01', tz='UTC')\n    unique_end = pd.Timestamp('2014-01-01', tz='UTC')\n\n    dupe_0_start = pd.Timestamp('2013-01-01', tz='UTC')\n    dupe_0_end = dupe_0_start + timedelta(days=1)\n\n    dupe_1_start = pd.Timestamp('2013-01-03', tz='UTC')\n    dupe_1_end = dupe_1_start + timedelta(days=1)\n\n    frame = pd.DataFrame.from_records(\n        [\n            {\n                'sid': 0,\n                'file_name':  'duplicated',\n                'company_name': 'duplicated_0',\n                'start_date_nano': dupe_0_start.value,\n                'end_date_nano': dupe_0_end.value,\n                'exchange': '',\n            },\n            {\n                'sid': 1,\n                'file_name':  'duplicated',\n                'company_name': 'duplicated_1',\n                'start_date_nano': dupe_1_start.value,\n                'end_date_nano': dupe_1_end.value,\n                'exchange': '',\n            },\n            {\n                'sid': 2,\n                'file_name':  'unique',\n                'company_name': 'unique',\n                'start_date_nano': unique_start.value,\n                'end_date_nano': unique_end.value,\n                'exchange': '',\n            },\n        ],\n    )\n    finder = AssetFinder(metadata=frame)\n    dupe_0, dupe_1, unique = assets = [\n        finder.retrieve_asset(i)\n        for i in range(3)\n    ]\n\n    dupe_0_start = dupe_0.start_date\n    dupe_1_start = dupe_1.start_date\n    cases = [\n        ##\n        # Scalars\n\n        # Asset object\n        (finder, assets[0], None, assets[0]),\n        (finder, assets[1], None, assets[1]),\n        (finder, assets[2], None, assets[2]),\n        # int\n        (finder, 0, None, assets[0]),\n        (finder, 1, None, assets[1]),\n        (finder, 2, None, assets[2]),\n        # Duplicated symbol with resolution date\n        (finder, 'duplicated', dupe_0_start, dupe_0),\n        (finder, 'duplicated', dupe_1_start, dupe_1),\n        # Unique symbol, with or without resolution date.\n        (finder, 'unique', unique_start, unique),\n        (finder, 'unique', None, unique),\n\n        ##\n        # Iterables\n\n        # Iterables of Asset objects.\n        (finder, assets, None, assets),\n        (finder, iter(assets), None, assets),\n        # Iterables of ints\n        (finder, (0, 1), None, assets[:-1]),\n        (finder, iter((0, 1)), None, assets[:-1]),\n        # Iterables of symbols.\n        (finder, ('duplicated', 'unique'), dupe_0_start, [dupe_0, unique]),\n        (finder, ('duplicated', 'unique'), dupe_1_start, [dupe_1, unique]),\n        # Mixed types\n        (finder,\n         ('duplicated', 2, 'unique', 1, dupe_1),\n         dupe_0_start,\n         [dupe_0, assets[2], unique, assets[1], dupe_1]),\n    ]\n    return cases\n\n\nclass AssetTestCase(TestCase):\n\n    def test_asset_object(self):\n        self.assertEquals({5061: 'foo'}[Asset(5061)], 'foo')\n        self.assertEquals(Asset(5061), 5061)\n        self.assertEquals(5061, Asset(5061))\n\n        self.assertEquals(Asset(5061), Asset(5061))\n        self.assertEquals(int(Asset(5061)), 5061)\n\n        self.assertEquals(str(Asset(5061)), 'Asset(5061)')\n\n    def test_asset_is_pickleable(self):\n\n        # Very wow\n        s = Asset(\n            1337,\n            symbol=\"DOGE\",\n            asset_name=\"DOGECOIN\",\n            start_date=pd.Timestamp('2013-12-08 9:31AM', tz='UTC'),\n            end_date=pd.Timestamp('2014-06-25 11:21AM', tz='UTC'),\n            first_traded=pd.Timestamp('2013-12-08 9:31AM', tz='UTC'),\n            exchange='THE MOON',\n        )\n        s_unpickled = pickle.loads(pickle.dumps(s))\n\n        attrs_to_check = ['end_date',\n                          'exchange',\n                          'first_traded',\n                          'end_date',\n                          'asset_name',\n                          'start_date',\n                          'sid',\n                          'start_date',\n                          'symbol']\n\n        for attr in attrs_to_check:\n            self.assertEqual(getattr(s, attr), getattr(s_unpickled, attr))\n\n    def test_asset_comparisons(self):\n\n        s_23 = Asset(23)\n        s_24 = Asset(24)\n\n        self.assertEqual(s_23, s_23)\n        self.assertEqual(s_23, 23)\n        self.assertEqual(23, s_23)\n\n        self.assertNotEqual(s_23, s_24)\n        self.assertNotEqual(s_23, 24)\n        self.assertNotEqual(s_23, \"23\")\n        self.assertNotEqual(s_23, 23.5)\n        self.assertNotEqual(s_23, [])\n        self.assertNotEqual(s_23, None)\n\n        self.assertLess(s_23, s_24)\n        self.assertLess(s_23, 24)\n        self.assertGreater(24, s_23)\n        self.assertGreater(s_24, s_23)\n\n    def test_lt(self):\n        self.assertTrue(Asset(3) < Asset(4))\n        self.assertFalse(Asset(4) < Asset(4))\n        self.assertFalse(Asset(5) < Asset(4))\n\n    def test_le(self):\n        self.assertTrue(Asset(3) <= Asset(4))\n        self.assertTrue(Asset(4) <= Asset(4))\n        self.assertFalse(Asset(5) <= Asset(4))\n\n    def test_eq(self):\n        self.assertFalse(Asset(3) == Asset(4))\n        self.assertTrue(Asset(4) == Asset(4))\n        self.assertFalse(Asset(5) == Asset(4))\n\n    def test_ge(self):\n        self.assertFalse(Asset(3) >= Asset(4))\n        self.assertTrue(Asset(4) >= Asset(4))\n        self.assertTrue(Asset(5) >= Asset(4))\n\n    def test_gt(self):\n        self.assertFalse(Asset(3) > Asset(4))\n        self.assertFalse(Asset(4) > Asset(4))\n        self.assertTrue(Asset(5) > Asset(4))\n\n    def test_type_mismatch(self):\n        if sys.version_info.major < 3:\n            self.assertIsNotNone(Asset(3) < 'a')\n            self.assertIsNotNone('a' < Asset(3))\n        else:\n            with self.assertRaises(TypeError):\n                Asset(3) < 'a'\n            with self.assertRaises(TypeError):\n                'a' < Asset(3)\n\n\nclass TestFuture(TestCase):\n    future = Future(\n        2468,\n        symbol='OMH15',\n        root_symbol='OM',\n        notice_date=pd.Timestamp('2014-01-20', tz='UTC'),\n        expiration_date=pd.Timestamp('2014-02-20', tz='UTC'),\n        contract_multiplier=500\n    )\n\n    def test_str(self):\n        strd = self.future.__str__()\n        self.assertEqual(\"Future(2468 [OMH15])\", strd)\n\n    def test_repr(self):\n        reprd = self.future.__repr__()\n        self.assertTrue(\"Future\" in reprd)\n        self.assertTrue(\"2468\" in reprd)\n        self.assertTrue(\"OMH15\" in reprd)\n        self.assertTrue(\"root_symbol='OM'\" in reprd)\n        self.assertTrue((\"notice_date=Timestamp('2014-01-20 00:00:00+0000', \"\n                        \"tz='UTC')\") in reprd)\n        self.assertTrue(\"expiration_date=Timestamp('2014-02-20 00:00:00+0000'\"\n                        in reprd)\n        self.assertTrue(\"contract_multiplier=500\" in reprd)\n\n    def test_reduce(self):\n        reduced = self.future.__reduce__()\n        self.assertEqual(Future, reduced[0])\n\n    def test_to_and_from_dict(self):\n        dictd = self.future.to_dict()\n        self.assertTrue('root_symbol' in dictd)\n        self.assertTrue('notice_date' in dictd)\n        self.assertTrue('expiration_date' in dictd)\n        self.assertTrue('contract_multiplier' in dictd)\n\n        from_dict = Future.from_dict(dictd)\n        self.assertTrue(isinstance(from_dict, Future))\n        self.assertEqual(self.future, from_dict)\n\n    def test_root_symbol(self):\n        self.assertEqual('OM', self.future.root_symbol)\n\n\nclass AssetFinderTestCase(TestCase):\n\n    def test_lookup_symbol_fuzzy(self):\n        as_of = pd.Timestamp('2013-01-01', tz='UTC')\n        frame = pd.DataFrame.from_records(\n            [\n                {\n                    'sid': i,\n                    'file_name':  'TEST@%d' % i,\n                    'company_name': \"company%d\" % i,\n                    'start_date_nano': as_of.value,\n                    'end_date_nano': as_of.value,\n                    'exchange': uuid.uuid4().hex,\n                }\n                for i in range(3)\n            ]\n        )\n        finder = AssetFinder(frame, fuzzy_char='@')\n        asset_0, asset_1, asset_2 = (\n            finder.retrieve_asset(i) for i in range(3)\n        )\n\n        for i in range(2):  # we do it twice to test for caching bugs\n            self.assertIsNone(finder.lookup_symbol('test', as_of))\n            self.assertEqual(\n                asset_1,\n                finder.lookup_symbol('test@1', as_of)\n            )\n\n            # Adding an unnecessary fuzzy shouldn't matter.\n            self.assertEqual(\n                asset_1,\n                finder.lookup_symbol('test@1', as_of, fuzzy=True)\n            )\n\n            # Shouldn't find this with no fuzzy_str passed.\n            self.assertIsNone(finder.lookup_symbol('test1', as_of))\n            # Should find exact match.\n            self.assertEqual(\n                asset_1,\n                finder.lookup_symbol('test1', as_of, fuzzy=True),\n            )\n\n    def test_lookup_symbol_resolve_multiple(self):\n\n        # Incrementing by two so that start and end dates for each\n        # generated Asset don't overlap (each Asset's end_date is the\n        # day after its start date.)\n        dates = pd.date_range('2013-01-01', freq='2D', periods=5, tz='UTC')\n        df = pd.DataFrame.from_records(\n            [\n                {\n                    'sid': i,\n                    'file_name':  'existing',\n                    'company_name': 'existing',\n                    'start_date_nano': date.value,\n                    'end_date_nano': (date + timedelta(days=1)).value,\n                    'exchange': 'NYSE',\n                }\n                for i, date in enumerate(dates)\n            ]\n        )\n\n        finder = AssetFinder(df)\n        for _ in range(2):  # Run checks twice to test for caching bugs.\n            with self.assertRaises(SymbolNotFound):\n                finder.lookup_symbol_resolve_multiple('non_existing', dates[0])\n\n            with self.assertRaises(MultipleSymbolsFound):\n                finder.lookup_symbol_resolve_multiple('existing', None)\n\n            for i, date in enumerate(dates):\n                # Verify that we correctly resolve multiple symbols using\n                # the supplied date\n                result = finder.lookup_symbol_resolve_multiple(\n                    'existing',\n                    date,\n                )\n                self.assertEqual(result.symbol, 'existing')\n                self.assertEqual(result.sid, i)\n\n    @parameterized.expand(\n        build_lookup_generic_cases()\n    )\n    def test_lookup_generic(self, finder, symbols, reference_date, expected):\n        \"\"\"\n        Ensure that lookup_generic works with various permutations of inputs.\n        \"\"\"\n        results, missing = finder.lookup_generic(symbols, reference_date)\n        self.assertEqual(results, expected)\n        self.assertEqual(missing, [])\n\n    def test_lookup_generic_handle_missing(self):\n        data = pd.DataFrame.from_records(\n            [\n                # Sids that will be found when we do lookups.\n                {\n                    'sid': 0,\n                    'file_name': 'real',\n                    'company_name': 'real',\n                    'start_date_nano': pd.Timestamp('2013-1-1', tz='UTC'),\n                    'end_date_nano': pd.Timestamp('2014-1-1', tz='UTC'),\n                    'exchange': '',\n                },\n                {\n                    'sid': 1,\n                    'file_name': 'also_real',\n                    'company_name': 'also_real',\n                    'start_date_nano': pd.Timestamp('2013-1-1', tz='UTC'),\n                    'end_date_nano': pd.Timestamp('2014-1-1', tz='UTC'),\n                    'exchange': '',\n                },\n                # Sid whose end date is before our query date.  We should\n                # still correctly find it.\n                {\n                    'sid': 2,\n                    'file_name': 'real_but_old',\n                    'company_name': 'real_but_old',\n                    'start_date_nano': pd.Timestamp('2002-1-1', tz='UTC'),\n                    'end_date_nano': pd.Timestamp('2003-1-1', tz='UTC'),\n                    'exchange': '',\n                },\n                # Sid whose end date is before our query date.  We should\n                # still correctly find it.\n                {\n                    'sid': 3,\n                    'file_name': 'real_but_in_the_future',\n                    'company_name': 'real_but_in_the_future',\n                    'start_date_nano': pd.Timestamp('2014-1-1', tz='UTC'),\n                    'end_date_nano': pd.Timestamp('2020-1-1', tz='UTC'),\n                    'exchange': 'THE FUTURE',\n                },\n            ]\n        )\n        finder = AssetFinder(data)\n        results, missing = finder.lookup_generic(\n            ['real', 1, 'fake', 'real_but_old', 'real_but_in_the_future'],\n            pd.Timestamp('2013-02-01', tz='UTC'),\n        )\n\n        self.assertEqual(len(results), 3)\n        self.assertEqual(results[0].symbol, 'real')\n        self.assertEqual(results[0].sid, 0)\n        self.assertEqual(results[1].symbol, 'also_real')\n        self.assertEqual(results[1].sid, 1)\n\n        self.assertEqual(len(missing), 2)\n        self.assertEqual(missing[0], 'fake')\n        self.assertEqual(missing[1], 'real_but_in_the_future')\n\n    def test_insert_metadata(self):\n        finder = AssetFinder()\n        finder.insert_metadata(0,\n                               asset_type='equity',\n                               start_date='2014-01-01',\n                               end_date='2015-01-01',\n                               symbol=\"PLAY\",\n                               foo_data=\"FOO\",)\n\n        # Test proper insertion\n        equity = finder.retrieve_asset(0)\n        self.assertIsInstance(equity, Equity)\n        self.assertEqual('PLAY', equity.symbol)\n        self.assertEqual(pd.Timestamp('2015-01-01', tz='UTC'),\n                         equity.end_date)\n\n        # Test invalid field\n        self.assertFalse('foo_data' in finder.metadata_cache[0])\n\n    def test_consume_metadata(self):\n\n        # Test dict consumption\n        finder = AssetFinder()\n        dict_to_consume = {0: {'symbol': 'PLAY'},\n                           1: {'symbol': 'MSFT'}}\n        finder.consume_metadata(dict_to_consume)\n\n        equity = finder.retrieve_asset(0)\n        self.assertIsInstance(equity, Equity)\n        self.assertEqual('PLAY', equity.symbol)\n\n        finder = AssetFinder()\n\n        # Test dataframe consumption\n        df = pd.DataFrame(columns=['asset_name', 'exchange'], index=[0, 1])\n        df['asset_name'][0] = \"Dave'N'Busters\"\n        df['exchange'][0] = \"NASDAQ\"\n        df['asset_name'][1] = \"Microsoft\"\n        df['exchange'][1] = \"NYSE\"\n        finder.consume_metadata(df)\n        self.assertEqual('NASDAQ', finder.metadata_cache[0]['exchange'])\n        self.assertEqual('Microsoft', finder.metadata_cache[1]['asset_name'])\n\n    def test_consume_asset_as_identifier(self):\n        # Build some end dates\n        eq_end = pd.Timestamp('2012-01-01', tz='UTC')\n        fut_end = pd.Timestamp('2008-01-01', tz='UTC')\n\n        # Build some simple Assets\n        equity_asset = Equity(1, symbol=\"TESTEQ\", end_date=eq_end)\n        future_asset = Future(200, symbol=\"TESTFUT\", end_date=fut_end)\n\n        # Consume the Assets\n        finder = AssetFinder()\n        finder.consume_identifiers([equity_asset, future_asset])\n\n        # Test equality with newly built Assets\n        self.assertEqual(equity_asset, finder.retrieve_asset(1))\n        self.assertEqual(future_asset, finder.retrieve_asset(200))\n        self.assertEqual(eq_end, finder.retrieve_asset(1).end_date)\n        self.assertEqual(fut_end, finder.retrieve_asset(200).end_date)\n\n    def test_sid_assignment(self):\n\n        # This metadata does not contain SIDs\n        metadata = {'PLAY': {'symbol': 'PLAY'},\n                    'MSFT': {'symbol': 'MSFT'}}\n\n        today = normalize_date(pd.Timestamp('2015-07-09', tz='UTC'))\n\n        # Build a finder that is allowed to assign sids\n        finder = AssetFinder(metadata=metadata,\n                             allow_sid_assignment=True)\n\n        # Verify that Assets were built and different sids were assigned\n        play = finder.lookup_symbol('PLAY', today)\n        msft = finder.lookup_symbol('MSFT', today)\n        self.assertEqual('PLAY', play.symbol)\n        self.assertIsNotNone(play.sid)\n        self.assertNotEqual(play.sid, msft.sid)\n\n    def test_sid_assignment_failure(self):\n\n        # This metadata does not contain SIDs\n        metadata = {'PLAY': {'symbol': 'PLAY'},\n                    'MSFT': {'symbol': 'MSFT'}}\n\n        # Build a finder that is not allowed to assign sids, asserting failure\n        with self.assertRaises(SidAssignmentError):\n            AssetFinder(metadata=metadata, allow_sid_assignment=False)\n\n    def test_security_dates_warning(self):\n\n        # Build an asset with an end_date\n        eq_end = pd.Timestamp('2012-01-01', tz='UTC')\n        equity_asset = Equity(1, symbol=\"TESTEQ\", end_date=eq_end)\n\n        # Catch all warnings\n        with warnings.catch_warnings(record=True) as w:\n            # Cause all warnings to always be triggered\n            warnings.simplefilter(\"always\")\n            equity_asset.security_start_date\n            equity_asset.security_end_date\n            equity_asset.security_name\n            # Verify the warning\n            self.assertEqual(3, len(w))\n            for warning in w:\n                self.assertTrue(issubclass(warning.category,\n                                           DeprecationWarning))\n\n    def test_lookup_future_chain(self):\n        metadata = {\n            # Notice day is today, so not valid\n            2: {\n                'symbol': 'ADN15',\n                'root_symbol': 'AD',\n                'asset_type': 'future',\n                'notice_date': pd.Timestamp('2015-05-14', tz='UTC'),\n                'start_date': pd.Timestamp('2015-01-01', tz='UTC')\n            },\n            1: {\n                'symbol': 'ADV15',\n                'root_symbol': 'AD',\n                'asset_type': 'future',\n                'notice_date': pd.Timestamp('2015-08-14', tz='UTC'),\n                'start_date': pd.Timestamp('2015-01-01', tz='UTC')\n            },\n            # Starts trading today, so should be valid.\n            0: {\n                'symbol': 'ADF16',\n                'root_symbol': 'AD',\n                'asset_type': 'future',\n                'notice_date': pd.Timestamp('2015-11-16', tz='UTC'),\n                'start_date': pd.Timestamp('2015-05-14', tz='UTC')\n            },\n            # Copy of the above future, but starts trading in August,\n            # so it isn't valid.\n            3: {\n                'symbol': 'ADF16',\n                'root_symbol': 'AD',\n                'asset_type': 'future',\n                'notice_date': pd.Timestamp('2015-11-16', tz='UTC'),\n                'start_date': pd.Timestamp('2015-08-01', tz='UTC')\n            },\n\n        }\n\n        finder = AssetFinder(metadata=metadata)\n        dt = pd.Timestamp('2015-05-14', tz='UTC')\n        last_year = pd.Timestamp('2014-01-01', tz='UTC')\n        first_day = pd.Timestamp('2015-01-01', tz='UTC')\n\n        # Check that we get the expected number of contracts, in the\n        # right order\n        ad_contracts = finder.lookup_future_chain('AD', dt, dt)\n        self.assertEqual(len(ad_contracts), 2)\n        self.assertEqual(ad_contracts[0].sid, 1)\n        self.assertEqual(ad_contracts[1].sid, 0)\n\n        # Check that we get nothing if our knowledge date is last year\n        ad_contracts = finder.lookup_future_chain('AD', dt, last_year)\n        self.assertEqual(len(ad_contracts), 0)\n\n        # Check that we get things that start on the knowledge date\n        ad_contracts = finder.lookup_future_chain('AD', dt, first_day)\n        self.assertEqual(len(ad_contracts), 1)\n\n    def test_map_identifier_index_to_sids(self):\n        # Build an empty finder and some Assets\n        dt = pd.Timestamp('2014-01-01', tz='UTC')\n        finder = AssetFinder()\n        asset1 = Equity(1, symbol=\"AAPL\")\n        asset2 = Equity(2, symbol=\"GOOG\")\n        asset200 = Future(200, symbol=\"CLK15\")\n        asset201 = Future(201, symbol=\"CLM15\")\n\n        # Check for correct mapping and types\n        pre_map = [asset1, asset2, asset200, asset201]\n        post_map = finder.map_identifier_index_to_sids(pre_map, dt)\n        self.assertListEqual([1, 2, 200, 201], post_map)\n        for sid in post_map:\n            self.assertIsInstance(sid, int)\n\n        # Change order and check mapping again\n        pre_map = [asset201, asset2, asset200, asset1]\n        post_map = finder.map_identifier_index_to_sids(pre_map, dt)\n        self.assertListEqual([201, 2, 200, 1], post_map)\n\n    @with_environment()\n    def test_compute_lifetimes(self, env=None):\n        num_assets = 4\n        trading_day = env.trading_day\n        first_start = pd.Timestamp('2015-04-01', tz='UTC')\n\n        frame = make_rotating_asset_info(\n            num_assets=num_assets,\n            first_start=first_start,\n            frequency=env.trading_day,\n            periods_between_starts=3,\n            asset_lifetime=5\n        )\n        finder = AssetFinder(frame)\n\n        all_dates = pd.date_range(\n            start=first_start,\n            end=frame.end_date.max(),\n            freq=trading_day,\n        )\n\n        for dates in all_subindices(all_dates):\n            expected_mask = full(\n                shape=(len(dates), num_assets),\n                fill_value=False,\n                dtype=bool,\n            )\n\n            for i, date in enumerate(dates):\n                it = frame[['start_date', 'end_date']].itertuples()\n                for j, start, end in it:\n                    if start <= date <= end:\n                        expected_mask[i, j] = True\n\n            # Filter out columns with all-empty columns.\n            expected_result = pd.DataFrame(\n                data=expected_mask,\n                index=dates,\n                columns=frame.sid.values,\n            )\n            actual_result = finder.lifetimes(dates)\n            assert_frame_equal(actual_result, expected_result)\n\n\nclass TestFutureChain(TestCase):\n    metadata = {\n        0: {\n            'symbol': 'CLG06',\n            'root_symbol': 'CL',\n            'asset_type': 'future',\n            'start_date': pd.Timestamp('2005-12-01', tz='UTC'),\n            'notice_date': pd.Timestamp('2005-12-20', tz='UTC'),\n            'expiration_date': pd.Timestamp('2006-01-20', tz='UTC')},\n        1: {\n            'root_symbol': 'CL',\n            'symbol': 'CLK06',\n            'asset_type': 'future',\n            'start_date': pd.Timestamp('2005-12-01', tz='UTC'),\n            'notice_date': pd.Timestamp('2006-03-20', tz='UTC'),\n            'expiration_date': pd.Timestamp('2006-04-20', tz='UTC')},\n        2: {\n            'symbol': 'CLQ06',\n            'root_symbol': 'CL',\n            'asset_type': 'future',\n            'start_date': pd.Timestamp('2005-12-01', tz='UTC'),\n            'notice_date': pd.Timestamp('2006-06-20', tz='UTC'),\n            'expiration_date': pd.Timestamp('2006-07-20', tz='UTC')},\n        3: {\n            'symbol': 'CLX06',\n            'root_symbol': 'CL',\n            'asset_type': 'future',\n            'start_date': pd.Timestamp('2006-02-01', tz='UTC'),\n            'notice_date': pd.Timestamp('2006-09-20', tz='UTC'),\n            'expiration_date': pd.Timestamp('2006-10-20', tz='UTC')}\n    }\n\n    asset_finder = AssetFinder(metadata=metadata)\n\n    def test_len(self):\n        \"\"\" Test the __len__ method of FutureChain.\n        \"\"\"\n        # None of the contracts have started yet.\n        cl = FutureChain(self.asset_finder, lambda: '2005-11-30', 'CL')\n        self.assertEqual(len(cl), 0)\n\n        # Sids 0, 1, & 2 have started, 3 has not yet started.\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-01', 'CL')\n        self.assertEqual(len(cl), 3)\n\n        # Sid 0 is still valid the day before its notice date.\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-19', 'CL')\n        self.assertEqual(len(cl), 3)\n\n        # Sid 0 is now invalid, leaving only Sids 1 & 2 valid.\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-20', 'CL')\n        self.assertEqual(len(cl), 2)\n\n        # Sid 3 has started, so 1, 2, & 3 are now valid.\n        cl = FutureChain(self.asset_finder, lambda: '2006-02-01', 'CL')\n        self.assertEqual(len(cl), 3)\n\n        # All contracts are no longer valid.\n        cl = FutureChain(self.asset_finder, lambda: '2006-09-20', 'CL')\n        self.assertEqual(len(cl), 0)\n\n    def test_getitem(self):\n        \"\"\" Test the __getitem__ method of FutureChain.\n        \"\"\"\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-01', 'CL')\n        self.assertEqual(cl[0], 0)\n        self.assertEqual(cl[1], 1)\n        self.assertEqual(cl[2], 2)\n        with self.assertRaises(IndexError):\n            cl[3]\n\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-19', 'CL')\n        self.assertEqual(cl[0], 0)\n\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-20', 'CL')\n        self.assertEqual(cl[0], 1)\n\n        cl = FutureChain(self.asset_finder, lambda: '2006-02-01', 'CL')\n        self.assertEqual(cl[-1], 3)\n\n    def test_root_symbols(self):\n        \"\"\" Test that different variations on root symbols are handled\n        as expected.\n        \"\"\"\n        # Make sure this successfully gets the chain for CL.\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-01', 'CL')\n        self.assertEqual(cl.root_symbol, 'CL')\n\n        # These root symbols don't exist, so RootSymbolNotFound should\n        # be raised immediately.\n        with self.assertRaises(RootSymbolNotFound):\n            FutureChain(self.asset_finder, lambda: '2005-12-01', 'CLZ')\n\n        with self.assertRaises(RootSymbolNotFound):\n            FutureChain(self.asset_finder, lambda: '2005-12-01', '')\n\n    def test_repr(self):\n        \"\"\" Test the __repr__ method of FutureChain.\n        \"\"\"\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-01', 'CL')\n        cl_feb = FutureChain(self.asset_finder, lambda: '2005-12-01', 'CL',\n                             as_of_date='2006-02-01')\n\n        # The default chain should not include the as of date.\n        self.assertEqual(repr(cl), \"FutureChain(root_symbol='CL')\")\n\n        # An explicit as of date should show up in the repr.\n        self.assertEqual(\n            repr(cl_feb),\n            (\"FutureChain(root_symbol='CL', \"\n             \"as_of_date='2006-02-01 00:00:00+00:00')\")\n        )\n\n    def test_as_of(self):\n        \"\"\" Test the as_of method of FutureChain.\n        \"\"\"\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-01', 'CL')\n\n        # Test that the as_of_date is set correctly to the future\n        feb = '2006-02-01'\n        cl_feb = cl.as_of(feb)\n        self.assertEqual(\n            cl_feb.as_of_date,\n            pd.Timestamp(feb, tz='UTC')\n        )\n\n        # Test that the as_of_date is set correctly to the past, with\n        # args of str, datetime.datetime, and pd.Timestamp.\n        feb_prev = '2005-02-01'\n        cl_feb_prev = cl.as_of(feb_prev)\n        self.assertEqual(\n            cl_feb_prev.as_of_date,\n            pd.Timestamp(feb_prev, tz='UTC')\n        )\n\n        feb_prev = datetime(year=2005, month=2, day=1)\n        cl_feb_prev = cl.as_of(feb_prev)\n        self.assertEqual(\n            cl_feb_prev.as_of_date,\n            pd.Timestamp(feb_prev, tz='UTC')\n        )\n\n        feb_prev = pd.Timestamp('2005-02-01')\n        cl_feb_prev = cl.as_of(feb_prev)\n        self.assertEqual(\n            cl_feb_prev.as_of_date,\n            pd.Timestamp(feb_prev, tz='UTC')\n        )\n\n        # The chain as of the current dt should always be the same as\n        # the defualt chain. Tests date as str, pd.Timestamp, and\n        # datetime.datetime.\n        self.assertEqual(cl[0], cl.as_of('2005-12-01')[0])\n        self.assertEqual(cl[0], cl.as_of(pd.Timestamp('2005-12-01'))[0])\n        self.assertEqual(\n            cl[0],\n            cl.as_of(datetime(year=2005, month=12, day=1))[0]\n        )\n\n    def test_offset(self):\n        \"\"\" Test the offset method of FutureChain.\n        \"\"\"\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-01', 'CL')\n\n        # Test that an offset forward sets as_of_date as expected\n        self.assertEqual(\n            cl.offset('3 days').as_of_date,\n            cl.as_of_date + pd.Timedelta(days=3)\n        )\n\n        # Test that an offset backward sets as_of_date as expected, with\n        # time delta given as str, datetime.timedelta, and pd.Timedelta.\n        self.assertEqual(\n            cl.offset('-1000 days').as_of_date,\n            cl.as_of_date + pd.Timedelta(days=-1000)\n        )\n        self.assertEqual(\n            cl.offset(timedelta(days=-1000)).as_of_date,\n            cl.as_of_date + pd.Timedelta(days=-1000)\n        )\n        self.assertEqual(\n            cl.offset(pd.Timedelta('-1000 days')).as_of_date,\n            cl.as_of_date + pd.Timedelta(days=-1000)\n        )\n\n        # An offset of zero should give the original chain.\n        self.assertEqual(cl[0], cl.offset(0)[0])\n        self.assertEqual(cl[0], cl.offset(\"0 days\")[0])\n\n        # A string that doesn't represent a time delta should raise a\n        # ValueError.\n        with self.assertRaises(ValueError):\n            cl.offset(\"blah\")\n",
  "output": {
    "before": "#\n# Copyright 2015 Quantopian, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nTests for the zipline.assets package\n\"\"\"\n\nimport sys\nfrom unittest import TestCase\n\nfrom datetime import datetime, timedelta\nimport pickle\nimport uuid\nimport warnings\n\nimport pandas as pd\nfrom pandas.tseries.tools import normalize_date\nfrom pandas.util.testing import assert_frame_equal\n\nfrom nose_parameterized import parameterized\nfrom numpy import full\n\nfrom zipline.assets import Asset, Equity, Future, AssetFinder\nfrom zipline.assets.futures import FutureChain\nfrom zipline.errors import (\n    SymbolNotFound,\n    MultipleSymbolsFound,\n    SidAssignmentError,\n    RootSymbolNotFound,\n)\nfrom zipline.finance.trading import with_environment\nfrom zipline.utils.test_utils import (\n    all_subindices,\n    make_rotating_asset_info,\n)\n\n\ndef build_lookup_generic_cases():\n    \"\"\"\n    Generate test cases for AssetFinder test_lookup_generic.\n    \"\"\"\n\n    unique_start = pd.Timestamp('2013-01-01', tz='UTC')\n    unique_end = pd.Timestamp('2014-01-01', tz='UTC')\n\n    dupe_0_start = pd.Timestamp('2013-01-01', tz='UTC')\n    dupe_0_end = dupe_0_start + timedelta(days=1)\n\n    dupe_1_start = pd.Timestamp('2013-01-03', tz='UTC')\n    dupe_1_end = dupe_1_start + timedelta(days=1)\n\n    frame = pd.DataFrame.from_records(\n        [\n            {\n                'sid': 0,\n                'file_name':  'duplicated',\n                'company_name': 'duplicated_0',\n                'start_date_nano': dupe_0_start.value,\n                'end_date_nano': dupe_0_end.value,\n                'exchange': '',\n            },\n            {\n                'sid': 1,\n                'file_name':  'duplicated',\n                'company_name': 'duplicated_1',\n                'start_date_nano': dupe_1_start.value,\n                'end_date_nano': dupe_1_end.value,\n                'exchange': '',\n            },\n            {\n                'sid': 2,\n                'file_name':  'unique',\n                'company_name': 'unique',\n                'start_date_nano': unique_start.value,\n                'end_date_nano': unique_end.value,\n                'exchange': '',\n            },\n        ],\n    )\n    finder = AssetFinder(metadata=frame)\n    dupe_0, dupe_1, unique = assets = [\n        finder.retrieve_asset(i)\n        for i in range(3)\n    ]\n\n    dupe_0_start = dupe_0.start_date\n    dupe_1_start = dupe_1.start_date\n    cases = [\n        ##\n        # Scalars\n\n        # Asset object\n        (finder, assets[0], None, assets[0]),\n        (finder, assets[1], None, assets[1]),\n        (finder, assets[2], None, assets[2]),\n        # int\n        (finder, 0, None, assets[0]),\n        (finder, 1, None, assets[1]),\n        (finder, 2, None, assets[2]),\n        # Duplicated symbol with resolution date\n        (finder, 'duplicated', dupe_0_start, dupe_0),\n        (finder, 'duplicated', dupe_1_start, dupe_1),\n        # Unique symbol, with or without resolution date.\n        (finder, 'unique', unique_start, unique),\n        (finder, 'unique', None, unique),\n\n        ##\n        # Iterables\n\n        # Iterables of Asset objects.\n        (finder, assets, None, assets),\n        (finder, iter(assets), None, assets),\n        # Iterables of ints\n        (finder, (0, 1), None, assets[:-1]),\n        (finder, iter((0, 1)), None, assets[:-1]),\n        # Iterables of symbols.\n        (finder, ('duplicated', 'unique'), dupe_0_start, [dupe_0, unique]),\n        (finder, ('duplicated', 'unique'), dupe_1_start, [dupe_1, unique]),\n        # Mixed types\n        (finder,\n         ('duplicated', 2, 'unique', 1, dupe_1),\n         dupe_0_start,\n         [dupe_0, assets[2], unique, assets[1], dupe_1]),\n    ]\n    return cases\n\n\nclass AssetTestCase(TestCase):\n\n    def test_asset_object(self):\n        self.assertEquals({5061: 'foo'}[Asset(5061)], 'foo')\n        self.assertEquals(Asset(5061), 5061)\n        self.assertEquals(5061, Asset(5061))\n\n        self.assertEquals(Asset(5061), Asset(5061))\n        self.assertEquals(int(Asset(5061)), 5061)\n\n        self.assertEquals(str(Asset(5061)), 'Asset(5061)')\n\n    def test_asset_is_pickleable(self):\n\n        # Very wow\n        s = Asset(\n            1337,\n            symbol=\"DOGE\",\n            asset_name=\"DOGECOIN\",\n            start_date=pd.Timestamp('2013-12-08 9:31AM', tz='UTC'),\n            end_date=pd.Timestamp('2014-06-25 11:21AM', tz='UTC'),\n            first_traded=pd.Timestamp('2013-12-08 9:31AM', tz='UTC'),\n            exchange='THE MOON',\n        )\n        s_unpickled = pickle.loads(pickle.dumps(s))\n\n        attrs_to_check = ['end_date',\n                          'exchange',\n                          'first_traded',\n                          'end_date',\n                          'asset_name',\n                          'start_date',\n                          'sid',\n                          'start_date',\n                          'symbol']\n\n        for attr in attrs_to_check:\n            self.assertEqual(getattr(s, attr), getattr(s_unpickled, attr))\n\n    def test_asset_comparisons(self):\n\n        s_23 = Asset(23)\n        s_24 = Asset(24)\n\n        self.assertEqual(s_23, s_23)\n        self.assertEqual(s_23, 23)\n        self.assertEqual(23, s_23)\n\n        self.assertNotEqual(s_23, s_24)\n        self.assertNotEqual(s_23, 24)\n        self.assertNotEqual(s_23, \"23\")\n        self.assertNotEqual(s_23, 23.5)\n        self.assertNotEqual(s_23, [])\n        self.assertNotEqual(s_23, None)\n\n        self.assertLess(s_23, s_24)\n        self.assertLess(s_23, 24)\n        self.assertGreater(24, s_23)\n        self.assertGreater(s_24, s_23)\n\n    def test_lt(self):\n        self.assertTrue(Asset(3) < Asset(4))\n        self.assertFalse(Asset(4) < Asset(4))\n        self.assertFalse(Asset(5) < Asset(4))\n\n    def test_le(self):\n        self.assertTrue(Asset(3) <= Asset(4))\n        self.assertTrue(Asset(4) <= Asset(4))\n        self.assertFalse(Asset(5) <= Asset(4))\n\n    def test_eq(self):\n        self.assertFalse(Asset(3) == Asset(4))\n        self.assertTrue(Asset(4) == Asset(4))\n        self.assertFalse(Asset(5) == Asset(4))\n\n    def test_ge(self):\n        self.assertFalse(Asset(3) >= Asset(4))\n        self.assertTrue(Asset(4) >= Asset(4))\n        self.assertTrue(Asset(5) >= Asset(4))\n\n    def test_gt(self):\n        self.assertFalse(Asset(3) > Asset(4))\n        self.assertFalse(Asset(4) > Asset(4))\n        self.assertTrue(Asset(5) > Asset(4))\n\n    def test_type_mismatch(self):\n        if sys.version_info.major < 3:\n            self.assertIsNotNone(Asset(3) < 'a')\n            self.assertIsNotNone('a' < Asset(3))\n        else:\n            with self.assertRaises(TypeError):\n                Asset(3) < 'a'\n            with self.assertRaises(TypeError):\n                'a' < Asset(3)\n\n\nclass TestFuture(TestCase):\n    future = Future(\n        2468,\n        symbol='OMH15',\n        root_symbol='OM',\n        notice_date=pd.Timestamp('2014-01-20', tz='UTC'),\n        expiration_date=pd.Timestamp('2014-02-20', tz='UTC'),\n        contract_multiplier=500\n    )\n\n    def test_str(self):\n        strd = self.future.__str__()\n        self.assertEqual(\"Future(2468 [OMH15])\", strd)\n\n    def test_repr(self):\n        reprd = self.future.__repr__()\n        self.assertTrue(\"Future\" in reprd)\n        self.assertTrue(\"2468\" in reprd)\n        self.assertTrue(\"OMH15\" in reprd)\n        self.assertTrue(\"root_symbol='OM'\" in reprd)\n        self.assertTrue((\"notice_date=Timestamp('2014-01-20 00:00:00+0000', \"\n                        \"tz='UTC')\") in reprd)\n        self.assertTrue(\"expiration_date=Timestamp('2014-02-20 00:00:00+0000'\"\n                        in reprd)\n        self.assertTrue(\"contract_multiplier=500\" in reprd)\n\n    def test_reduce(self):\n        reduced = self.future.__reduce__()\n        self.assertEqual(Future, reduced[0])\n\n    def test_to_and_from_dict(self):\n        dictd = self.future.to_dict()\n        self.assertTrue('root_symbol' in dictd)\n        self.assertTrue('notice_date' in dictd)\n        self.assertTrue('expiration_date' in dictd)\n        self.assertTrue('contract_multiplier' in dictd)\n\n        from_dict = Future.from_dict(dictd)\n        self.assertTrue(isinstance(from_dict, Future))\n        self.assertEqual(self.future, from_dict)\n\n    def test_root_symbol(self):\n        self.assertEqual('OM', self.future.root_symbol)\n\n\nclass AssetFinderTestCase(TestCase):\n\n    def test_lookup_symbol_fuzzy(self):\n        as_of = pd.Timestamp('2013-01-01', tz='UTC')\n        frame = pd.DataFrame.from_records(\n            [\n                {\n                    'sid': i,\n                    'file_name':  'TEST@%d' % i,\n                    'company_name': \"company%d\" % i,\n                    'start_date_nano': as_of.value,\n                    'end_date_nano': as_of.value,\n                    'exchange': uuid.uuid4().hex,\n                }\n                for i in range(3)\n            ]\n        )\n        finder = AssetFinder(frame, fuzzy_char='@')\n        asset_0, asset_1, asset_2 = (\n            finder.retrieve_asset(i) for i in range(3)\n        )\n\n        for i in range(2):  # we do it twice to test for caching bugs\n            self.assertIsNone(finder.lookup_symbol('test', as_of))\n            self.assertEqual(\n                asset_1,\n                finder.lookup_symbol('test@1', as_of)\n            )\n\n            # Adding an unnecessary fuzzy shouldn't matter.\n            self.assertEqual(\n                asset_1,\n                finder.lookup_symbol('test@1', as_of, fuzzy=True)\n            )\n\n            # Shouldn't find this with no fuzzy_str passed.\n            self.assertIsNone(finder.lookup_symbol('test1', as_of))\n            # Should find exact match.\n            self.assertEqual(\n                asset_1,\n                finder.lookup_symbol('test1', as_of, fuzzy=True),\n            )\n\n    def test_lookup_symbol_resolve_multiple(self):\n\n        # Incrementing by two so that start and end dates for each\n        # generated Asset don't overlap (each Asset's end_date is the\n        # day after its start date.)\n        dates = pd.date_range('2013-01-01', freq='2D', periods=5, tz='UTC')\n        df = pd.DataFrame.from_records(\n            [\n                {\n                    'sid': i,\n                    'file_name':  'existing',\n                    'company_name': 'existing',\n                    'start_date_nano': date.value,\n                    'end_date_nano': (date + timedelta(days=1)).value,\n                    'exchange': 'NYSE',\n                }\n                for i, date in enumerate(dates)\n            ]\n        )\n\n        finder = AssetFinder(df)\n        for _ in range(2):  # Run checks twice to test for caching bugs.\n            with self.assertRaises(SymbolNotFound):\n                finder.lookup_symbol_resolve_multiple('non_existing', dates[0])\n\n            with self.assertRaises(MultipleSymbolsFound):\n                finder.lookup_symbol_resolve_multiple('existing', None)\n\n            for i, date in enumerate(dates):\n                # Verify that we correctly resolve multiple symbols using\n                # the supplied date\n                result = finder.lookup_symbol_resolve_multiple(\n                    'existing',\n                    date,\n                )\n                self.assertEqual(result.symbol, 'existing')\n                self.assertEqual(result.sid, i)\n\n    @parameterized.expand(\n        build_lookup_generic_cases()\n    )\n    def test_lookup_generic(self, finder, symbols, reference_date, expected):\n        \"\"\"\n        Ensure that lookup_generic works with various permutations of inputs.\n        \"\"\"\n        results, missing = finder.lookup_generic(symbols, reference_date)\n        self.assertEqual(results, expected)\n        self.assertEqual(missing, [])\n\n    def test_lookup_generic_handle_missing(self):\n        data = pd.DataFrame.from_records(\n            [\n                # Sids that will be found when we do lookups.\n                {\n                    'sid': 0,\n                    'file_name': 'real',\n                    'company_name': 'real',\n                    'start_date_nano': pd.Timestamp('2013-1-1', tz='UTC'),\n                    'end_date_nano': pd.Timestamp('2014-1-1', tz='UTC'),\n                    'exchange': '',\n                },\n                {\n                    'sid': 1,\n                    'file_name': 'also_real',\n                    'company_name': 'also_real',\n                    'start_date_nano': pd.Timestamp('2013-1-1', tz='UTC'),\n                    'end_date_nano': pd.Timestamp('2014-1-1', tz='UTC'),\n                    'exchange': '',\n                },\n                # Sid whose end date is before our query date.  We should\n                # still correctly find it.\n                {\n                    'sid': 2,\n                    'file_name': 'real_but_old',\n                    'company_name': 'real_but_old',\n                    'start_date_nano': pd.Timestamp('2002-1-1', tz='UTC'),\n                    'end_date_nano': pd.Timestamp('2003-1-1', tz='UTC'),\n                    'exchange': '',\n                },\n                # Sid whose end date is before our query date.  We should\n                # still correctly find it.\n                {\n                    'sid': 3,\n                    'file_name': 'real_but_in_the_future',\n                    'company_name': 'real_but_in_the_future',\n                    'start_date_nano': pd.Timestamp('2014-1-1', tz='UTC'),\n                    'end_date_nano': pd.Timestamp('2020-1-1', tz='UTC'),\n                    'exchange': 'THE FUTURE',\n                },\n            ]\n        )\n        finder = AssetFinder(data)\n        results, missing = finder.lookup_generic(\n            ['real', 1, 'fake', 'real_but_old', 'real_but_in_the_future'],\n            pd.Timestamp('2013-02-01', tz='UTC'),\n        )\n\n        self.assertEqual(len(results), 3)\n        self.assertEqual(results[0].symbol, 'real')\n        self.assertEqual(results[0].sid, 0)\n        self.assertEqual(results[1].symbol, 'also_real')\n        self.assertEqual(results[1].sid, 1)\n\n        self.assertEqual(len(missing), 2)\n        self.assertEqual(missing[0], 'fake')\n        self.assertEqual(missing[1], 'real_but_in_the_future')\n\n    def test_insert_metadata(self):\n        finder = AssetFinder()\n        finder.insert_metadata(0,\n                               asset_type='equity',\n                               start_date='2014-01-01',\n                               end_date='2015-01-01',\n                               symbol=\"PLAY\",\n                               foo_data=\"FOO\",)\n\n        # Test proper insertion\n        equity = finder.retrieve_asset(0)\n        self.assertIsInstance(equity, Equity)\n        self.assertEqual('PLAY', equity.symbol)\n        self.assertEqual(pd.Timestamp('2015-01-01', tz='UTC'),\n                         equity.end_date)\n\n        # Test invalid field\n        self.assertFalse('foo_data' in finder.metadata_cache[0])\n\n    def test_consume_metadata(self):\n\n        # Test dict consumption\n        finder = AssetFinder()\n        dict_to_consume = {0: {'symbol': 'PLAY'},\n                           1: {'symbol': 'MSFT'}}\n        finder.consume_metadata(dict_to_consume)\n\n        equity = finder.retrieve_asset(0)\n        self.assertIsInstance(equity, Equity)\n        self.assertEqual('PLAY', equity.symbol)\n\n        finder = AssetFinder()\n\n        # Test dataframe consumption\n        df = pd.DataFrame(columns=['asset_name', 'exchange'], index=[0, 1])\n        df['asset_name'][0] = \"Dave'N'Busters\"\n        df['exchange'][0] = \"NASDAQ\"\n        df['asset_name'][1] = \"Microsoft\"\n        df['exchange'][1] = \"NYSE\"\n        finder.consume_metadata(df)\n        self.assertEqual('NASDAQ', finder.metadata_cache[0]['exchange'])\n        self.assertEqual('Microsoft', finder.metadata_cache[1]['asset_name'])\n\n    def test_consume_asset_as_identifier(self):\n        # Build some end dates\n        eq_end = pd.Timestamp('2012-01-01', tz='UTC')\n        fut_end = pd.Timestamp('2008-01-01', tz='UTC')\n\n        # Build some simple Assets\n        equity_asset = Equity(1, symbol=\"TESTEQ\", end_date=eq_end)\n        future_asset = Future(200, symbol=\"TESTFUT\", end_date=fut_end)\n\n        # Consume the Assets\n        finder = AssetFinder()\n        finder.consume_identifiers([equity_asset, future_asset])\n\n        # Test equality with newly built Assets\n        self.assertEqual(equity_asset, finder.retrieve_asset(1))\n        self.assertEqual(future_asset, finder.retrieve_asset(200))\n        self.assertEqual(eq_end, finder.retrieve_asset(1).end_date)\n        self.assertEqual(fut_end, finder.retrieve_asset(200).end_date)\n\n    def test_sid_assignment(self):\n\n        # This metadata does not contain SIDs\n        metadata = {'PLAY': {'symbol': 'PLAY'},\n                    'MSFT': {'symbol': 'MSFT'}}\n\n        today = normalize_date(pd.Timestamp('2015-07-09', tz='UTC'))\n\n        # Build a finder that is allowed to assign sids\n        finder = AssetFinder(metadata=metadata,\n                             allow_sid_assignment=True)\n\n        # Verify that Assets were built and different sids were assigned\n        play = finder.lookup_symbol('PLAY', today)\n        msft = finder.lookup_symbol('MSFT', today)\n        self.assertEqual('PLAY', play.symbol)\n        self.assertIsNotNone(play.sid)\n        self.assertNotEqual(play.sid, msft.sid)\n\n    def test_sid_assignment_failure(self):\n\n        # This metadata does not contain SIDs\n        metadata = {'PLAY': {'symbol': 'PLAY'},\n                    'MSFT': {'symbol': 'MSFT'}}\n\n        # Build a finder that is not allowed to assign sids, asserting failure\n        with self.assertRaises(SidAssignmentError):\n            AssetFinder(metadata=metadata, allow_sid_assignment=False)\n\n    def test_security_dates_warning(self):\n\n        # Build an asset with an end_date\n        eq_end = pd.Timestamp('2012-01-01', tz='UTC')\n        equity_asset = Equity(1, symbol=\"TESTEQ\", end_date=eq_end)\n\n        # Catch all warnings\n        with warnings.catch_warnings(record=True) as w:\n            # Cause all warnings to always be triggered\n            warnings.simplefilter(\"always\")\n            equity_asset.security_start_date\n            equity_asset.security_end_date\n            equity_asset.security_name\n            # Verify the warning\n            self.assertEqual(3, len(w))\n            for warning in w:\n                self.assertTrue(issubclass(warning.category,\n                                           DeprecationWarning))\n\n    def test_lookup_future_chain(self):\n        metadata = {\n            # Notice day is today, so not valid\n            2: {\n                'symbol': 'ADN15',\n                'root_symbol': 'AD',\n                'asset_type': 'future',\n                'notice_date': pd.Timestamp('2015-05-14', tz='UTC'),\n                'start_date': pd.Timestamp('2015-01-01', tz='UTC')\n            },\n            1: {\n                'symbol': 'ADV15',\n                'root_symbol': 'AD',\n                'asset_type': 'future',\n                'notice_date': pd.Timestamp('2015-08-14', tz='UTC'),\n                'start_date': pd.Timestamp('2015-01-01', tz='UTC')\n            },\n            # Starts trading today, so should be valid.\n            0: {\n                'symbol': 'ADF16',\n                'root_symbol': 'AD',\n                'asset_type': 'future',\n                'notice_date': pd.Timestamp('2015-11-16', tz='UTC'),\n                'start_date': pd.Timestamp('2015-05-14', tz='UTC')\n            },\n            # Copy of the above future, but starts trading in August,\n            # so it isn't valid.\n            3: {\n                'symbol': 'ADF16',\n                'root_symbol': 'AD',\n                'asset_type': 'future',\n                'notice_date': pd.Timestamp('2015-11-16', tz='UTC'),\n                'start_date': pd.Timestamp('2015-08-01', tz='UTC')\n            },\n\n        }\n\n        finder = AssetFinder(metadata=metadata)\n        dt = pd.Timestamp('2015-05-14', tz='UTC')\n        last_year = pd.Timestamp('2014-01-01', tz='UTC')\n        first_day = pd.Timestamp('2015-01-01', tz='UTC')\n\n        # Check that we get the expected number of contracts, in the\n        # right order\n        ad_contracts = finder.lookup_future_chain('AD', dt, dt)\n        self.assertEqual(len(ad_contracts), 2)\n        self.assertEqual(ad_contracts[0].sid, 1)\n        self.assertEqual(ad_contracts[1].sid, 0)\n\n        # Check that we get nothing if our knowledge date is last year\n        ad_contracts = finder.lookup_future_chain('AD', dt, last_year)\n        self.assertEqual(len(ad_contracts), 0)\n\n        # Check that we get things that start on the knowledge date\n        ad_contracts = finder.lookup_future_chain('AD', dt, first_day)\n        self.assertEqual(len(ad_contracts), 1)\n\n    def test_map_identifier_index_to_sids(self):\n        # Build an empty finder and some Assets\n        dt = pd.Timestamp('2014-01-01', tz='UTC')\n        finder = AssetFinder()\n        asset1 = Equity(1, symbol=\"AAPL\")\n        asset2 = Equity(2, symbol=\"GOOG\")\n        asset200 = Future(200, symbol=\"CLK15\")\n        asset201 = Future(201, symbol=\"CLM15\")\n\n        # Check for correct mapping and types\n        pre_map = [asset1, asset2, asset200, asset201]\n        post_map = finder.map_identifier_index_to_sids(pre_map, dt)\n        self.assertListEqual([1, 2, 200, 201], post_map)\n        for sid in post_map:\n            self.assertIsInstance(sid, int)\n\n        # Change order and check mapping again\n        pre_map = [asset201, asset2, asset200, asset1]\n        post_map = finder.map_identifier_index_to_sids(pre_map, dt)\n        self.assertListEqual([201, 2, 200, 1], post_map)\n\n    @with_environment()\n    def test_compute_lifetimes(self, env=None):\n        num_assets = 4\n        trading_day = env.trading_day\n        first_start = pd.Timestamp('2015-04-01', tz='UTC')\n\n        frame = make_rotating_asset_info(\n            num_assets=num_assets,\n            first_start=first_start,\n            frequency=env.trading_day,\n            periods_between_starts=3,\n            asset_lifetime=5\n        )\n        finder = AssetFinder(frame)\n\n        all_dates = pd.date_range(\n            start=first_start,\n            end=frame.end_date.max(),\n            freq=trading_day,\n        )\n\n        for dates in all_subindices(all_dates):\n            expected_mask = full(\n                shape=(len(dates), num_assets),\n                fill_value=False,\n                dtype=bool,\n            )\n\n            for i, date in enumerate(dates):\n                it = frame[['start_date', 'end_date']].itertuples()\n                for j, start, end in it:\n                    if start <= date <= end:\n                        expected_mask[i, j] = True\n\n            # Filter out columns with all-empty columns.\n            expected_result = pd.DataFrame(\n                data=expected_mask,\n                index=dates,\n                columns=frame.sid.values,\n            )\n            actual_result = finder.lifetimes(dates)\n            assert_frame_equal(actual_result, expected_result)\n\n\nclass TestFutureChain(TestCase):\n    metadata = {\n        0: {\n            'symbol': 'CLG06',\n            'root_symbol': 'CL',\n            'asset_type': 'future',\n            'start_date': pd.Timestamp('2005-12-01', tz='UTC'),\n            'notice_date': pd.Timestamp('2005-12-20', tz='UTC'),\n            'expiration_date': pd.Timestamp('2006-01-20', tz='UTC')},\n        1: {\n            'root_symbol': 'CL',\n            'symbol': 'CLK06',\n            'asset_type': 'future',\n            'start_date': pd.Timestamp('2005-12-01', tz='UTC'),\n            'notice_date': pd.Timestamp('2006-03-20', tz='UTC'),\n            'expiration_date': pd.Timestamp('2006-04-20', tz='UTC')},\n        2: {\n            'symbol': 'CLQ06',\n            'root_symbol': 'CL',\n            'asset_type': 'future',\n            'start_date': pd.Timestamp('2005-12-01', tz='UTC'),\n            'notice_date': pd.Timestamp('2006-06-20', tz='UTC'),\n            'expiration_date': pd.Timestamp('2006-07-20', tz='UTC')},\n        3: {\n            'symbol': 'CLX06',\n            'root_symbol': 'CL',\n            'asset_type': 'future',\n            'start_date': pd.Timestamp('2006-02-01', tz='UTC'),\n            'notice_date': pd.Timestamp('2006-09-20', tz='UTC'),\n            'expiration_date': pd.Timestamp('2006-10-20', tz='UTC')}\n    }\n\n    asset_finder = AssetFinder(metadata=metadata)\n\n    def test_len(self):\n        \"\"\" Test the __len__ method of FutureChain.\n        \"\"\"\n        # None of the contracts have started yet.\n        cl = FutureChain(self.asset_finder, lambda: '2005-11-30', 'CL')\n        self.assertEqual(len(cl), 0)\n\n        # Sids 0, 1, & 2 have started, 3 has not yet started.\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-01', 'CL')\n        self.assertEqual(len(cl), 3)\n\n        # Sid 0 is still valid the day before its notice date.\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-19', 'CL')\n        self.assertEqual(len(cl), 3)\n\n        # Sid 0 is now invalid, leaving only Sids 1 & 2 valid.\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-20', 'CL')\n        self.assertEqual(len(cl), 2)\n\n        # Sid 3 has started, so 1, 2, & 3 are now valid.\n        cl = FutureChain(self.asset_finder, lambda: '2006-02-01', 'CL')\n        self.assertEqual(len(cl), 3)\n\n        # All contracts are no longer valid.\n        cl = FutureChain(self.asset_finder, lambda: '2006-09-20', 'CL')\n        self.assertEqual(len(cl), 0)\n\n    def test_getitem(self):\n        \"\"\" Test the __getitem__ method of FutureChain.\n        \"\"\"\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-01', 'CL')\n        self.assertEqual(cl[0], 0)\n        self.assertEqual(cl[1], 1)\n        self.assertEqual(cl[2], 2)\n        with self.assertRaises(IndexError):\n            cl[3]\n\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-19', 'CL')\n        self.assertEqual(cl[0], 0)\n\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-20', 'CL')\n        self.assertEqual(cl[0], 1)\n\n        cl = FutureChain(self.asset_finder, lambda: '2006-02-01', 'CL')\n        self.assertEqual(cl[-1], 3)\n\n    def test_root_symbols(self):\n        \"\"\" Test that different variations on root symbols are handled\n        as expected.\n        \"\"\"\n        # Make sure this successfully gets the chain for CL.\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-01', 'CL')\n        self.assertEqual(cl.root_symbol, 'CL')\n\n        # These root symbols don't exist, so RootSymbolNotFound should\n        # be raised immediately.\n        with self.assertRaises(RootSymbolNotFound):\n            FutureChain(self.asset_finder, lambda: '2005-12-01', 'CLZ')\n\n        with self.assertRaises(RootSymbolNotFound):\n            FutureChain(self.asset_finder, lambda: '2005-12-01', '')\n\n    def test_repr(self):\n        \"\"\" Test the __repr__ method of FutureChain.\n        \"\"\"\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-01', 'CL')\n        cl_feb = FutureChain(self.asset_finder, lambda: '2005-12-01', 'CL',\n                             as_of_date='2006-02-01')\n\n        # The default chain should not include the as of date.\n        self.assertEqual(repr(cl), \"FutureChain(root_symbol='CL')\")\n\n        # An explicit as of date should show up in the repr.\n        self.assertEqual(\n            repr(cl_feb),\n            (\"FutureChain(root_symbol='CL', \"\n             \"as_of_date='2006-02-01 00:00:00+00:00')\")\n        )\n\n    def test_as_of(self):\n        \"\"\" Test the as_of method of FutureChain.\n        \"\"\"\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-01', 'CL')\n\n        # Test that the as_of_date is set correctly to the future\n        feb = '2006-02-01'\n        cl_feb = cl.as_of(feb)\n        self.assertEqual(\n            cl_feb.as_of_date,\n            pd.Timestamp(feb, tz='UTC')\n        )\n\n        # Test that the as_of_date is set correctly to the past, with\n        # args of str, datetime.datetime, and pd.Timestamp.\n        feb_prev = '2005-02-01'\n        cl_feb_prev = cl.as_of(feb_prev)\n        self.assertEqual(\n            cl_feb_prev.as_of_date,\n            pd.Timestamp(feb_prev, tz='UTC')\n        )\n\n        feb_prev = datetime(year=2005, month=2, day=1)\n        cl_feb_prev = cl.as_of(feb_prev)\n        self.assertEqual(\n            cl_feb_prev.as_of_date,\n            pd.Timestamp(feb_prev, tz='UTC')\n        )\n\n        feb_prev = pd.Timestamp('2005-02-01')\n        cl_feb_prev = cl.as_of(feb_prev)\n        self.assertEqual(\n            cl_feb_prev.as_of_date,\n            pd.Timestamp(feb_prev, tz='UTC')\n        )\n\n        # The chain as of the current dt should always be the same as\n        # the defualt chain. Tests date as str, pd.Timestamp, and\n        # datetime.datetime.\n        self.assertEqual(cl[0], cl.as_of('2005-12-01')[0])\n        self.assertEqual(cl[0], cl.as_of(pd.Timestamp('2005-12-01'))[0])\n        self.assertEqual(\n            cl[0],\n            cl.as_of(datetime(year=2005, month=12, day=1))[0]\n        )\n\n    def test_offset(self):\n        \"\"\" Test the offset method of FutureChain.\n        \"\"\"\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-01', 'CL')\n\n        # Test that an offset forward sets as_of_date as expected\n        self.assertEqual(\n            cl.offset('3 days').as_of_date,\n            cl.as_of_date + pd.Timedelta(days=3)\n        )\n\n        # Test that an offset backward sets as_of_date as expected, with\n        # time delta given as str, datetime.timedelta, and pd.Timedelta.\n        self.assertEqual(\n            cl.offset('-1000 days').as_of_date,\n            cl.as_of_date + pd.Timedelta(days=-1000)\n        )\n        self.assertEqual(\n            cl.offset(timedelta(days=-1000)).as_of_date,\n            cl.as_of_date + pd.Timedelta(days=-1000)\n        )\n        self.assertEqual(\n            cl.offset(pd.Timedelta('-1000 days')).as_of_date,\n            cl.as_of_date + pd.Timedelta(days=-1000)\n        )\n\n        # An offset of zero should give the original chain.\n        self.assertEqual(cl[0], cl.offset(0)[0])\n        self.assertEqual(cl[0], cl.offset(\"0 days\")[0])\n\n        # A string that doesn't represent a time delta should raise a\n        # ValueError.\n        with self.assertRaises(ValueError):\n            cl.offset(\"blah\")\n        \"\"\"\n        # The original chain.\n        \"\"\"\n\n        self.assertEqual(cl[0], cl.offset(0)\n        )\n\n        # The original chain, and the default chain.\n        self.assertEqual(cl",
    "after": "#\n# Copyright 2015 Quantopian, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nTests for the zipline.assets package\n\"\"\"\n\nimport sys\nfrom unittest import TestCase\n\nfrom datetime import datetime, timedelta\nimport pickle\nimport uuid\nimport warnings\n\nimport pandas as pd\nfrom pandas.tseries.tools import normalize_date\nfrom pandas.util.testing import assert_frame_equal\n\nfrom nose_parameterized import parameterized\nfrom numpy import full\n\nfrom zipline.assets import Asset, Equity, Future, AssetFinder\nfrom zipline.assets.futures import FutureChain\nfrom zipline.errors import (\n    SymbolNotFound,\n    MultipleSymbolsFound,\n    SidAssignmentError,\n    RootSymbolNotFound,\n)\nfrom zipline.finance.trading import with_environment\nfrom zipline.utils.test_utils import (\n    all_subindices,\n    make_rotating_asset_info,\n)\n\n\ndef build_lookup_generic_cases():\n    \"\"\"\n    Generate test cases for AssetFinder test_lookup_generic.\n    \"\"\"\n\n    unique_start = pd.Timestamp('2013-01-01', tz='UTC')\n    unique_end = pd.Timestamp('2014-01-01', tz='UTC')\n\n    dupe_0_start = pd.Timestamp('2013-01-01', tz='UTC')\n    dupe_0_end = dupe_0_start + timedelta(days=1)\n\n    dupe_1_start = pd.Timestamp('2013-01-03', tz='UTC')\n    dupe_1_end = dupe_1_start + timedelta(days=1)\n\n    frame = pd.DataFrame.from_records(\n        [\n            {\n                'sid': 0,\n                'file_name':  'duplicated',\n                'company_name': 'duplicated_0',\n                'start_date_nano': dupe_0_start.value,\n                'end_date_nano': dupe_0_end.value,\n                'exchange': '',\n            },\n            {\n                'sid': 1,\n                'file_name':  'duplicated',\n                'company_name': 'duplicated_1',\n                'start_date_nano': dupe_1_start.value,\n                'end_date_nano': dupe_1_end.value,\n                'exchange': '',\n            },\n            {\n                'sid': 2,\n                'file_name':  'unique',\n                'company_name': 'unique',\n                'start_date_nano': unique_start.value,\n                'end_date_nano': unique_end.value,\n                'exchange': '',\n            },\n        ],\n    )\n    finder = AssetFinder(metadata=frame)\n    dupe_0, dupe_1, unique = assets = [\n        finder.retrieve_asset(i)\n        for i in range(3)\n    ]\n\n    dupe_0_start = dupe_0.start_date\n    dupe_1_start = dupe_1.start_date\n    cases = [\n        ##\n        # Scalars\n\n        # Asset object\n        (finder, assets[0], None, assets[0]),\n        (finder, assets[1], None, assets[1]),\n        (finder, assets[2], None, assets[2]),\n        # int\n        (finder, 0, None, assets[0]),\n        (finder, 1, None, assets[1]),\n        (finder, 2, None, assets[2]),\n        # Duplicated symbol with resolution date\n        (finder, 'duplicated', dupe_0_start, dupe_0),\n        (finder, 'duplicated', dupe_1_start, dupe_1),\n        # Unique symbol, with or without resolution date.\n        (finder, 'unique', unique_start, unique),\n        (finder, 'unique', None, unique),\n\n        ##\n        # Iterables\n\n        # Iterables of Asset objects.\n        (finder, assets, None, assets),\n        (finder, iter(assets), None, assets),\n        # Iterables of ints\n        (finder, (0, 1), None, assets[:-1]),\n        (finder, iter((0, 1)), None, assets[:-1]),\n        # Iterables of symbols.\n        (finder, ('duplicated', 'unique'), dupe_0_start, [dupe_0, unique]),\n        (finder, ('duplicated', 'unique'), dupe_1_start, [dupe_1, unique]),\n        # Mixed types\n        (finder,\n         ('duplicated', 2, 'unique', 1, dupe_1),\n         dupe_0_start,\n         [dupe_0, assets[2], unique, assets[1], dupe_1]),\n    ]\n    return cases\n\n\nclass AssetTestCase(TestCase):\n\n    def test_asset_object(self):\n        self.assertEquals({5061: 'foo'}[Asset(5061)], 'foo')\n        self.assertEquals(Asset(5061), 5061)\n        self.assertEquals(5061, Asset(5061))\n\n        self.assertEquals(Asset(5061), Asset(5061))\n        self.assertEquals(int(Asset(5061)), 5061)\n\n        self.assertEquals(str(Asset(5061)), 'Asset(5061)')\n\n    def test_asset_is_pickleable(self):\n\n        # Very wow\n        s = Asset(\n            1337,\n            symbol=\"DOGE\",\n            asset_name=\"DOGECOIN\",\n            start_date=pd.Timestamp('2013-12-08 9:31AM', tz='UTC'),\n            end_date=pd.Timestamp('2014-06-25 11:21AM', tz='UTC'),\n            first_traded=pd.Timestamp('2013-12-08 9:31AM', tz='UTC'),\n            exchange='THE MOON',\n        )\n        s_unpickled = pickle.loads(pickle.dumps(s))\n\n        attrs_to_check = ['end_date',\n                          'exchange',\n                          'first_traded',\n                          'end_date',\n                          'asset_name',\n                          'start_date',\n                          'sid',\n                          'start_date',\n                          'symbol']\n\n        for attr in attrs_to_check:\n            self.assertEqual(getattr(s, attr), getattr(s_unpickled, attr))\n\n    def test_asset_comparisons(self):\n\n        s_23 = Asset(23)\n        s_24 = Asset(24)\n\n        self.assertEqual(s_23, s_23)\n        self.assertEqual(s_23, 23)\n        self.assertEqual(23, s_23)\n\n        self.assertNotEqual(s_23, s_24)\n        self.assertNotEqual(s_23, 24)\n        self.assertNotEqual(s_23, \"23\")\n        self.assertNotEqual(s_23, 23.5)\n        self.assertNotEqual(s_23, [])\n        self.assertNotEqual(s_23, None)\n\n        self.assertLess(s_23, s_24)\n        self.assertLess(s_23, 24)\n        self.assertGreater(24, s_23)\n        self.assertGreater(s_24, s_23)\n\n    def test_lt(self):\n        self.assertTrue(Asset(3) < Asset(4))\n        self.assertFalse(Asset(4) < Asset(4))\n        self.assertFalse(Asset(5) < Asset(4))\n\n    def test_le(self):\n        self.assertTrue(Asset(3) <= Asset(4))\n        self.assertTrue(Asset(4) <= Asset(4))\n        self.assertFalse(Asset(5) <= Asset(4))\n\n    def test_eq(self):\n        self.assertFalse(Asset(3) == Asset(4))\n        self.assertTrue(Asset(4) == Asset(4))\n        self.assertFalse(Asset(5) == Asset(4))\n\n    def test_ge(self):\n        self.assertFalse(Asset(3) >= Asset(4))\n        self.assertTrue(Asset(4) >= Asset(4))\n        self.assertTrue(Asset(5) >= Asset(4))\n\n    def test_gt(self):\n        self.assertFalse(Asset(3) > Asset(4))\n        self.assertFalse(Asset(4) > Asset(4))\n        self.assertTrue(Asset(5) > Asset(4))\n\n    def test_type_mismatch(self):\n        if sys.version_info.major < 3:\n            self.assertIsNotNone(Asset(3) < 'a')\n            self.assertIsNotNone('a' < Asset(3))\n        else:\n            with self.assertRaises(TypeError):\n                Asset(3) < 'a'\n            with self.assertRaises(TypeError):\n                'a' < Asset(3)\n\n\nclass TestFuture(TestCase):\n    future = Future(\n        2468,\n        symbol='OMH15',\n        root_symbol='OM',\n        notice_date=pd.Timestamp('2014-01-20', tz='UTC'),\n        expiration_date=pd.Timestamp('2014-02-20', tz='UTC'),\n        contract_multiplier=500\n    )\n\n    def test_str(self):\n        strd = self.future.__str__()\n        self.assertEqual(\"Future(2468 [OMH15])\", strd)\n\n    def test_repr(self):\n        reprd = self.future.__repr__()\n        self.assertTrue(\"Future\" in reprd)\n        self.assertTrue(\"2468\" in reprd)\n        self.assertTrue(\"OMH15\" in reprd)\n        self.assertTrue(\"root_symbol='OM'\" in reprd)\n        self.assertTrue((\"notice_date=Timestamp('2014-01-20 00:00:00+0000', \"\n                        \"tz='UTC')\") in reprd)\n        self.assertTrue(\"expiration_date=Timestamp('2014-02-20 00:00:00+0000'\"\n                        in reprd)\n        self.assertTrue(\"contract_multiplier=500\" in reprd)\n\n    def test_reduce(self):\n        reduced = self.future.__reduce__()\n        self.assertEqual(Future, reduced[0])\n\n    def test_to_and_from_dict(self):\n        dictd = self.future.to_dict()\n        self.assertTrue('root_symbol' in dictd)\n        self.assertTrue('notice_date' in dictd)\n        self.assertTrue('expiration_date' in dictd)\n        self.assertTrue('contract_multiplier' in dictd)\n\n        from_dict = Future.from_dict(dictd)\n        self.assertTrue(isinstance(from_dict, Future))\n        self.assertEqual(self.future, from_dict)\n\n    def test_root_symbol(self):\n        self.assertEqual('OM', self.future.root_symbol)\n\n\nclass AssetFinderTestCase(TestCase):\n\n    def test_lookup_symbol_fuzzy(self):\n        as_of = pd.Timestamp('2013-01-01', tz='UTC')\n        frame = pd.DataFrame.from_records(\n            [\n                {\n                    'sid': i,\n                    'file_name':  'TEST@%d' % i,\n                    'company_name': \"company%d\" % i,\n                    'start_date_nano': as_of.value,\n                    'end_date_nano': as_of.value,\n                    'exchange': uuid.uuid4().hex,\n                }\n                for i in range(3)\n            ]\n        )\n        finder = AssetFinder(frame, fuzzy_char='@')\n        asset_0, asset_1, asset_2 = (\n            finder.retrieve_asset(i) for i in range(3)\n        )\n\n        for i in range(2):  # we do it twice to test for caching bugs\n            self.assertIsNone(finder.lookup_symbol('test', as_of))\n            self.assertEqual(\n                asset_1,\n                finder.lookup_symbol('test@1', as_of)\n            )\n\n            # Adding an unnecessary fuzzy shouldn't matter.\n            self.assertEqual(\n                asset_1,\n                finder.lookup_symbol('test@1', as_of, fuzzy=True)\n            )\n\n            # Shouldn't find this with no fuzzy_str passed.\n            self.assertIsNone(finder.lookup_symbol('test1', as_of))\n            # Should find exact match.\n            self.assertEqual(\n                asset_1,\n                finder.lookup_symbol('test1', as_of, fuzzy=True),\n            )\n\n    def test_lookup_symbol_resolve_multiple(self):\n\n        # Incrementing by two so that start and end dates for each\n        # generated Asset don't overlap (each Asset's end_date is the\n        # day after its start date.)\n        dates = pd.date_range('2013-01-01', freq='2D', periods=5, tz='UTC')\n        df = pd.DataFrame.from_records(\n            [\n                {\n                    'sid': i,\n                    'file_name':  'existing',\n                    'company_name': 'existing',\n                    'start_date_nano': date.value,\n                    'end_date_nano': (date + timedelta(days=1)).value,\n                    'exchange': 'NYSE',\n                }\n                for i, date in enumerate(dates)\n            ]\n        )\n\n        finder = AssetFinder(df)\n        for _ in range(2):  # Run checks twice to test for caching bugs.\n            with self.assertRaises(SymbolNotFound):\n                finder.lookup_symbol_resolve_multiple('non_existing', dates[0])\n\n            with self.assertRaises(MultipleSymbolsFound):\n                finder.lookup_symbol_resolve_multiple('existing', None)\n\n            for i, date in enumerate(dates):\n                # Verify that we correctly resolve multiple symbols using\n                # the supplied date\n                result = finder.lookup_symbol_resolve_multiple(\n                    'existing',\n                    date,\n                )\n                self.assertEqual(result.symbol, 'existing')\n                self.assertEqual(result.sid, i)\n\n    @parameterized.expand(\n        build_lookup_generic_cases()\n    )\n    def test_lookup_generic(self, finder, symbols, reference_date, expected):\n        \"\"\"\n        Ensure that lookup_generic works with various permutations of inputs.\n        \"\"\"\n        results, missing = finder.lookup_generic(symbols, reference_date)\n        self.assertEqual(results, expected)\n        self.assertEqual(missing, [])\n\n    def test_lookup_generic_handle_missing(self):\n        data = pd.DataFrame.from_records(\n            [\n                # Sids that will be found when we do lookups.\n                {\n                    'sid': 0,\n                    'file_name': 'real',\n                    'company_name': 'real',\n                    'start_date_nano': pd.Timestamp('2013-1-1', tz='UTC'),\n                    'end_date_nano': pd.Timestamp('2014-1-1', tz='UTC'),\n                    'exchange': '',\n                },\n                {\n                    'sid': 1,\n                    'file_name': 'also_real',\n                    'company_name': 'also_real',\n                    'start_date_nano': pd.Timestamp('2013-1-1', tz='UTC'),\n                    'end_date_nano': pd.Timestamp('2014-1-1', tz='UTC'),\n                    'exchange': '',\n                },\n                # Sid whose end date is before our query date.  We should\n                # still correctly find it.\n                {\n                    'sid': 2,\n                    'file_name': 'real_but_old',\n                    'company_name': 'real_but_old',\n                    'start_date_nano': pd.Timestamp('2002-1-1', tz='UTC'),\n                    'end_date_nano': pd.Timestamp('2003-1-1', tz='UTC'),\n                    'exchange': '',\n                },\n                # Sid whose end date is before our query date.  We should\n                # still correctly find it.\n                {\n                    'sid': 3,\n                    'file_name': 'real_but_in_the_future',\n                    'company_name': 'real_but_in_the_future',\n                    'start_date_nano': pd.Timestamp('2014-1-1', tz='UTC'),\n                    'end_date_nano': pd.Timestamp('2020-1-1', tz='UTC'),\n                    'exchange': 'THE FUTURE',\n                },\n            ]\n        )\n        finder = AssetFinder(data)\n        results, missing = finder.lookup_generic(\n            ['real', 1, 'fake', 'real_but_old', 'real_but_in_the_future'],\n            pd.Timestamp('2013-02-01', tz='UTC'),\n        )\n\n        self.assertEqual(len(results), 3)\n        self.assertEqual(results[0].symbol, 'real')\n        self.assertEqual(results[0].sid, 0)\n        self.assertEqual(results[1].symbol, 'also_real')\n        self.assertEqual(results[1].sid, 1)\n\n        self.assertEqual(len(missing), 2)\n        self.assertEqual(missing[0], 'fake')\n        self.assertEqual(missing[1], 'real_but_in_the_future')\n\n    def test_insert_metadata(self):\n        finder = AssetFinder()\n        finder.insert_metadata(0,\n                               asset_type='equity',\n                               start_date='2014-01-01',\n                               end_date='2015-01-01',\n                               symbol=\"PLAY\",\n                               foo_data=\"FOO\",)\n\n        # Test proper insertion\n        equity = finder.retrieve_asset(0)\n        self.assertIsInstance(equity, Equity)\n        self.assertEqual('PLAY', equity.symbol)\n        self.assertEqual(pd.Timestamp('2015-01-01', tz='UTC'),\n                         equity.end_date)\n\n        # Test invalid field\n        self.assertFalse('foo_data' in finder.metadata_cache[0])\n\n    def test_consume_metadata(self):\n\n        # Test dict consumption\n        finder = AssetFinder()\n        dict_to_consume = {0: {'symbol': 'PLAY'},\n                           1: {'symbol': 'MSFT'}}\n        finder.consume_metadata(dict_to_consume)\n\n        equity = finder.retrieve_asset(0)\n        self.assertIsInstance(equity, Equity)\n        self.assertEqual('PLAY', equity.symbol)\n\n        finder = AssetFinder()\n\n        # Test dataframe consumption\n        df = pd.DataFrame(columns=['asset_name', 'exchange'], index=[0, 1])\n        df['asset_name'][0] = \"Dave'N'Busters\"\n        df['exchange'][0] = \"NASDAQ\"\n        df['asset_name'][1] = \"Microsoft\"\n        df['exchange'][1] = \"NYSE\"\n        finder.consume_metadata(df)\n        self.assertEqual('NASDAQ', finder.metadata_cache[0]['exchange'])\n        self.assertEqual('Microsoft', finder.metadata_cache[1]['asset_name'])\n\n    def test_consume_asset_as_identifier(self):\n        # Build some end dates\n        eq_end = pd.Timestamp('2012-01-01', tz='UTC')\n        fut_end = pd.Timestamp('2008-01-01', tz='UTC')\n\n        # Build some simple Assets\n        equity_asset = Equity(1, symbol=\"TESTEQ\", end_date=eq_end)\n        future_asset = Future(200, symbol=\"TESTFUT\", end_date=fut_end)\n\n        # Consume the Assets\n        finder = AssetFinder()\n        finder.consume_identifiers([equity_asset, future_asset])\n\n        # Test equality with newly built Assets\n        self.assertEqual(equity_asset, finder.retrieve_asset(1))\n        self.assertEqual(future_asset, finder.retrieve_asset(200))\n        self.assertEqual(eq_end, finder.retrieve_asset(1).end_date)\n        self.assertEqual(fut_end, finder.retrieve_asset(200).end_date)\n\n    def test_sid_assignment(self):\n\n        # This metadata does not contain SIDs\n        metadata = {'PLAY': {'symbol': 'PLAY'},\n                    'MSFT': {'symbol': 'MSFT'}}\n\n        today = normalize_date(pd.Timestamp('2015-07-09', tz='UTC'))\n\n        # Build a finder that is allowed to assign sids\n        finder = AssetFinder(metadata=metadata,\n                             allow_sid_assignment=True)\n\n        # Verify that Assets were built and different sids were assigned\n        play = finder.lookup_symbol('PLAY', today)\n        msft = finder.lookup_symbol('MSFT', today)\n        self.assertEqual('PLAY', play.symbol)\n        self.assertIsNotNone(play.sid)\n        self.assertNotEqual(play.sid, msft.sid)\n\n    def test_sid_assignment_failure(self):\n\n        # This metadata does not contain SIDs\n        metadata = {'PLAY': {'symbol': 'PLAY'},\n                    'MSFT': {'symbol': 'MSFT'}}\n\n        # Build a finder that is not allowed to assign sids, asserting failure\n        with self.assertRaises(SidAssignmentError):\n            AssetFinder(metadata=metadata, allow_sid_assignment=False)\n\n    def test_security_dates_warning(self):\n\n        # Build an asset with an end_date\n        eq_end = pd.Timestamp('2012-01-01', tz='UTC')\n        equity_asset = Equity(1, symbol=\"TESTEQ\", end_date=eq_end)\n\n        # Catch all warnings\n        with warnings.catch_warnings(record=True) as w:\n            # Cause all warnings to always be triggered\n            warnings.simplefilter(\"always\")\n            equity_asset.security_start_date\n            equity_asset.security_end_date\n            equity_asset.security_name\n            # Verify the warning\n            self.assertEqual(3, len(w))\n            for warning in w:\n                self.assertTrue(issubclass(warning.category,\n                                           DeprecationWarning))\n\n    def test_lookup_future_chain(self):\n        metadata = {\n            # Notice day is today, so not valid\n            2: {\n                'symbol': 'ADN15',\n                'root_symbol': 'AD',\n                'asset_type': 'future',\n                'notice_date': pd.Timestamp('2015-05-14', tz='UTC'),\n                'start_date': pd.Timestamp('2015-01-01', tz='UTC')\n            },\n            1: {\n                'symbol': 'ADV15',\n                'root_symbol': 'AD',\n                'asset_type': 'future',\n                'notice_date': pd.Timestamp('2015-08-14', tz='UTC'),\n                'start_date': pd.Timestamp('2015-01-01', tz='UTC')\n            },\n            # Starts trading today, so should be valid.\n            0: {\n                'symbol': 'ADF16',\n                'root_symbol': 'AD',\n                'asset_type': 'future',\n                'notice_date': pd.Timestamp('2015-11-16', tz='UTC'),\n                'start_date': pd.Timestamp('2015-05-14', tz='UTC')\n            },\n            # Copy of the above future, but starts trading in August,\n            # so it isn't valid.\n            3: {\n                'symbol': 'ADF16',\n                'root_symbol': 'AD',\n                'asset_type': 'future',\n                'notice_date': pd.Timestamp('2015-11-16', tz='UTC'),\n                'start_date': pd.Timestamp('2015-08-01', tz='UTC')\n            },\n\n        }\n\n        finder = AssetFinder(metadata=metadata)\n        dt = pd.Timestamp('2015-05-14', tz='UTC')\n        last_year = pd.Timestamp('2014-01-01', tz='UTC')\n        first_day = pd.Timestamp('2015-01-01', tz='UTC')\n\n        # Check that we get the expected number of contracts, in the\n        # right order\n        ad_contracts = finder.lookup_future_chain('AD', dt, dt)\n        self.assertEqual(len(ad_contracts), 2)\n        self.assertEqual(ad_contracts[0].sid, 1)\n        self.assertEqual(ad_contracts[1].sid, 0)\n\n        # Check that we get nothing if our knowledge date is last year\n        ad_contracts = finder.lookup_future_chain('AD', dt, last_year)\n        self.assertEqual(len(ad_contracts), 0)\n\n        # Check that we get things that start on the knowledge date\n        ad_contracts = finder.lookup_future_chain('AD', dt, first_day)\n        self.assertEqual(len(ad_contracts), 1)\n\n    def test_map_identifier_index_to_sids(self):\n        # Build an empty finder and some Assets\n        dt = pd.Timestamp('2014-01-01', tz='UTC')\n        finder = AssetFinder()\n        asset1 = Equity(1, symbol=\"AAPL\")\n        asset2 = Equity(2, symbol=\"GOOG\")\n        asset200 = Future(200, symbol=\"CLK15\")\n        asset201 = Future(201, symbol=\"CLM15\")\n\n        # Check for correct mapping and types\n        pre_map = [asset1, asset2, asset200, asset201]\n        post_map = finder.map_identifier_index_to_sids(pre_map, dt)\n        self.assertListEqual([1, 2, 200, 201], post_map)\n        for sid in post_map:\n            self.assertIsInstance(sid, int)\n\n        # Change order and check mapping again\n        pre_map = [asset201, asset2, asset200, asset1]\n        post_map = finder.map_identifier_index_to_sids(pre_map, dt)\n        self.assertListEqual([201, 2, 200, 1], post_map)\n\n    @with_environment()\n    def test_compute_lifetimes(self, env=None):\n        num_assets = 4\n        trading_day = env.trading_day\n        first_start = pd.Timestamp('2015-04-01', tz='UTC')\n\n        frame = make_rotating_asset_info(\n            num_assets=num_assets,\n            first_start=first_start,\n            frequency=env.trading_day,\n            periods_between_starts=3,\n            asset_lifetime=5\n        )\n        finder = AssetFinder(frame)\n\n        all_dates = pd.date_range(\n            start=first_start,\n            end=frame.end_date.max(),\n            freq=trading_day,\n        )\n\n        for dates in all_subindices(all_dates):\n            expected_mask = full(\n                shape=(len(dates), num_assets),\n                fill_value=False,\n                dtype=bool,\n            )\n\n            for i, date in enumerate(dates):\n                it = frame[['start_date', 'end_date']].itertuples()\n                for j, start, end in it:\n                    if start <= date <= end:\n                        expected_mask[i, j] = True\n\n            # Filter out columns with all-empty columns.\n            expected_result = pd.DataFrame(\n                data=expected_mask,\n                index=dates,\n                columns=frame.sid.values,\n            )\n            actual_result = finder.lifetimes(dates)\n            assert_frame_equal(actual_result, expected_result)\n\n\nclass TestFutureChain(TestCase):\n    metadata = {\n        0: {\n            'symbol': 'CLG06',\n            'root_symbol': 'CL',\n            'asset_type': 'future',\n            'start_date': pd.Timestamp('2005-12-01', tz='UTC'),\n            'notice_date': pd.Timestamp('2005-12-20', tz='UTC'),\n            'expiration_date': pd.Timestamp('2006-01-20', tz='UTC')},\n        1: {\n            'root_symbol': 'CL',\n            'symbol': 'CLK06',\n            'asset_type': 'future',\n            'start_date': pd.Timestamp('2005-12-01', tz='UTC'),\n            'notice_date': pd.Timestamp('2006-03-20', tz='UTC'),\n            'expiration_date': pd.Timestamp('2006-04-20', tz='UTC')},\n        2: {\n            'symbol': 'CLQ06',\n            'root_symbol': 'CL',\n            'asset_type': 'future',\n            'start_date': pd.Timestamp('2005-12-01', tz='UTC'),\n            'notice_date': pd.Timestamp('2006-06-20', tz='UTC'),\n            'expiration_date': pd.Timestamp('2006-07-20', tz='UTC')},\n        3: {\n            'symbol': 'CLX06',\n            'root_symbol': 'CL',\n            'asset_type': 'future',\n            'start_date': pd.Timestamp('2006-02-01', tz='UTC'),\n            'notice_date': pd.Timestamp('2006-09-20', tz='UTC'),\n            'expiration_date': pd.Timestamp('2006-10-20', tz='UTC')}\n    }\n\n    asset_finder = AssetFinder(metadata=metadata)\n\n    def test_len(self):\n        \"\"\" Test the __len__ method of FutureChain.\n        \"\"\"\n        # None of the contracts have started yet.\n        cl = FutureChain(self.asset_finder, lambda: '2005-11-30', 'CL')\n        self.assertEqual(len(cl), 0)\n\n        # Sids 0, 1, & 2 have started, 3 has not yet started.\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-01', 'CL')\n        self.assertEqual(len(cl), 3)\n\n        # Sid 0 is still valid the day before its notice date.\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-19', 'CL')\n        self.assertEqual(len(cl), 3)\n\n        # Sid 0 is now invalid, leaving only Sids 1 & 2 valid.\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-20', 'CL')\n        self.assertEqual(len(cl), 2)\n\n        # Sid 3 has started, so 1, 2, & 3 are now valid.\n        cl = FutureChain(self.asset_finder, lambda: '2006-02-01', 'CL')\n        self.assertEqual(len(cl), 3)\n\n        # All contracts are no longer valid.\n        cl = FutureChain(self.asset_finder, lambda: '2006-09-20', 'CL')\n        self.assertEqual(len(cl), 0)\n\n    def test_getitem(self):\n        \"\"\" Test the __getitem__ method of FutureChain.\n        \"\"\"\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-01', 'CL')\n        self.assertEqual(cl[0], 0)\n        self.assertEqual(cl[1], 1)\n        self.assertEqual(cl[2], 2)\n        with self.assertRaises(IndexError):\n            cl[3]\n\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-19', 'CL')\n        self.assertEqual(cl[0], 0)\n\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-20', 'CL')\n        self.assertEqual(cl[0], 1)\n\n        cl = FutureChain(self.asset_finder, lambda: '2006-02-01', 'CL')\n        self.assertEqual(cl[-1], 3)\n\n    def test_root_symbols(self):\n        \"\"\" Test that different variations on root symbols are handled\n        as expected.\n        \"\"\"\n        # Make sure this successfully gets the chain for CL.\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-01', 'CL')\n        self.assertEqual(cl.root_symbol, 'CL')\n\n        # These root symbols don't exist, so RootSymbolNotFound should\n        # be raised immediately.\n        with self.assertRaises(RootSymbolNotFound):\n            FutureChain(self.asset_finder, lambda: '2005-12-01', 'CLZ')\n\n        with self.assertRaises(RootSymbolNotFound):\n            FutureChain(self.asset_finder, lambda: '2005-12-01', '')\n\n    def test_repr(self):\n        \"\"\" Test the __repr__ method of FutureChain.\n        \"\"\"\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-01', 'CL')\n        cl_feb = FutureChain(self.asset_finder, lambda: '2005-12-01', 'CL',\n                             as_of_date='2006-02-01')\n\n        # The default chain should not include the as of date.\n        self.assertEqual(repr(cl), \"FutureChain(root_symbol='CL')\")\n\n        # An explicit as of date should show up in the repr.\n        self.assertEqual(\n            repr(cl_feb),\n            (\"FutureChain(root_symbol='CL', \"\n             \"as_of_date='2006-02-01 00:00:00+00:00')\")\n        )\n\n    def test_as_of(self):\n        \"\"\" Test the as_of method of FutureChain.\n        \"\"\"\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-01', 'CL')\n\n        # Test that the as_of_date is set correctly to the future\n        feb = '2006-02-01'\n        cl_feb = cl.as_of(feb)\n        self.assertEqual(\n            cl_feb.as_of_date,\n            pd.Timestamp(feb, tz='UTC')\n        )\n\n        # Test that the as_of_date is set correctly to the past, with\n        # args of str, datetime.datetime, and pd.Timestamp.\n        feb_prev = '2005-02-01'\n        cl_feb_prev = cl.as_of(feb_prev)\n        self.assertEqual(\n            cl_feb_prev.as_of_date,\n            pd.Timestamp(feb_prev, tz='UTC')\n        )\n\n        feb_prev = datetime(year=2005, month=2, day=1)\n        cl_feb_prev = cl.as_of(feb_prev)\n        self.assertEqual(\n            cl_feb_prev.as_of_date,\n            pd.Timestamp(feb_prev, tz='UTC')\n        )\n\n        feb_prev = pd.Timestamp('2005-02-01')\n        cl_feb_prev = cl.as_of(feb_prev)\n        self.assertEqual(\n            cl_feb_prev.as_of_date,\n            pd.Timestamp(feb_prev, tz='UTC')\n        )\n\n        # The chain as of the current dt should always be the same as\n        # the defualt chain. Tests date as str, pd.Timestamp, and\n        # datetime.datetime.\n        self.assertEqual(cl[0], cl.as_of('2005-12-01')[0])\n        self.assertEqual(cl[0], cl.as_of(pd.Timestamp('2005-12-01'))[0])\n        self.assertEqual(\n            cl[0],\n            cl.as_of(datetime(year=2005, month=12, day=1))[0]\n        )\n\n    def test_offset(self):\n        \"\"\" Test the offset method of FutureChain.\n        \"\"\"\n        cl = FutureChain(self.asset_finder, lambda: '2005-12-01', 'CL')\n\n        # Test that an offset forward sets as_of_date as expected\n        self.assertEqual(\n            cl.offset('3 days').as_of_date,\n            cl.as_of_date + pd.Timedelta(days=3)\n        )\n\n        # Test that an offset backward sets as_of_date as expected, with\n        # time delta given as str, datetime.timedelta, and pd.Timedelta.\n        self.assertEqual(\n            cl.offset('-1000 days').as_of_date,\n            cl.as_of_date + pd.Timedelta(days=-1000)\n        )\n        self.assertEqual(\n            cl.offset(timedelta(days=-1000)).as_of_date,\n            cl.as_of_date + pd.Timedelta(days=-1000)\n        )\n        self.assertEqual(\n            cl.offset(pd.Timedelta('-1000 days')).as_of_date,\n            cl.as_of_date + pd.Timedelta(days=-1000)\n        )\n\n        # An offset of zero should give the original chain.\n        self.assertEqual(cl[0], cl.offset(0)[0])\n        self.assertEqual(cl[0], cl.offset(\"0 days\")[0])\n\n        # A string that doesn't represent a time delta should raise a\n        # ValueError.\n        with self.assertRaises(ValueError):\n            cl.offset(\"blah\")\n        self.assertEqual(cl.offset(0)\n        )\n        if cl.offset\n\n        self.assertEqual(\n            cl.offset(0)\n        )\n\n\n        # Test that as_of_date.\n        "
  },
  "feature_stats": {
    "indices": [
      0,
      2,
      8711,
      2874,
      1646,
      5111,
      3943,
      8935,
      7673,
      3030,
      8147
    ],
    "f_before": [
      48.94874954223633,
      0.0,
      0.7621291279792786,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "f_after": [
      48.94874954223633,
      0.0,
      0.7621291279792786,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "g_before": [
      0.03846938535571098,
      28.675052642822266,
      5.159969329833984,
      5.0200419425964355,
      5.220460891723633,
      5.376467704772949,
      4.739353179931641,
      5.128687381744385,
      4.768220901489258,
      4.7950239181518555,
      0.0
    ],
    "g_after": [
      0.03846938535571098,
      28.675052642822266,
      5.159969329833984,
      5.0200419425964355,
      5.220460891723633,
      5.376467704772949,
      4.739353179931641,
      5.128687381744385,
      4.768220901489258,
      4.7950239181518555,
      0.0
    ],
    "num_batches_for_stats": 10
  },
  "loss_summary": {
    "train_mean_loss": 8.755375345926732,
    "train_mean_l2": 5.643428234145046,
    "train_mean_l1": 3.491124365925789,
    "num_steps": 2000,
    "num_batches": 2000
  },
  "feature_std_summary": {
    "plot_path": "outputs/plots/20251128-161814/feature_std_layer_12.html",
    "mean_std": 1.2764151096343994,
    "max_std": 34.51808166503906
  }
}