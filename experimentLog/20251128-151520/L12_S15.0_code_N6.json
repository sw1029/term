{
  "model_name": "google/gemma-2-2b-it",
  "layer_idx": 12,
  "command": "python main.py experiment.use_multi_contrast=true sae.loss_option=2 sae.loss_module=option2_loss sae.guidance_method=contrastive sae.guidance_coeff=1.0 sae.alpha_concept.code=0.04 sae.alpha_concept.harm=0.06 sae.alpha_concept.struct=0.0 sae.use_l0=true sae.l0_coeff=0.0002314673387520083 sae.role_sep_coeff=0.002",
  "sae": {
    "input_dim": 2304,
    "sae_dim": 9216,
    "fixed_v_cnt": 3,
    "batch_size": 3,
    "epochs": 2,
    "max_steps": 2000,
    "l1_coeff": 0.005,
    "l0_coeff": 0.0002314673387520083,
    "use_l0": true,
    "concept_samples_per_label": 100,
    "loss_option": 2,
    "loss_module": "option2_loss",
    "concept_feature_indices": {
      "code": 0,
      "harm": 1,
      "struct": 2
    },
    "alpha_concept": {
      "code": 0.04,
      "harm": 0.06,
      "struct": 0.0
    },
    "positive_targets": {
      "code": 1,
      "harm": 1,
      "struct": 1
    },
    "guidance_method": "contrastive",
    "guidance_margin": 0.0,
    "guidance_coeff": 1.0,
    "guidance_mse_pos_value": 1.0,
    "guidance_mse_neg_value": 0.0,
    "jumprelu_bandwidth": 0.001,
    "jumprelu_init_threshold": 0.001,
    "role_sep_coeff": 0.002
  },
  "gnn": {
    "use_gnn": true,
    "top_k": 10
  },
  "experiment": {
    "device": "cuda",
    "dataset_name": "wikitext",
    "dataset_config": "wikitext-2-raw-v1",
    "use_multi_contrast": true,
    "num_steering_samples_per_label": 10,
    "top_k_for_plot": 10,
    "layer_sweep": [
      12
    ],
    "strength_sweep": [
      15.0
    ]
  },
  "steering": {
    "label": "code",
    "feature_idx": 0,
    "strength": 15.0
  },
  "prompt": "\"\"\"\n    OpenAPI Petstore\n\n    This spec is mainly for testing Petstore server and contains fake endpoints, models. Please do not use this for any other purpose. Special characters: \\\" \\\\  # noqa: E501\n\n    The version of the OpenAPI document: 1.0.0\n    Generated by: https://openapi-generator.tech\n\"\"\"\n\n\nfrom datetime import date, datetime  # noqa: F401\nimport inspect\nimport io\nimport os\nimport pprint\nimport re\nimport tempfile\n\nfrom dateutil.parser import parse\n\nfrom petstore_api.exceptions import (\n    ApiKeyError,\n    ApiAttributeError,\n    ApiTypeError,\n    ApiValueError,\n)\n\nnone_type = type(None)\nfile_type = io.IOBase\n\n\nclass cached_property(object):\n    # this caches the result of the function call for fn with no inputs\n    # use this as a decorator on fuction methods that you want converted\n    # into cached properties\n    result_key = '_results'\n\n    def __init__(self, fn):\n        self._fn = fn\n\n    def __get__(self, instance, cls=None):\n        if self.result_key in vars(self):\n            return vars(self)[self.result_key]\n        else:\n            result = self._fn()\n            setattr(self, self.result_key, result)\n            return result\n\n\nPRIMITIVE_TYPES = (list, float, int, bool, datetime, date, str, file_type)\n\ndef allows_single_value_input(cls):\n    \"\"\"\n    This function returns True if the input composed schema model or any\n    descendant model allows a value only input\n    This is true for cases where oneOf contains items like:\n    oneOf:\n      - float\n      - NumberWithValidation\n      - StringEnum\n      - ArrayModel\n      - null\n    TODO: lru_cache this\n    \"\"\"\n    if (\n        issubclass(cls, ModelSimple) or\n        cls in PRIMITIVE_TYPES\n    ):\n        return True\n    elif issubclass(cls, ModelComposed):\n        if not cls._composed_schemas['oneOf']:\n            return False\n        return any(allows_single_value_input(c) for c in cls._composed_schemas['oneOf'])\n    return False\n\ndef composed_model_input_classes(cls):\n    \"\"\"\n    This function returns a list of the possible models that can be accepted as\n    inputs.\n    TODO: lru_cache this\n    \"\"\"\n    if issubclass(cls, ModelSimple) or cls in PRIMITIVE_TYPES:\n        return [cls]\n    elif issubclass(cls, ModelNormal):\n        if cls.discriminator is None:\n            return [cls]\n        else:\n            return get_discriminated_classes(cls)\n    elif issubclass(cls, ModelComposed):\n        if not cls._composed_schemas['oneOf']:\n            return []\n        if cls.discriminator is None:\n            input_classes = []\n            for c in cls._composed_schemas['oneOf']:\n                input_classes.extend(composed_model_input_classes(c))\n            return input_classes\n        else:\n            return get_discriminated_classes(cls)\n    return []\n\n\nclass OpenApiModel(object):\n    \"\"\"The base class for all OpenAPIModels\"\"\"\n\n    def set_attribute(self, name, value):\n        # this is only used to set properties on self\n\n        path_to_item = []\n        if self._path_to_item:\n            path_to_item.extend(self._path_to_item)\n        path_to_item.append(name)\n\n        if name in self.openapi_types:\n            required_types_mixed = self.openapi_types[name]\n        elif self.additional_properties_type is None:\n            raise ApiAttributeError(\n                \"{0} has no attribute '{1}'\".format(\n                    type(self).__name__, name),\n                path_to_item\n            )\n        elif self.additional_properties_type is not None:\n            required_types_mixed = self.additional_properties_type\n\n        if get_simple_class(name) != str:\n            error_msg = type_error_message(\n                var_name=name,\n                var_value=name,\n                valid_classes=(str,),\n                key_type=True\n            )\n            raise ApiTypeError(\n                error_msg,\n                path_to_item=path_to_item,\n                valid_classes=(str,),\n                key_type=True\n            )\n\n        if self._check_type:\n            value = validate_and_convert_types(\n                value, required_types_mixed, path_to_item, self._spec_property_naming,\n                self._check_type, configuration=self._configuration)\n        if (name,) in self.allowed_values:\n            check_allowed_values(\n                self.allowed_values,\n                (name,),\n                value\n            )\n        if (name,) in self.validations:\n            check_validations(\n                self.validations,\n                (name,),\n                value,\n                self._configuration\n            )\n        self.__dict__['_data_store'][name] = value\n\n    def __repr__(self):\n        \"\"\"For `print` and `pprint`\"\"\"\n        return self.to_str()\n\n    def __ne__(self, other):\n        \"\"\"Returns true if both objects are not equal\"\"\"\n        return not self == other\n\n    def __setattr__(self, attr, value):\n        \"\"\"set the value of an attribute using dot notation: `instance.attr = val`\"\"\"\n        self[attr] = value\n\n    def __getattr__(self, attr):\n        \"\"\"get the value of an attribute using dot notation: `instance.attr`\"\"\"\n        return self.__getitem__(attr)\n\n    def __new__(cls, *args, **kwargs):\n        # this function uses the discriminator to\n        # pick a new schema/class to instantiate because a discriminator\n        # propertyName value was passed in\n\n        if len(args) == 1:\n            arg = args[0]\n            if arg is None and is_type_nullable(cls):\n                # The input data is the 'null' value and the type is nullable.\n                return None\n\n            if issubclass(cls, ModelComposed) and allows_single_value_input(cls):\n                model_kwargs = {}\n                oneof_instance = get_oneof_instance(cls, model_kwargs, kwargs, model_arg=arg)\n                return oneof_instance\n\n\n        visited_composed_classes = kwargs.get('_visited_composed_classes', ())\n        if (\n            cls.discriminator is None or\n            cls in visited_composed_classes\n        ):\n            # Use case 1: this openapi schema (cls) does not have a discriminator\n            # Use case 2: we have already visited this class before and are sure that we\n            # want to instantiate it this time. We have visited this class deserializing\n            # a payload with a discriminator. During that process we traveled through\n            # this class but did not make an instance of it. Now we are making an\n            # instance of a composed class which contains cls in it, so this time make an instance of cls.\n            #\n            # Here's an example of use case 2: If Animal has a discriminator\n            # petType and we pass in \"Dog\", and the class Dog\n            # allOf includes Animal, we move through Animal\n            # once using the discriminator, and pick Dog.\n            # Then in the composed schema dog Dog, we will make an instance of the\n            # Animal class (because Dal has allOf: Animal) but this time we won't travel\n            # through Animal's discriminator because we passed in\n            # _visited_composed_classes = (Animal,)\n\n            return super(OpenApiModel, cls).__new__(cls)\n\n        # Get the name and value of the discriminator property.\n        # The discriminator name is obtained from the discriminator meta-data\n        # and the discriminator value is obtained from the input data.\n        discr_propertyname_py = list(cls.discriminator.keys())[0]\n        discr_propertyname_js = cls.attribute_map[discr_propertyname_py]\n        if discr_propertyname_js in kwargs:\n            discr_value = kwargs[discr_propertyname_js]\n        elif discr_propertyname_py in kwargs:\n            discr_value = kwargs[discr_propertyname_py]\n        else:\n            # The input data does not contain the discriminator property.\n            path_to_item = kwargs.get('_path_to_item', ())\n            raise ApiValueError(\n                \"Cannot deserialize input data due to missing discriminator. \"\n                \"The discriminator property '%s' is missing at path: %s\" %\n                (discr_propertyname_js, path_to_item)\n            )\n\n        # Implementation note: the last argument to get_discriminator_class\n        # is a list of visited classes. get_discriminator_class may recursively\n        # call itself and update the list of visited classes, and the initial\n        # value must be an empty list. Hence not using 'visited_composed_classes'\n        new_cls = get_discriminator_class(\n                    cls, discr_propertyname_py, discr_value, [])\n        if new_cls is None:\n            path_to_item = kwargs.get('_path_to_item', ())\n            disc_prop_value = kwargs.get(\n                discr_propertyname_js, kwargs.get(discr_propertyname_py))\n            raise ApiValueError(\n                \"Cannot deserialize input data due to invalid discriminator \"\n                \"value. The OpenAPI document has no mapping for discriminator \"\n                \"property '%s'='%s' at path: %s\" %\n                (discr_propertyname_js, disc_prop_value, path_to_item)\n            )\n\n        if new_cls in visited_composed_classes:\n            # if we are making an instance of a composed schema Descendent\n            # which allOf includes Ancestor, then Ancestor contains\n            # a discriminator that includes Descendent.\n            # So if we make an instance of Descendent, we have to make an\n            # instance of Ancestor to hold the allOf properties.\n            # This code detects that use case and makes the instance of Ancestor\n            # For example:\n            # When making an instance of Dog, _visited_composed_classes = (Dog,)\n            # then we make an instance of Animal to include in dog._composed_instances\n            # so when we are here, cls is Animal\n            # cls.discriminator != None\n            # cls not in _visited_composed_classes\n            # new_cls = Dog\n            # but we know we know that we already have Dog\n            # because it is in visited_composed_classes\n            # so make Animal here\n            return super(OpenApiModel, cls).__new__(cls)\n\n        # Build a list containing all oneOf and anyOf descendants.\n        oneof_anyof_classes = None\n        if cls._composed_schemas is not None:\n            oneof_anyof_classes = (\n                cls._composed_schemas.get('oneOf', ()) +\n                cls._composed_schemas.get('anyOf', ()))\n        oneof_anyof_child = new_cls in oneof_anyof_classes\n        kwargs['_visited_composed_classes'] = visited_composed_classes + (cls,)\n\n        if cls._composed_schemas.get('allOf') and oneof_anyof_child:\n            # Validate that we can make self because when we make the\n            # new_cls it will not include the allOf validations in self\n            self_inst = super(OpenApiModel, cls).__new__(cls)\n            self_inst.__init__(*args, **kwargs)\n\n        new_inst = new_cls.__new__(new_cls, *args, **kwargs)\n        new_inst.__init__(*args, **kwargs)\n        return new_inst\n\n\nclass ModelSimple(OpenApiModel):\n    \"\"\"the parent class of models whose type != object in their\n    swagger/openapi\"\"\"\n\n    def __setitem__(self, name, value):\n        \"\"\"set the value of an attribute using square-bracket notation: `instance[attr] = val`\"\"\"\n        if name in self.required_properties:\n            self.__dict__[name] = value\n            return\n\n        self.set_attribute(name, value)\n\n    def get(self, name, default=None):\n        \"\"\"returns the value of an attribute or some default value if the attribute was not set\"\"\"\n        if name in self.required_properties:\n            return self.__dict__[name]\n\n        return self.__dict__['_data_store'].get(name, default)\n\n    def __getitem__(self, name):\n        \"\"\"get the value of an attribute using square-bracket notation: `instance[attr]`\"\"\"\n        if name in self:\n            return self.get(name)\n\n        raise ApiAttributeError(\n            \"{0} has no attribute '{1}'\".format(\n                type(self).__name__, name),\n            [e for e in [self._path_to_item, name] if e]\n        )\n\n    def __contains__(self, name):\n        \"\"\"used by `in` operator to check if an attrbute value was set in an instance: `'attr' in instance`\"\"\"\n        if name in self.required_properties:\n            return name in self.__dict__\n\n        return name in self.__dict__['_data_store']\n\n    def to_str(self):\n        \"\"\"Returns the string representation of the model\"\"\"\n        return str(self.value)\n\n    def __eq__(self, other):\n        \"\"\"Returns true if both objects are equal\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n\n        this_val = self._data_store['value']\n        that_val = other._data_store['value']\n        types = set()\n        types.add(this_val.__class__)\n        types.add(that_val.__class__)\n        vals_equal = this_val == that_val\n        return vals_equal\n\n\nclass ModelNormal(OpenApiModel):\n    \"\"\"the parent class of models whose type == object in their\n    swagger/openapi\"\"\"\n\n    def __setitem__(self, name, value):\n        \"\"\"set the value of an attribute using square-bracket notation: `instance[attr] = val`\"\"\"\n        if name in self.required_properties:\n            self.__dict__[name] = value\n            return\n\n        self.set_attribute(name, value)\n\n    def get(self, name, default=None):\n        \"\"\"returns the value of an attribute or some default value if the attribute was not set\"\"\"\n        if name in self.required_properties:\n            return self.__dict__[name]\n\n        return self.__dict__['_data_store'].get(name, default)\n\n    def __getitem__(self, name):\n        \"\"\"get the value of an attribute using square-bracket notation: `instance[attr]`\"\"\"\n        if name in self:\n            return self.get(name)\n\n        raise ApiAttributeError(\n            \"{0} has no attribute '{1}'\".format(\n                type(self).__name__, name),\n            [e for e in [self._path_to_item, name] if e]\n        )\n\n    def __contains__(self, name):\n        \"\"\"used by `in` operator to check if an attrbute value was set in an instance: `'attr' in instance`\"\"\"\n        if name in self.required_properties:\n            return name in self.__dict__\n\n        return name in self.__dict__['_data_store']\n\n    def to_dict(self):\n        \"\"\"Returns the model properties as a dict\"\"\"\n        return model_to_dict(self, serialize=False)\n\n    def to_str(self):\n        \"\"\"Returns the string representation of the model\"\"\"\n        return pprint.pformat(self.to_dict())\n\n    def __eq__(self, other):\n        \"\"\"Returns true if both objects are equal\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n\n        if not set(self._data_store.keys()) == set(other._data_store.keys()):\n            return False\n        for _var_name, this_val in self._data_store.items():\n            that_val = other._data_store[_var_name]\n            types = set()\n            types.add(this_val.__class__)\n            types.add(that_val.__class__)\n            vals_equal = this_val == that_val\n            if not vals_equal:\n                return False\n        return True\n\n\nclass ModelComposed(OpenApiModel):\n    \"\"\"the parent class of models whose type == object in their\n    swagger/openapi and have oneOf/allOf/anyOf\n\n    When one sets a property we use var_name_to_model_instances to store the value in\n    the correct class instances + run any type checking + validation code.\n    When one gets a property we use var_name_to_model_instances to get the value\n    from the correct class instances.\n    This allows multiple composed schemas to contain the same property with additive\n    constraints on the value.\n\n    _composed_schemas (dict) stores the anyOf/allOf/oneOf classes\n    key (str): allOf/oneOf/anyOf\n    value (list): the classes in the XOf definition.\n        Note: none_type can be included when the openapi document version >= 3.1.0\n    _composed_instances (list): stores a list of instances of the composed schemas\n    defined in _composed_schemas. When properties are accessed in the self instance,\n    they are returned from the self._data_store or the data stores in the instances\n    in self._composed_schemas\n    _var_name_to_model_instances (dict): maps between a variable name on self and\n    the composed instances (self included) which contain that data\n    key (str): property name\n    value (list): list of class instances, self or instances in _composed_instances\n    which contain the value that the key is referring to.\n    \"\"\"\n\n    def __setitem__(self, name, value):\n        \"\"\"set the value of an attribute using square-bracket notation: `instance[attr] = val`\"\"\"\n        if name in self.required_properties:\n            self.__dict__[name] = value\n            return\n\n        # set the attribute on the correct instance\n        model_instances = self._var_name_to_model_instances.get(\n            name, self._additional_properties_model_instances)\n        if model_instances:\n            for model_instance in model_instances:\n                if model_instance == self:\n                    self.set_attribute(name, value)\n                else:\n                    setattr(model_instance, name, value)\n                if name not in self._var_name_to_model_instances:\n                    # we assigned an additional property\n                    self.__dict__['_var_name_to_model_instances'][name] = (\n                        model_instance\n                    )\n            return None\n\n        raise ApiAttributeError(\n            \"{0} has no attribute '{1}'\".format(\n                type(self).__name__, name),\n            [e for e in [self._path_to_item, name] if e]\n        )\n\n    __unset_attribute_value__ = object()\n\n    def get(self, name, default=None):\n        \"\"\"returns the value of an attribute or some default value if the attribute was not set\"\"\"\n        if name in self.required_properties:\n            return self.__dict__[name]\n\n        # get the attribute from the correct instance\n        model_instances = self._var_name_to_model_instances.get(\n            name, self._additional_properties_model_instances)\n        values = []\n        # A composed model stores child (oneof/anyOf/allOf) models under\n        # self._var_name_to_model_instances. A named property can exist in\n        # multiple child models. If the property is present in more than one\n        # child model, the value must be the same across all the child models.\n        if model_instances:\n            for model_instance in model_instances:\n                if name in model_instance._data_store:\n                    v = model_instance._data_store[name]\n                    if v not in values:\n                        values.append(v)\n        len_values = len(values)\n        if len_values == 0:\n            return default\n        elif len_values == 1:\n            return values[0]\n        elif len_values > 1:\n            raise ApiValueError(\n                \"Values stored for property {0} in {1} differ when looking \"\n                \"at self and self's composed instances. All values must be \"\n                \"the same\".format(name, type(self).__name__),\n                [e for e in [self._path_to_item, name] if e]\n            )\n\n    def __getitem__(self, name):\n        \"\"\"get the value of an attribute using square-bracket notation: `instance[attr]`\"\"\"\n        value = self.get(name, self.__unset_attribute_value__)\n        if value is self.__unset_attribute_value__:\n            raise ApiAttributeError(\n                \"{0} has no attribute '{1}'\".format(\n                    type(self).__name__, name),\n                    [e for e in [self._path_to_item, name] if e]\n            )\n        return value\n\n    def __contains__(self, name):\n        \"\"\"used by `in` operator to check if an attrbute value was set in an instance: `'attr' in instance`\"\"\"\n\n        if name in self.required_properties:\n            return name in self.__dict__\n\n        model_instances = self._var_name_to_model_instances.get(\n            name, self._additional_properties_model_instances)\n\n        if model_instances:\n            for model_instance in model_instances:\n                if name in model_instance._data_store:\n                    return True\n\n        return False\n\n    def to_dict(self):\n        \"\"\"Returns the model properties as a dict\"\"\"\n        return model_to_dict(self, serialize=False)\n\n    def to_str(self):\n        \"\"\"Returns the string representation of the model\"\"\"\n        return pprint.pformat(self.to_dict())\n\n    def __eq__(self, other):\n        \"\"\"Returns true if both objects are equal\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n\n        if not set(self._data_store.keys()) == set(other._data_store.keys()):\n            return False\n        for _var_name, this_val in self._data_store.items():\n            that_val = other._data_store[_var_name]\n            types = set()\n            types.add(this_val.__class__)\n            types.add(that_val.__class__)\n            vals_equal = this_val == that_val\n            if not vals_equal:\n                return False\n        return True\n\n\nCOERCION_INDEX_BY_TYPE = {\n    ModelComposed: 0,\n    ModelNormal: 1,\n    ModelSimple: 2,\n    none_type: 3,    # The type of 'None'.\n    list: 4,\n    dict: 5,\n    float: 6,\n    int: 7,\n    bool: 8,\n    datetime: 9,\n    date: 10,\n    str: 11,\n    file_type: 12,   # 'file_type' is an alias for the built-in 'file' or 'io.IOBase' type.\n}\n\n# these are used to limit what type conversions we try to do\n# when we have a valid type already and we want to try converting\n# to another type\nUPCONVERSION_TYPE_PAIRS = (\n    (str, datetime),\n    (str, date),\n    (int, float),             # A float may be serialized as an integer, e.g. '3' is a valid serialized float.\n    (list, ModelComposed),\n    (dict, ModelComposed),\n    (str, ModelComposed),\n    (int, ModelComposed),\n    (float, ModelComposed),\n    (list, ModelComposed),\n    (list, ModelNormal),\n    (dict, ModelNormal),\n    (str, ModelSimple),\n    (int, ModelSimple),\n    (float, ModelSimple),\n    (list, ModelSimple),\n)\n\nCOERCIBLE_TYPE_PAIRS = {\n    False: (  # client instantiation of a model with client data\n        # (dict, ModelComposed),\n        # (list, ModelComposed),\n        # (dict, ModelNormal),\n        # (list, ModelNormal),\n        # (str, ModelSimple),\n        # (int, ModelSimple),\n        # (float, ModelSimple),\n        # (list, ModelSimple),\n        # (str, int),\n        # (str, float),\n        # (str, datetime),\n        # (str, date),\n        # (int, str),\n        # (float, str),\n    ),\n    True: (  # server -> client data\n        (dict, ModelComposed),\n        (list, ModelComposed),\n        (dict, ModelNormal),\n        (list, ModelNormal),\n        (str, ModelSimple),\n        (int, ModelSimple),\n        (float, ModelSimple),\n        (list, ModelSimple),\n        # (str, int),\n        # (str, float),\n        (str, datetime),\n        (str, date),\n        # (int, str),\n        # (float, str),\n        (str, file_type)\n    ),\n}\n\n\ndef get_simple_class(input_value):\n    \"\"\"Returns an input_value's simple class that we will use for type checking\n    Python2:\n    float and int will return int, where int is the python3 int backport\n    str and unicode will return str, where str is the python3 str backport\n    Note: float and int ARE both instances of int backport\n    Note: str_py2 and unicode_py2 are NOT both instances of str backport\n\n    Args:\n        input_value (class/class_instance): the item for which we will return\n                                            the simple class\n    \"\"\"\n    if isinstance(input_value, type):\n        # input_value is a class\n        return input_value\n    elif isinstance(input_value, tuple):\n        return tuple\n    elif isinstance(input_value, list):\n        return list\n    elif isinstance(input_value, dict):\n        return dict\n    elif isinstance(input_value, none_type):\n        return none_type\n    elif isinstance(input_value, file_type):\n        return file_type\n    elif isinstance(input_value, bool):\n        # this must be higher than the int check because\n        # isinstance(True, int) == True\n        return bool\n    elif isinstance(input_value, int):\n        return int\n    elif isinstance(input_value, datetime):\n        # this must be higher than the date check because\n        # isinstance(datetime_instance, date) == True\n        return datetime\n    elif isinstance(input_value, date):\n        return date\n    elif isinstance(input_value, str):\n        return str\n    return type(input_value)\n\n\ndef check_allowed_values(allowed_values, input_variable_path, input_values):\n    \"\"\"Raises an exception if the input_values are not allowed\n\n    Args:\n        allowed_values (dict): the allowed_values dict\n        input_variable_path (tuple): the path to the input variable\n        input_values (list/str/int/float/date/datetime): the values that we\n            are checking to see if they are in allowed_values\n    \"\"\"\n    these_allowed_values = list(allowed_values[input_variable_path].values())\n    if (isinstance(input_values, list)\n            and not set(input_values).issubset(\n                set(these_allowed_values))):\n        invalid_values = \", \".join(\n            map(str, set(input_values) - set(these_allowed_values))),\n        raise ApiValueError(\n            \"Invalid values for `%s` [%s], must be a subset of [%s]\" %\n            (\n                input_variable_path[0],\n                invalid_values,\n                \", \".join(map(str, these_allowed_values))\n            )\n        )\n    elif (isinstance(input_values, dict)\n            and not set(\n                input_values.keys()).issubset(set(these_allowed_values))):\n        invalid_values = \", \".join(\n            map(str, set(input_values.keys()) - set(these_allowed_values)))\n        raise ApiValueError(\n            \"Invalid keys in `%s` [%s], must be a subset of [%s]\" %\n            (\n                input_variable_path[0],\n                invalid_values,\n                \", \".join(map(str, these_allowed_values))\n            )\n        )\n    elif (not isinstance(input_values, (list, dict))\n            and input_values not in these_allowed_values):\n        raise ApiValueError(\n            \"Invalid value for `%s` (%s), must be one of %s\" %\n            (\n                input_variable_path[0],\n                input_values,\n                these_allowed_values\n            )\n        )\n\n\ndef is_json_validation_enabled(schema_keyword, configuration=None):\n    \"\"\"Returns true if JSON schema validation is enabled for the specified\n    validation keyword. This can be used to skip JSON schema structural validation\n    as requested in the configuration.\n\n    Args:\n        schema_keyword (string): the name of a JSON schema validation keyword.\n        configuration (Configuration): the configuration class.\n    \"\"\"\n\n    return (configuration is None or\n        not hasattr(configuration, '_disabled_client_side_validations') or\n        schema_keyword not in configuration._disabled_client_side_validations)\n\n\ndef check_validations(\n        validations, input_variable_path, input_values,\n        configuration=None):\n    \"\"\"Raises an exception if the input_values are invalid\n\n    Args:\n        validations (dict): the validation dictionary.\n        input_variable_path (tuple): the path to the input variable.\n        input_values (list/str/int/float/date/datetime): the values that we\n            are checking.\n        configuration (Configuration): the configuration class.\n    \"\"\"\n\n    if input_values is None:\n        return\n\n    current_validations = validations[input_variable_path]\n    if (is_json_validation_enabled('multipleOf', configuration) and\n            'multiple_of' in current_validations and\n            isinstance(input_values, (int, float)) and\n            not (float(input_values) / current_validations['multiple_of']).is_integer()):\n        # Note 'multipleOf' will be as good as the floating point arithmetic.\n        raise ApiValueError(\n            \"Invalid value for `%s`, value must be a multiple of \"\n            \"`%s`\" % (\n                input_variable_path[0],\n                current_validations['multiple_of']\n            )\n        )\n\n    if (is_json_validation_enabled('maxLength', configuration) and\n            'max_length' in current_validations and\n            len(input_values) > current_validations['max_length']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, length must be less than or equal to \"\n            \"`%s`\" % (\n                input_variable_path[0],\n                current_validations['max_length']\n            )\n        )\n\n    if (is_json_validation_enabled('minLength', configuration) and\n            'min_length' in current_validations and\n            len(input_values) < current_validations['min_length']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, length must be greater than or equal to \"\n            \"`%s`\" % (\n                input_variable_path[0],\n                current_validations['min_length']\n            )\n        )\n\n    if (is_json_validation_enabled('maxItems', configuration) and\n            'max_items' in current_validations and\n            len(input_values) > current_validations['max_items']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, number of items must be less than or \"\n            \"equal to `%s`\" % (\n                input_variable_path[0],\n                current_validations['max_items']\n            )\n        )\n\n    if (is_json_validation_enabled('minItems', configuration) and\n            'min_items' in current_validations and\n            len(input_values) < current_validations['min_items']):\n        raise ValueError(\n            \"Invalid value for `%s`, number of items must be greater than or \"\n            \"equal to `%s`\" % (\n                input_variable_path[0],\n                current_validations['min_items']\n            )\n        )\n\n    items = ('exclusive_maximum', 'inclusive_maximum', 'exclusive_minimum',\n             'inclusive_minimum')\n    if (any(item in current_validations for item in items)):\n        if isinstance(input_values, list):\n            max_val = max(input_values)\n            min_val = min(input_values)\n        elif isinstance(input_values, dict):\n            max_val = max(input_values.values())\n            min_val = min(input_values.values())\n        else:\n            max_val = input_values\n            min_val = input_values\n\n    if (is_json_validation_enabled('exclusiveMaximum', configuration) and\n            'exclusive_maximum' in current_validations and\n            max_val >= current_validations['exclusive_maximum']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, must be a value less than `%s`\" % (\n                input_variable_path[0],\n                current_validations['exclusive_maximum']\n            )\n        )\n\n    if (is_json_validation_enabled('maximum', configuration) and\n            'inclusive_maximum' in current_validations and\n            max_val > current_validations['inclusive_maximum']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, must be a value less than or equal to \"\n            \"`%s`\" % (\n                input_variable_path[0],\n                current_validations['inclusive_maximum']\n            )\n        )\n\n    if (is_json_validation_enabled('exclusiveMinimum', configuration) and\n            'exclusive_minimum' in current_validations and\n            min_val <= current_validations['exclusive_minimum']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, must be a value greater than `%s`\" %\n            (\n                input_variable_path[0],\n                current_validations['exclusive_maximum']\n            )\n        )\n\n    if (is_json_validation_enabled('minimum', configuration) and\n            'inclusive_minimum' in current_validations and\n            min_val < current_validations['inclusive_minimum']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, must be a value greater than or equal \"\n            \"to `%s`\" % (\n                input_variable_path[0],\n                current_validations['inclusive_minimum']\n            )\n        )\n    flags = current_validations.get('regex', {}).get('flags', 0)\n    if (is_json_validation_enabled('pattern', configuration) and\n            'regex' in current_validations and\n            not re.search(current_validations['regex']['pattern'],\n                          input_values, flags=flags)):\n        err_msg = r\"Invalid value for `%s`, must match regular expression `%s`\" % (\n                    input_variable_path[0],\n                    current_validations['regex']['pattern']\n                )\n        if flags != 0:\n            # Don't print the regex flags if the flags are not\n            # specified in the OAS document.\n            err_msg = r\"%s with flags=`%s`\" % (err_msg, flags)\n        raise ApiValueError(err_msg)\n\n\ndef order_response_types(required_types):\n    \"\"\"Returns the required types sorted in coercion order\n\n    Args:\n        required_types (list/tuple): collection of classes or instance of\n            list or dict with class information inside it.\n\n    Returns:\n        (list): coercion order sorted collection of classes or instance\n            of list or dict with class information inside it.\n    \"\"\"\n\n    def index_getter(class_or_instance):\n        if isinstance(class_or_instance, list):\n            return COERCION_INDEX_BY_TYPE[list]\n        elif isinstance(class_or_instance, dict):\n            return COERCION_INDEX_BY_TYPE[dict]\n        elif (inspect.isclass(class_or_instance)\n                and issubclass(class_or_instance, ModelComposed)):\n            return COERCION_INDEX_BY_TYPE[ModelComposed]\n        elif (inspect.isclass(class_or_instance)\n                and issubclass(class_or_instance, ModelNormal)):\n            return COERCION_INDEX_BY_TYPE[ModelNormal]\n        elif (inspect.isclass(class_or_instance)\n                and issubclass(class_or_instance, ModelSimple)):\n            return COERCION_INDEX_BY_TYPE[ModelSimple]\n        elif class_or_instance in COERCION_INDEX_BY_TYPE:\n            return COERCION_INDEX_BY_TYPE[class_or_instance]\n        raise ApiValueError(\"Unsupported type: %s\" % class_or_instance)\n\n    sorted_types = sorted(\n        required_types,\n        key=lambda class_or_instance: index_getter(class_or_instance)\n    )\n    return sorted_types\n\n\ndef remove_uncoercible(required_types_classes, current_item, spec_property_naming,\n                       must_convert=True):\n    \"\"\"Only keeps the type conversions that are possible\n\n    Args:\n        required_types_classes (tuple): tuple of classes that are required\n                          these should be ordered by COERCION_INDEX_BY_TYPE\n        spec_property_naming (bool): True if the variable names in the input\n            data are serialized names as specified in the OpenAPI document.\n            False if the variables names in the input data are python\n            variable names in PEP-8 snake case.\n        current_item (any): the current item (input data) to be converted\n\n    Keyword Args:\n        must_convert (bool): if True the item to convert is of the wrong\n                          type and we want a big list of coercibles\n                          if False, we want a limited list of coercibles\n\n    Returns:\n        (list): the remaining coercible required types, classes only\n    \"\"\"\n    current_type_simple = get_simple_class(current_item)\n\n    results_classes = []\n    for required_type_class in required_types_classes:\n        # convert our models to OpenApiModel\n        required_type_class_simplified = required_type_class\n        if isinstance(required_type_class_simplified, type):\n            if issubclass(required_type_class_simplified, ModelComposed):\n                required_type_class_simplified = ModelComposed\n            elif issubclass(required_type_class_simplified, ModelNormal):\n                required_type_class_simplified = ModelNormal\n            elif issubclass(required_type_class_simplified, ModelSimple):\n                required_type_class_simplified = ModelSimple\n\n        if required_type_class_simplified == current_type_simple:\n            # don't consider converting to one's own class\n            continue\n\n        class_pair = (current_type_simple, required_type_class_simplified)\n        if must_convert and class_pair in COERCIBLE_TYPE_PAIRS[spec_property_naming]:\n            results_classes.append(required_type_class)\n        elif class_pair in UPCONVERSION_TYPE_PAIRS:\n            results_classes.append(required_type_class)\n    return results_classes\n\ndef get_discriminated_classes(cls):\n    \"\"\"\n    Returns all the classes that a discriminator converts to\n    TODO: lru_cache this\n    \"\"\"\n    possible_classes = []\n    key = list(cls.discriminator.keys())[0]\n    if is_type_nullable(cls):\n        possible_classes.append(cls)\n    for discr_cls in cls.discriminator[key].values():\n        if hasattr(discr_cls, 'discriminator') and discr_cls.discriminator is not None:\n            possible_classes.extend(get_discriminated_classes(discr_cls))\n        else:\n            possible_classes.append(discr_cls)\n    return possible_classes\n\n\ndef get_possible_classes(cls, from_server_context):\n    # TODO: lru_cache this\n    possible_classes = [cls]\n    if from_server_context:\n        return possible_classes\n    if hasattr(cls, 'discriminator') and cls.discriminator is not None:\n        possible_classes = []\n        possible_classes.extend(get_discriminated_classes(cls))\n    elif issubclass(cls, ModelComposed):\n        possible_classes.extend(composed_model_input_classes(cls))\n    return possible_classes\n\n\ndef get_required_type_classes(required_types_mixed, spec_property_naming):\n    \"\"\"Converts the tuple required_types into a tuple and a dict described\n    below\n\n    Args:\n        required_types_mixed (tuple/list): will contain either classes or\n            instance of list or dict\n        spec_property_naming (bool): if True these values came from the\n            server, and we use the data types in our endpoints.\n            If False, we are client side and we need to include\n            oneOf and discriminator classes inside the data types in our endpoints\n\n    Returns:\n        (valid_classes, dict_valid_class_to_child_types_mixed):\n            valid_classes (tuple): the valid classes that the current item\n                                   should be\n            dict_valid_class_to_child_types_mixed (dict):\n                valid_class (class): this is the key\n                child_types_mixed (list/dict/tuple): describes the valid child\n                    types\n    \"\"\"\n    valid_classes = []\n    child_req_types_by_current_type = {}\n    for required_type in required_types_mixed:\n        if isinstance(required_type, list):\n            valid_classes.append(list)\n            child_req_types_by_current_type[list] = required_type\n        elif isinstance(required_type, tuple):\n            valid_classes.append(tuple)\n            child_req_types_by_current_type[tuple] = required_type\n        elif isinstance(required_type, dict):\n            valid_classes.append(dict)\n            child_req_types_by_current_type[dict] = required_type[str]\n        else:\n            valid_classes.extend(get_possible_classes(required_type, spec_property_naming))\n    return tuple(valid_classes), child_req_types_by_current_type\n\n\ndef change_keys_js_to_python(input_dict, model_class):\n    \"\"\"\n    Converts from javascript_key keys in the input_dict to python_keys in\n    the output dict using the mapping in model_class.\n    If the input_dict contains a key which does not declared in the model_class,\n    the key is added to the output dict as is. The assumption is the model_class\n    may have undeclared properties (additionalProperties attribute in the OAS\n    document).\n    \"\"\"\n\n    if getattr(model_class, 'attribute_map', None) is None:\n        return input_dict\n    output_dict = {}\n    reversed_attr_map = {value: key for key, value in\n                         model_class.attribute_map.items()}\n    for javascript_key, value in input_dict.items():\n        python_key = reversed_attr_map.get(javascript_key)\n        if python_key is None:\n            # if the key is unknown, it is in error or it is an\n            # additionalProperties variable\n            python_key = javascript_key\n        output_dict[python_key] = value\n    return output_dict\n\n\ndef get_type_error(var_value, path_to_item, valid_classes, key_type=False):\n    error_msg = type_error_message(\n        var_name=path_to_item[-1],\n        var_value=var_value,\n        valid_classes=valid_classes,\n        key_type=key_type\n    )\n    return ApiTypeError(\n        error_msg,\n        path_to_item=path_to_item,\n        valid_classes=valid_classes,\n        key_type=key_type\n    )\n\n\ndef deserialize_primitive(data, klass, path_to_item):\n    \"\"\"Deserializes string to primitive type.\n\n    :param data: str/int/float\n    :param klass: str/class the class to convert to\n\n    :return: int, float, str, bool, date, datetime\n    \"\"\"\n    additional_message = \"\"\n    try:\n        if klass in {datetime, date}:\n            additional_message = (\n                \"If you need your parameter to have a fallback \"\n                \"string value, please set its type as `type: {}` in your \"\n                \"spec. That allows the value to be any type. \"\n            )\n            if klass == datetime:\n                if len(data) < 8:\n                    raise ValueError(\"This is not a datetime\")\n                # The string should be in iso8601 datetime format.\n                parsed_datetime = parse(data)\n                date_only = (\n                    parsed_datetime.hour == 0 and\n                    parsed_datetime.minute == 0 and\n                    parsed_datetime.second == 0 and\n                    parsed_datetime.tzinfo is None and\n                    8 <= len(data) <= 10\n                )\n                if date_only:\n                    raise ValueError(\"This is a date, not a datetime\")\n                return parsed_datetime\n            elif klass == date:\n                if len(data) < 8:\n                    raise ValueError(\"This is not a date\")\n                return parse(data).date()\n        else:\n            converted_value = klass(data)\n            if isinstance(data, str) and klass == float:\n                if str(converted_value) != data:\n                    # '7' -> 7.0 -> '7.0' != '7'\n                    raise ValueError('This is not a float')\n            return converted_value\n    except (OverflowError, ValueError) as ex:\n        # parse can raise OverflowError\n        raise ApiValueError(\n            \"{0}Failed to parse {1} as {2}\".format(\n                additional_message, repr(data), klass.__name__\n            ),\n            path_to_item=path_to_item\n        ) from ex\n\n\ndef get_discriminator_class(model_class,\n                            discr_name,\n                            discr_value, cls_visited):\n    \"\"\"Returns the child class specified by the discriminator.\n\n    Args:\n        model_class (OpenApiModel): the model class.\n        discr_name (string): the name of the discriminator property.\n        discr_value (any): the discriminator value.\n        cls_visited (list): list of model classes that have been visited.\n            Used to determine the discriminator class without\n            visiting circular references indefinitely.\n\n    Returns:\n        used_model_class (class/None): the chosen child class that will be used\n            to deserialize the data, for example dog.Dog.\n            If a class is not found, None is returned.\n    \"\"\"\n\n    if model_class in cls_visited:\n        # The class has already been visited and no suitable class was found.\n        return None\n    cls_visited.append(model_class)\n    used_model_class = None\n    if discr_name in model_class.discriminator:\n        class_name_to_discr_class = model_class.discriminator[discr_name]\n        used_model_class = class_name_to_discr_class.get(discr_value)\n    if used_model_class is None:\n        # We didn't find a discriminated class in class_name_to_discr_class.\n        # So look in the ancestor or descendant discriminators\n        # The discriminator mapping may exist in a descendant (anyOf, oneOf)\n        # or ancestor (allOf).\n        # Ancestor example: in the GrandparentAnimal -> ParentPet -> ChildCat\n        #   hierarchy, the discriminator mappings may be defined at any level\n        #   in the hierarchy.\n        # Descendant example:  mammal -> whale/zebra/Pig -> BasquePig/DanishPig\n        #   if we try to make BasquePig from mammal, we need to travel through\n        #   the oneOf descendant discriminators to find BasquePig\n        descendant_classes =  model_class._composed_schemas.get('oneOf', ()) + \\\n            model_class._composed_schemas.get('anyOf', ())\n        ancestor_classes = model_class._composed_schemas.get('allOf', ())\n        possible_classes = descendant_classes + ancestor_classes\n        for cls in possible_classes:\n            # Check if the schema has inherited discriminators.\n            if hasattr(cls, 'discriminator') and cls.discriminator is not None:\n                used_model_class = get_discriminator_class(\n                                    cls, discr_name, discr_value, cls_visited)\n                if used_model_class is not None:\n                    return used_model_class\n    return used_model_class\n\n\ndef deserialize_model(model_data, model_class, path_to_item, check_type,\n                      configuration, spec_property_naming):\n    \"\"\"Deserializes model_data to model instance.\n\n    Args:\n        model_data (int/str/float/bool/none_type/list/dict): data to instantiate the model\n        model_class (OpenApiModel): the model class\n        path_to_item (list): path to the model in the received data\n        check_type (bool): whether to check the data tupe for the values in\n            the model\n        configuration (Configuration): the instance to use to convert files\n        spec_property_naming (bool): True if the variable names in the input\n            data are serialized names as specified in the OpenAPI document.\n            False if the variables names in the input data are python\n            variable names in PEP-8 snake case.\n\n    Returns:\n        model instance\n\n    Raise:\n        ApiTypeError\n        ApiValueError\n        ApiKeyError\n    \"\"\"\n\n    kw_args = dict(_check_type=check_type,\n                   _path_to_item=path_to_item,\n                   _configuration=configuration,\n                   _spec_property_naming=spec_property_naming)\n\n    if issubclass(model_class, ModelSimple):\n        return model_class(model_data, **kw_args)\n    elif isinstance(model_data, list):\n        return model_class(*model_data, **kw_args)\n    if isinstance(model_data, dict):\n        kw_args.update(model_data)\n        return model_class(**kw_args)\n    elif isinstance(model_data, PRIMITIVE_TYPES):\n        return model_class(model_data, **kw_args)\n\n\ndef deserialize_file(response_data, configuration, content_disposition=None):\n    \"\"\"Deserializes body to file\n\n    Saves response body into a file in a temporary folder,\n    using the filename from the `Content-Disposition` header if provided.\n\n    Args:\n        param response_data (str):  the file data to write\n        configuration (Configuration): the instance to use to convert files\n\n    Keyword Args:\n        content_disposition (str):  the value of the Content-Disposition\n            header\n\n    Returns:\n        (file_type): the deserialized file which is open\n            The user is responsible for closing and reading the file\n    \"\"\"\n    fd, path = tempfile.mkstemp(dir=configuration.temp_folder_path)\n    os.close(fd)\n    os.remove(path)\n\n    if content_disposition:\n        filename = re.search(r'filename=[\\'\"]?([^\\'\"\\s]+)[\\'\"]?',\n                             content_disposition).group(1)\n        path = os.path.join(os.path.dirname(path), filename)\n\n    with open(path, \"wb\") as f:\n        if isinstance(response_data, str):\n            # change str to bytes so we can write it\n            response_data = response_data.encode('utf-8')\n        f.write(response_data)\n\n    f = open(path, \"rb\")\n    return f\n\n\ndef attempt_convert_item(input_value, valid_classes, path_to_item,\n                         configuration, spec_property_naming, key_type=False,\n                         must_convert=False, check_type=True):\n    \"\"\"\n    Args:\n        input_value (any): the data to convert\n        valid_classes (any): the classes that are valid\n        path_to_item (list): the path to the item to convert\n        configuration (Configuration): the instance to use to convert files\n        spec_property_naming (bool): True if the variable names in the input\n            data are serialized names as specified in the OpenAPI document.\n            False if the variables names in the input data are python\n            variable names in PEP-8 snake case.\n        key_type (bool): if True we need to convert a key type (not supported)\n        must_convert (bool): if True we must convert\n        check_type (bool): if True we check the type or the returned data in\n            ModelComposed/ModelNormal/ModelSimple instances\n\n    Returns:\n        instance (any) the fixed item\n\n    Raises:\n        ApiTypeError\n        ApiValueError\n        ApiKeyError\n    \"\"\"\n    valid_classes_ordered = order_response_types(valid_classes)\n    valid_classes_coercible = remove_uncoercible(\n        valid_classes_ordered, input_value, spec_property_naming)\n    if not valid_classes_coercible or key_type:\n        # we do not handle keytype errors, json will take care\n        # of this for us\n        if configuration is None or not configuration.discard_unknown_keys:\n            raise get_type_error(input_value, path_to_item, valid_classes,\n                                 key_type=key_type)\n    for valid_class in valid_classes_coercible:\n        try:\n            if issubclass(valid_class, OpenApiModel):\n                return deserialize_model(input_value, valid_class,\n                                         path_to_item, check_type,\n                                         configuration, spec_property_naming)\n            elif valid_class == file_type:\n                return deserialize_file(input_value, configuration)\n            return deserialize_primitive(input_value, valid_class,\n                                         path_to_item)\n        except (ApiTypeError, ApiValueError, ApiKeyError) as conversion_exc:\n            if must_convert:\n                raise conversion_exc\n            # if we have conversion errors when must_convert == False\n            # we ignore the exception and move on to the next class\n            continue\n    # we were unable to convert, must_convert == False\n    return input_value\n\n\ndef is_type_nullable(input_type):\n    \"\"\"\n    Returns true if None is an allowed value for the specified input_type.\n\n    A type is nullable if at least one of the following conditions is true:\n    1. The OAS 'nullable' attribute has been specified,\n    1. The type is the 'null' type,\n    1. The type is a anyOf/oneOf composed schema, and a child schema is\n       the 'null' type.\n    Args:\n        input_type (type): the class of the input_value that we are\n            checking\n    Returns:\n        bool\n    \"\"\"\n    if input_type is none_type:\n        return True\n    if issubclass(input_type, OpenApiModel) and input_type._nullable:\n        return True\n    if issubclass(input_type, ModelComposed):\n        # If oneOf/anyOf, check if the 'null' type is one of the allowed types.\n        for t in input_type._composed_schemas.get('oneOf', ()):\n            if is_type_nullable(t): return True\n        for t in input_type._composed_schemas.get('anyOf', ()):\n            if is_type_nullable(t): return True\n    return False\n\n\ndef is_valid_type(input_class_simple, valid_classes):\n    \"\"\"\n    Args:\n        input_class_simple (class): the class of the input_value that we are\n            checking\n        valid_classes (tuple): the valid classes that the current item\n            should be\n    Returns:\n        bool\n    \"\"\"\n    valid_type = input_class_simple in valid_classes\n    if not valid_type and (\n            issubclass(input_class_simple, OpenApiModel) or\n            input_class_simple is none_type):\n        for valid_class in valid_classes:\n            if input_class_simple is none_type and is_type_nullable(valid_class):\n                # Schema is oneOf/anyOf and the 'null' type is one of the allowed types.\n                return True\n            if not (issubclass(valid_class, OpenApiModel) and valid_class.discriminator):\n                continue\n            discr_propertyname_py = list(valid_class.discriminator.keys())[0]\n            discriminator_classes = (\n                valid_class.discriminator[discr_propertyname_py].values()\n            )\n            valid_type = is_valid_type(input_class_simple, discriminator_classes)\n            if valid_type:\n                return True\n    return valid_type\n\n\ndef validate_and_convert_types(input_value, required_types_mixed, path_to_item,\n                               spec_property_naming, _check_type, configuration=None):\n    \"\"\"Raises a TypeError is there is a problem, otherwise returns value\n\n    Args:\n        input_value (any): the data to validate/convert\n        required_types_mixed (list/dict/tuple): A list of\n            valid classes, or a list tuples of valid classes, or a dict where\n            the value is a tuple of value classes\n        path_to_item: (list) the path to the data being validated\n            this stores a list of keys or indices to get to the data being\n            validated\n        spec_property_naming (bool): True if the variable names in the input\n            data are serialized names as specified in the OpenAPI document.\n            False if the variables names in the input data are python\n            variable names in PEP-8 snake case.\n        _check_type: (boolean) if true, type will be checked and conversion\n            will be attempted.\n        configuration: (Configuration): the configuration class to use\n            when converting file_type items.\n            If passed, conversion will be attempted when possible\n            If not passed, no conversions will be attempted and\n            exceptions will be raised\n\n    Returns:\n        the correctly typed value\n\n    Raises:\n        ApiTypeError\n    \"\"\"\n    results = get_required_type_classes(required_types_mixed, spec_property_naming)\n    valid_classes, child_req_types_by_current_type = results\n\n    input_class_simple = get_simple_class(input_value)\n    valid_type = is_valid_type(input_class_simple, valid_classes)\n    if not valid_type:\n        if configuration:\n            # if input_value is not valid_type try to convert it\n            converted_instance = attempt_convert_item(\n                input_value,\n                valid_classes,\n                path_to_item,\n                configuration,\n                spec_property_naming,\n                key_type=False,\n                must_convert=True,\n                check_type=_check_type\n            )\n            return converted_instance\n        else:\n            raise get_type_error(input_value, path_to_item, valid_classes,\n                                 key_type=False)\n\n    # input_value's type is in valid_classes\n    if len(valid_classes) > 1 and configuration:\n        # there are valid classes which are not the current class\n        valid_classes_coercible = remove_uncoercible(\n            valid_classes, input_value, spec_property_naming, must_convert=False)\n        if valid_classes_coercible:\n            converted_instance = attempt_convert_item(\n                input_value,\n                valid_classes_coercible,\n                path_to_item,\n                configuration,\n                spec_property_naming,\n                key_type=False,\n                must_convert=False,\n                check_type=_check_type\n            )\n            return converted_instance\n\n    if child_req_types_by_current_type == {}:\n        # all types are of the required types and there are no more inner\n        # variables left to look at\n        return input_value\n    inner_required_types = child_req_types_by_current_type.get(\n        type(input_value)\n    )\n    if inner_required_types is None:\n        # for this type, there are not more inner variables left to look at\n        return input_value\n    if isinstance(input_value, list):\n        if input_value == []:\n            # allow an empty list\n            return input_value\n        for index, inner_value in enumerate(input_value):\n            inner_path = list(path_to_item)\n            inner_path.append(index)\n            input_value[index] = validate_and_convert_types(\n                inner_value,\n                inner_required_types,\n                inner_path,\n                spec_property_naming,\n                _check_type,\n                configuration=configuration\n            )\n    elif isinstance(input_value, dict):\n        if input_value == {}:\n            # allow an empty dict\n            return input_value\n        for inner_key, inner_val in input_value.items():\n            inner_path = list(path_to_item)\n            inner_path.append(inner_key)\n            if get_simple_class(inner_key) != str:\n                raise get_type_error(inner_key, inner_path, valid_classes,\n                                     key_type=True)\n            input_value[inner_key] = validate_and_convert_types(\n                inner_val,\n                inner_required_types,\n                inner_path,\n                spec_property_naming,\n                _check_type,\n                configuration=configuration\n            )\n    return input_value\n\n\ndef model_to_dict(model_instance, serialize=True):\n    \"\"\"Returns the model properties as a dict\n\n    Args:\n        model_instance (one of your model instances): the model instance that\n            will be converted to a dict.\n\n    Keyword Args:\n        serialize (bool): if True, the keys in the dict will be values from\n            attribute_map\n    \"\"\"\n    result = {}\n\n    model_instances = [model_instance]\n    if model_instance._composed_schemas:\n        model_instances.extend(model_instance._composed_instances)\n    for model_instance in model_instances:\n        for attr, value in model_instance._data_store.items():\n            if serialize:\n                # we use get here because additional property key names do not\n                # exist in attribute_map\n                attr = model_instance.attribute_map.get(attr, attr)\n            if isinstance(value, list):\n               if not value:\n                   # empty list or None\n                   result[attr] = value\n               else:\n                   res = []\n                   for v in value:\n                       if isinstance(v, PRIMITIVE_TYPES) or v is None:\n                           res.append(v)\n                       elif isinstance(v, ModelSimple):\n                           res.append(v.value)\n                       else:\n                           res.append(model_to_dict(v, serialize=serialize))\n                   result[attr] = res\n            elif isinstance(value, dict):\n                result[attr] = dict(map(\n                    lambda item: (item[0],\n                                  model_to_dict(item[1], serialize=serialize))\n                    if hasattr(item[1], '_data_store') else item,\n                    value.items()\n                ))\n            elif isinstance(value, ModelSimple):\n                result[attr] = value.value\n            elif hasattr(value, '_data_store'):\n                result[attr] = model_to_dict(value, serialize=serialize)\n            else:\n                result[attr] = value\n\n    return result\n\n\ndef type_error_message(var_value=None, var_name=None, valid_classes=None,\n                       key_type=None):\n    \"\"\"\n    Keyword Args:\n        var_value (any): the variable which has the type_error\n        var_name (str): the name of the variable which has the typ error\n        valid_classes (tuple): the accepted classes for current_item's\n                                  value\n        key_type (bool): False if our value is a value in a dict\n                         True if it is a key in a dict\n                         False if our item is an item in a list\n    \"\"\"\n    key_or_value = 'value'\n    if key_type:\n        key_or_value = 'key'\n    valid_classes_phrase = get_valid_classes_phrase(valid_classes)\n    msg = (\n        \"Invalid type for variable '{0}'. Required {1} type {2} and \"\n        \"passed type was {3}\".format(\n            var_name,\n            key_or_value,\n            valid_classes_phrase,\n            type(var_value).__name__,\n        )\n    )\n    return msg\n\n\ndef get_valid_classes_phrase(input_classes):\n    \"\"\"Returns a string phrase describing what types are allowed\n    \"\"\"\n    all_classes = list(input_classes)\n    all_classes = sorted(all_classes, key=lambda cls: cls.__name__)\n    all_class_names = [cls.__name__ for cls in all_classes]\n    if len(all_class_names) == 1:\n        return 'is {0}'.format(all_class_names[0])\n    return \"is one of [{0}]\".format(\", \".join(all_class_names))\n\n\ndef convert_js_args_to_python_args(fn):\n    from functools import wraps\n    @wraps(fn)\n    def wrapped_init(_self, *args, **kwargs):\n        \"\"\"\n        An attribute named `self` received from the api will conflicts with the reserved `self`\n        parameter of a class method. During generation, `self` attributes are mapped\n        to `_self` in models. Here, we name `_self` instead of `self` to avoid conflicts.\n        \"\"\"\n        spec_property_naming = kwargs.get('_spec_property_naming', False)\n        if spec_property_naming:\n            kwargs = change_keys_js_to_python(kwargs, _self.__class__)\n        return fn(_self, *args, **kwargs)\n    return wrapped_init\n\n\ndef get_allof_instances(self, model_args, constant_args):\n    \"\"\"\n    Args:\n        self: the class we are handling\n        model_args (dict): var_name to var_value\n            used to make instances\n        constant_args (dict): var_name to var_value\n            used to make instances\n\n    Returns\n        composed_instances (list)\n    \"\"\"\n    composed_instances = []\n    for allof_class in self._composed_schemas['allOf']:\n\n        # no need to handle changing js keys to python because\n        # for composed schemas, allof parameters are included in the\n        # composed schema and were changed to python keys in __new__\n        # extract a dict of only required keys from fixed_model_args\n        kwargs = {}\n        var_names = set(allof_class.openapi_types.keys())\n        for var_name in var_names:\n            if var_name in model_args:\n                kwargs[var_name] = model_args[var_name]\n\n        # and use it to make the instance\n        kwargs.update(constant_args)\n        try:\n            allof_instance = allof_class(**kwargs)\n            composed_instances.append(allof_instance)\n        except Exception as ex:\n            raise ApiValueError(\n                \"Invalid inputs given to generate an instance of '%s'. The \"\n                \"input data was invalid for the allOf schema '%s' in the composed \"\n                \"schema '%s'. Error=%s\" % (\n                    allof_class.__name__,\n                    allof_class.__name__,\n                    self.__class__.__name__,\n                    str(ex)\n                )\n            ) from ex\n    return composed_instances\n\n\ndef get_oneof_instance(cls, model_kwargs, constant_kwargs, model_arg=None):\n    \"\"\"\n    Find the oneOf schema that matches the input data (e.g. payload).\n    If exactly one schema matches the input data, an instance of that schema\n    is returned.\n    If zero or more than one schema match the input data, an exception is raised.\n    In OAS 3.x, the payload MUST, by validation, match exactly one of the\n    schemas described by oneOf.\n\n    Args:\n        cls: the class we are handling\n        model_kwargs (dict): var_name to var_value\n            The input data, e.g. the payload that must match a oneOf schema\n            in the OpenAPI document.\n        constant_kwargs (dict): var_name to var_value\n            args that every model requires, including configuration, server\n            and path to item.\n\n    Kwargs:\n        model_arg: (int, float, bool, str, date, datetime, ModelSimple, None):\n            the value to assign to a primitive class or ModelSimple class\n            Notes:\n            - this is only passed in when oneOf includes types which are not object\n            - None is used to suppress handling of model_arg, nullable models are handled in __new__\n\n    Returns\n        oneof_instance (instance)\n    \"\"\"\n    if len(cls._composed_schemas['oneOf']) == 0:\n        return None\n\n    oneof_instances = []\n    # Iterate over each oneOf schema and determine if the input data\n    # matches the oneOf schemas.\n    for oneof_class in cls._composed_schemas['oneOf']:\n        # The composed oneOf schema allows the 'null' type and the input data\n        # is the null value. This is a OAS >= 3.1 feature.\n        if oneof_class is none_type:\n            # skip none_types because we are deserializing dict data.\n            # none_type deserialization is handled in the __new__ method\n            continue\n\n        single_value_input = allows_single_value_input(oneof_class)\n\n        if not single_value_input:\n            # transform js keys from input data to python keys in fixed_model_args\n            fixed_model_args = change_keys_js_to_python(\n                model_kwargs, oneof_class)\n\n            # Extract a dict with the properties that are declared in the oneOf schema.\n            # Undeclared properties (e.g. properties that are allowed because of the\n            # additionalProperties attribute in the OAS document) are not added to\n            # the dict.\n            kwargs = {}\n            var_names = set(oneof_class.openapi_types.keys())\n            for var_name in var_names:\n                if var_name in fixed_model_args:\n                    kwargs[var_name] = fixed_model_args[var_name]\n\n            # do not try to make a model with no input args\n            if len(kwargs) == 0:\n                continue\n\n            # and use it to make the instance\n            kwargs.update(constant_kwargs)\n\n        try:\n            if not single_value_input:\n                oneof_instance = oneof_class(**kwargs)\n            else:\n                if issubclass(oneof_class, ModelSimple):\n                    oneof_instance = oneof_class(model_arg, **constant_kwargs)\n                elif oneof_class in PRIMITIVE_TYPES:\n                    oneof_instance = validate_and_convert_types(\n                        model_arg,\n                        (oneof_class,),\n                        constant_kwargs['_path_to_item'],\n                        constant_kwargs['_spec_property_naming'],\n                        constant_kwargs['_check_type'],\n                        configuration=constant_kwargs['_configuration']\n                    )\n            oneof_instances.append(oneof_instance)\n        except Exception:\n            pass\n    if len(oneof_instances) == 0:\n        raise ApiValueError(\n            \"Invalid inputs given to generate an instance of %s. None \"\n            \"of the oneOf schemas matched the input data.\" %\n            cls.__name__\n        )\n    elif len(oneof_instances) > 1:\n        raise ApiValueError(\n            \"Invalid inputs given to generate an instance of %s. Multiple \"\n            \"oneOf schemas matched the inputs, but a max of one is allowed.\" %\n            cls.__name__\n        )\n    return oneof_instances[0]\n\n\ndef get_anyof_instances(self, model_args, constant_args):\n    \"\"\"\n    Args:\n        self: the class we are handling\n        model_args (dict): var_name to var_value\n            The input data, e.g. the payload that must match at least one\n            anyOf child schema in the OpenAPI document.\n        constant_args (dict): var_name to var_value\n            args that every model requires, including configuration, server\n            and path to item.\n\n    Returns\n        anyof_instances (list)\n    \"\"\"\n    anyof_instances = []\n    if len(self._composed_schemas['anyOf']) == 0:\n        return anyof_instances\n\n    for anyof_class in self._composed_schemas['anyOf']:\n        # The composed oneOf schema allows the 'null' type and the input data\n        # is the null value. This is a OAS >= 3.1 feature.\n        if anyof_class is none_type:\n            # skip none_types because we are deserializing dict data.\n            # none_type deserialization is handled in the __new__ method\n            continue\n\n        # transform js keys to python keys in fixed_model_args\n        fixed_model_args = change_keys_js_to_python(model_args, anyof_class)\n\n        # extract a dict of only required keys from these_model_vars\n        kwargs = {}\n        var_names = set(anyof_class.openapi_types.keys())\n        for var_name in var_names:\n            if var_name in fixed_model_args:\n                kwargs[var_name] = fixed_model_args[var_name]\n\n        # do not try to make a model with no input args\n        if len(kwargs) == 0:\n            continue\n\n        # and use it to make the instance\n        kwargs.update(constant_args)\n        try:\n            anyof_instance = anyof_class(**kwargs)\n            anyof_instances.append(anyof_instance)\n        except Exception:\n            pass\n    if len(anyof_instances) == 0:\n        raise ApiValueError(\n            \"Invalid inputs given to generate an instance of %s. None of the \"\n            \"anyOf schemas matched the inputs.\" %\n            self.__class__.__name__\n        )\n    return anyof_instances\n\n\ndef get_additional_properties_model_instances(\n        composed_instances, self):\n    additional_properties_model_instances = []\n    all_instances = [self]\n    all_instances.extend(composed_instances)\n    for instance in all_instances:\n        if instance.additional_properties_type is not None:\n            additional_properties_model_instances.append(instance)\n    return additional_properties_model_instances\n\n\ndef get_var_name_to_model_instances(self, composed_instances):\n    var_name_to_model_instances = {}\n    all_instances = [self]\n    all_instances.extend(composed_instances)\n    for instance in all_instances:\n        for var_name in instance.openapi_types:\n            if var_name not in var_name_to_model_instances:\n                var_name_to_model_instances[var_name] = [instance]\n            else:\n                var_name_to_model_instances[var_name].append(instance)\n    return var_name_to_model_instances\n\n\ndef get_unused_args(self, composed_instances, model_args):\n    unused_args = dict(model_args)\n    # arguments apssed to self were already converted to python names\n    # before __init__ was called\n    for var_name_py in self.attribute_map:\n        if var_name_py in unused_args:\n            del unused_args[var_name_py]\n    for instance in composed_instances:\n        if instance.__class__ in self._composed_schemas['allOf']:\n            for var_name_py in instance.attribute_map:\n                if var_name_py in unused_args:\n                    del unused_args[var_name_py]\n        else:\n            for var_name_js in instance.attribute_map.values():\n                if var_name_js in unused_args:\n                    del unused_args[var_name_js]\n    return unused_args\n\n\ndef validate_get_composed_info(constant_args, model_args, self):\n    \"\"\"\n    For composed schemas, generate schema instances for\n    all schemas in the oneOf/anyOf/allOf definition. If additional\n    properties are allowed, also assign those properties on\n    all matched schemas that contain additionalProperties.\n    Openapi schemas are python classes.\n\n    Exceptions are raised if:\n    - 0 or > 1 oneOf schema matches the model_args input data\n    - no anyOf schema matches the model_args input data\n    - any of the allOf schemas do not match the model_args input data\n\n    Args:\n        constant_args (dict): these are the args that every model requires\n        model_args (dict): these are the required and optional spec args that\n            were passed in to make this model\n        self (class): the class that we are instantiating\n            This class contains self._composed_schemas\n\n    Returns:\n        composed_info (list): length three\n            composed_instances (list): the composed instances which are not\n                self\n            var_name_to_model_instances (dict): a dict going from var_name\n                to the model_instance which holds that var_name\n                the model_instance may be self or an instance of one of the\n                classes in self.composed_instances()\n            additional_properties_model_instances (list): a list of the\n                model instances which have the property\n                additional_properties_type. This list can include self\n    \"\"\"\n    # create composed_instances\n    composed_instances = []\n    allof_instances = get_allof_instances(self, model_args, constant_args)\n    composed_instances.extend(allof_instances)\n    oneof_instance = get_oneof_instance(self.__class__, model_args, constant_args)\n    if oneof_instance is not None:\n        composed_instances.append(oneof_instance)\n    anyof_instances = get_anyof_instances(self, model_args, constant_args)\n    composed_instances.extend(anyof_instances)\n\n    # map variable names to composed_instances\n    var_name_to_model_instances = get_var_name_to_model_instances(\n        self, composed_instances)\n\n    # set additional_properties_model_instances\n    additional_properties_model_instances = (\n        get_additional_properties_model_instances(composed_instances, self)\n    )\n\n    # set any remaining values\n    unused_args = get_unused_args(self, composed_instances, model_args)\n    if len(unused_args) > 0 and \\\n            len(additional_properties_model_instances) == 0 and \\\n            (self._configuration is None or\n                not self._configuration.discard_unknown_keys):\n        raise ApiValueError(\n            \"Invalid input arguments input when making an instance of \"\n            \"class %s. Not all inputs were used. The unused input data \"\n            \"is %s\" % (self.__class__.__name__, unused_args)\n        )\n\n    # no need to add additional_properties to var_name_to_model_instances here\n    # because additional_properties_model_instances will direct us to that\n    # instance when we use getattr or setattr\n    # and we update var_name_to_model_instances in setattr\n\n    return [\n      composed_instances,\n      var_name_to_model_instances,\n      additional_properties_model_instances,\n      unused_args\n    ]\n",
  "output": {
    "before": "\"\"\"\n    OpenAPI Petstore\n\n    This spec is mainly for testing Petstore server and contains fake endpoints, models. Please do not use this for any other purpose. Special characters: \\\" \\\\  # noqa: E501\n\n    The version of the OpenAPI document: 1.0.0\n    Generated by: https://openapi-generator.tech\n\"\"\"\n\n\nfrom datetime import date, datetime  # noqa: F401\nimport inspect\nimport io\nimport os\nimport pprint\nimport re\nimport tempfile\n\nfrom dateutil.parser import parse\n\nfrom petstore_api.exceptions import (\n    ApiKeyError,\n    ApiAttributeError,\n    ApiTypeError,\n    ApiValueError,\n)\n\nnone_type = type(None)\nfile_type = io.IOBase\n\n\nclass cached_property(object):\n    # this caches the result of the function call for fn with no inputs\n    # use this as a decorator on fuction methods that you want converted\n    # into cached properties\n    result_key = '_results'\n\n    def __init__(self, fn):\n        self._fn = fn\n\n    def __get__(self, instance, cls=None):\n        if self.result_key in vars(self):\n            return vars(self)[self.result_key]\n        else:\n            result = self._fn()\n            setattr(self, self.result_key, result)\n            return result\n\n\nPRIMITIVE_TYPES = (list, float, int, bool, datetime, date, str, file_type)\n\ndef allows_single_value_input(cls):\n    \"\"\"\n    This function returns True if the input composed schema model or any\n    descendant model allows a value only input\n    This is true for cases where oneOf contains items like:\n    oneOf:\n      - float\n      - NumberWithValidation\n      - StringEnum\n      - ArrayModel\n      - null\n    TODO: lru_cache this\n    \"\"\"\n    if (\n        issubclass(cls, ModelSimple) or\n        cls in PRIMITIVE_TYPES\n    ):\n        return True\n    elif issubclass(cls, ModelComposed):\n        if not cls._composed_schemas['oneOf']:\n            return False\n        return any(allows_single_value_input(c) for c in cls._composed_schemas['oneOf'])\n    return False\n\ndef composed_model_input_classes(cls):\n    \"\"\"\n    This function returns a list of the possible models that can be accepted as\n    inputs.\n    TODO: lru_cache this\n    \"\"\"\n    if issubclass(cls, ModelSimple) or cls in PRIMITIVE_TYPES:\n        return [cls]\n    elif issubclass(cls, ModelNormal):\n        if cls.discriminator is None:\n            return [cls]\n        else:\n            return get_discriminated_classes(cls)\n    elif issubclass(cls, ModelComposed):\n        if not cls._composed_schemas['oneOf']:\n            return []\n        if cls.discriminator is None:\n            input_classes = []\n            for c in cls._composed_schemas['oneOf']:\n                input_classes.extend(composed_model_input_classes(c))\n            return input_classes\n        else:\n            return get_discriminated_classes(cls)\n    return []\n\n\nclass OpenApiModel(object):\n    \"\"\"The base class for all OpenAPIModels\"\"\"\n\n    def set_attribute(self, name, value):\n        # this is only used to set properties on self\n\n        path_to_item = []\n        if self._path_to_item:\n            path_to_item.extend(self._path_to_item)\n        path_to_item.append(name)\n\n        if name in self.openapi_types:\n            required_types_mixed = self.openapi_types[name]\n        elif self.additional_properties_type is None:\n            raise ApiAttributeError(\n                \"{0} has no attribute '{1}'\".format(\n                    type(self).__name__, name),\n                path_to_item\n            )\n        elif self.additional_properties_type is not None:\n            required_types_mixed = self.additional_properties_type\n\n        if get_simple_class(name) != str:\n            error_msg = type_error_message(\n                var_name=name,\n                var_value=name,\n                valid_classes=(str,),\n                key_type=True\n            )\n            raise ApiTypeError(\n                error_msg,\n                path_to_item=path_to_item,\n                valid_classes=(str,),\n                key_type=True\n            )\n\n        if self._check_type:\n            value = validate_and_convert_types(\n                value, required_types_mixed, path_to_item, self._spec_property_naming,\n                self._check_type, configuration=self._configuration)\n        if (name,) in self.allowed_values:\n            check_allowed_values(\n                self.allowed_values,\n                (name,),\n                value\n            )\n        if (name,) in self.validations:\n            check_validations(\n                self.validations,\n                (name,),\n                value,\n                self._configuration\n            )\n        self.__dict__['_data_store'][name] = value\n\n    def __repr__(self):\n        \"\"\"For `print` and `pprint`\"\"\"\n        return self.to_str()\n\n    def __ne__(self, other):\n        \"\"\"Returns true if both objects are not equal\"\"\"\n        return not self == other\n\n    def __setattr__(self, attr, value):\n        \"\"\"set the value of an attribute using dot notation: `instance.attr = val`\"\"\"\n        self[attr] = value\n\n    def __getattr__(self, attr):\n        \"\"\"get the value of an attribute using dot notation: `instance.attr`\"\"\"\n        return self.__getitem__(attr)\n\n    def __new__(cls, *args, **kwargs):\n        # this function uses the discriminator to\n        # pick a new schema/class to instantiate because a discriminator\n        # propertyName value was passed in\n\n        if len(args) == 1:\n            arg = args[0]\n            if arg is None and is_type_nullable(cls):\n                # The input data is the 'null' value and the type is nullable.\n                return None\n\n            if issubclass(cls, ModelComposed) and allows_single_value_input(cls):\n                model_kwargs = {}\n                oneof_instance = get_oneof_instance(cls, model_kwargs, kwargs, model_arg=arg)\n                return oneof_instance\n\n\n        visited_composed_classes = kwargs.get('_visited_composed_classes', ())\n        if (\n            cls.discriminator is None or\n            cls in visited_composed_classes\n        ):\n            # Use case 1: this openapi schema (cls) does not have a discriminator\n            # Use case 2: we have already visited this class before and are sure that we\n            # want to instantiate it this time. We have visited this class deserializing\n            # a payload with a discriminator. During that process we traveled through\n            # this class but did not make an instance of it. Now we are making an\n            # instance of a composed class which contains cls in it, so this time make an instance of cls.\n            #\n            # Here's an example of use case 2: If Animal has a discriminator\n            # petType and we pass in \"Dog\", and the class Dog\n            # allOf includes Animal, we move through Animal\n            # once using the discriminator, and pick Dog.\n            # Then in the composed schema dog Dog, we will make an instance of the\n            # Animal class (because Dal has allOf: Animal) but this time we won't travel\n            # through Animal's discriminator because we passed in\n            # _visited_composed_classes = (Animal,)\n\n            return super(OpenApiModel, cls).__new__(cls)\n\n        # Get the name and value of the discriminator property.\n        # The discriminator name is obtained from the discriminator meta-data\n        # and the discriminator value is obtained from the input data.\n        discr_propertyname_py = list(cls.discriminator.keys())[0]\n        discr_propertyname_js = cls.attribute_map[discr_propertyname_py]\n        if discr_propertyname_js in kwargs:\n            discr_value = kwargs[discr_propertyname_js]\n        elif discr_propertyname_py in kwargs:\n            discr_value = kwargs[discr_propertyname_py]\n        else:\n            # The input data does not contain the discriminator property.\n            path_to_item = kwargs.get('_path_to_item', ())\n            raise ApiValueError(\n                \"Cannot deserialize input data due to missing discriminator. \"\n                \"The discriminator property '%s' is missing at path: %s\" %\n                (discr_propertyname_js, path_to_item)\n            )\n\n        # Implementation note: the last argument to get_discriminator_class\n        # is a list of visited classes. get_discriminator_class may recursively\n        # call itself and update the list of visited classes, and the initial\n        # value must be an empty list. Hence not using 'visited_composed_classes'\n        new_cls = get_discriminator_class(\n                    cls, discr_propertyname_py, discr_value, [])\n        if new_cls is None:\n            path_to_item = kwargs.get('_path_to_item', ())\n            disc_prop_value = kwargs.get(\n                discr_propertyname_js, kwargs.get(discr_propertyname_py))\n            raise ApiValueError(\n                \"Cannot deserialize input data due to invalid discriminator \"\n                \"value. The OpenAPI document has no mapping for discriminator \"\n                \"property '%s'='%s' at path: %s\" %\n                (discr_propertyname_js, disc_prop_value, path_to_item)\n            )\n\n        if new_cls in visited_composed_classes:\n            # if we are making an instance of a composed schema Descendent\n            # which allOf includes Ancestor, then Ancestor contains\n            # a discriminator that includes Descendent.\n            # So if we make an instance of Descendent, we have to make an\n            # instance of Ancestor to hold the allOf properties.\n            # This code detects that use case and makes the instance of Ancestor\n            # For example:\n            # When making an instance of Dog, _visited_composed_classes = (Dog,)\n            # then we make an instance of Animal to include in dog._composed_instances\n            # so when we are here, cls is Animal\n            # cls.discriminator != None\n            # cls not in _visited_composed_classes\n            # new_cls = Dog\n            # but we know we know that we already have Dog\n            # because it is in visited_composed_classes\n            # so make Animal here\n            return super(OpenApiModel, cls).__new__(cls)\n\n        # Build a list containing all oneOf and anyOf descendants.\n        oneof_anyof_classes = None\n        if cls._composed_schemas is not None:\n            oneof_anyof_classes = (\n                cls._composed_schemas.get('oneOf', ()) +\n                cls._composed_schemas.get('anyOf', ()))\n        oneof_anyof_child = new_cls in oneof_anyof_classes\n        kwargs['_visited_composed_classes'] = visited_composed_classes + (cls,)\n\n        if cls._composed_schemas.get('allOf') and oneof_anyof_child:\n            # Validate that we can make self because when we make the\n            # new_cls it will not include the allOf validations in self\n            self_inst = super(OpenApiModel, cls).__new__(cls)\n            self_inst.__init__(*args, **kwargs)\n\n        new_inst = new_cls.__new__(new_cls, *args, **kwargs)\n        new_inst.__init__(*args, **kwargs)\n        return new_inst\n\n\nclass ModelSimple(OpenApiModel):\n    \"\"\"the parent class of models whose type != object in their\n    swagger/openapi\"\"\"\n\n    def __setitem__(self, name, value):\n        \"\"\"set the value of an attribute using square-bracket notation: `instance[attr] = val`\"\"\"\n        if name in self.required_properties:\n            self.__dict__[name] = value\n            return\n\n        self.set_attribute(name, value)\n\n    def get(self, name, default=None):\n        \"\"\"returns the value of an attribute or some default value if the attribute was not set\"\"\"\n        if name in self.required_properties:\n            return self.__dict__[name]\n\n        return self.__dict__['_data_store'].get(name, default)\n\n    def __getitem__(self, name):\n        \"\"\"get the value of an attribute using square-bracket notation: `instance[attr]`\"\"\"\n        if name in self:\n            return self.get(name)\n\n        raise ApiAttributeError(\n            \"{0} has no attribute '{1}'\".format(\n                type(self).__name__, name),\n            [e for e in [self._path_to_item, name] if e]\n        )\n\n    def __contains__(self, name):\n        \"\"\"used by `in` operator to check if an attrbute value was set in an instance: `'attr' in instance`\"\"\"\n        if name in self.required_properties:\n            return name in self.__dict__\n\n        return name in self.__dict__['_data_store']\n\n    def to_str(self):\n        \"\"\"Returns the string representation of the model\"\"\"\n        return str(self.value)\n\n    def __eq__(self, other):\n        \"\"\"Returns true if both objects are equal\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n\n        this_val = self._data_store['value']\n        that_val = other._data_store['value']\n        types = set()\n        types.add(this_val.__class__)\n        types.add(that_val.__class__)\n        vals_equal = this_val == that_val\n        return vals_equal\n\n\nclass ModelNormal(OpenApiModel):\n    \"\"\"the parent class of models whose type == object in their\n    swagger/openapi\"\"\"\n\n    def __setitem__(self, name, value):\n        \"\"\"set the value of an attribute using square-bracket notation: `instance[attr] = val`\"\"\"\n        if name in self.required_properties:\n            self.__dict__[name] = value\n            return\n\n        self.set_attribute(name, value)\n\n    def get(self, name, default=None):\n        \"\"\"returns the value of an attribute or some default value if the attribute was not set\"\"\"\n        if name in self.required_properties:\n            return self.__dict__[name]\n\n        return self.__dict__['_data_store'].get(name, default)\n\n    def __getitem__(self, name):\n        \"\"\"get the value of an attribute using square-bracket notation: `instance[attr]`\"\"\"\n        if name in self:\n            return self.get(name)\n\n        raise ApiAttributeError(\n            \"{0} has no attribute '{1}'\".format(\n                type(self).__name__, name),\n            [e for e in [self._path_to_item, name] if e]\n        )\n\n    def __contains__(self, name):\n        \"\"\"used by `in` operator to check if an attrbute value was set in an instance: `'attr' in instance`\"\"\"\n        if name in self.required_properties:\n            return name in self.__dict__\n\n        return name in self.__dict__['_data_store']\n\n    def to_dict(self):\n        \"\"\"Returns the model properties as a dict\"\"\"\n        return model_to_dict(self, serialize=False)\n\n    def to_str(self):\n        \"\"\"Returns the string representation of the model\"\"\"\n        return pprint.pformat(self.to_dict())\n\n    def __eq__(self, other):\n        \"\"\"Returns true if both objects are equal\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n\n        if not set(self._data_store.keys()) == set(other._data_store.keys()):\n            return False\n        for _var_name, this_val in self._data_store.items():\n            that_val = other._data_store[_var_name]\n            types = set()\n            types.add(this_val.__class__)\n            types.add(that_val.__class__)\n            vals_equal = this_val == that_val\n            if not vals_equal:\n                return False\n        return True\n\n\nclass ModelComposed(OpenApiModel):\n    \"\"\"the parent class of models whose type == object in their\n    swagger/openapi and have oneOf/allOf/anyOf\n\n    When one sets a property we use var_name_to_model_instances to store the value in\n    the correct class instances + run any type checking + validation code.\n    When one gets a property we use var_name_to_model_instances to get the value\n    from the correct class instances.\n    This allows multiple composed schemas to contain the same property with additive\n    constraints on the value.\n\n    _composed_schemas (dict) stores the anyOf/allOf/oneOf classes\n    key (str): allOf/oneOf/anyOf\n    value (list): the classes in the XOf definition.\n        Note: none_type can be included when the openapi document version >= 3.1.0\n    _composed_instances (list): stores a list of instances of the composed schemas\n    defined in _composed_schemas. When properties are accessed in the self instance,\n    they are returned from the self._data_store or the data stores in the instances\n    in self._composed_schemas\n    _var_name_to_model_instances (dict): maps between a variable name on self and\n    the composed instances (self included) which contain that data\n    key (str): property name\n    value (list): list of class instances, self or instances in _composed_instances\n    which contain the value that the key is referring to.\n    \"\"\"\n\n    def __setitem__(self, name, value):\n        \"\"\"set the value of an attribute using square-bracket notation: `instance[attr] = val`\"\"\"\n        if name in self.required_properties:\n            self.__dict__[name] = value\n            return\n\n        # set the attribute on the correct instance\n        model_instances = self._var_name_to_model_instances.get(\n            name, self._additional_properties_model_instances)\n        if model_instances:\n            for model_instance in model_instances:\n                if model_instance == self:\n                    self.set_attribute(name, value)\n                else:\n                    setattr(model_instance, name, value)\n                if name not in self._var_name_to_model_instances:\n                    # we assigned an additional property\n                    self.__dict__['_var_name_to_model_instances'][name] = (\n                        model_instance\n                    )\n            return None\n\n        raise ApiAttributeError(\n            \"{0} has no attribute '{1}'\".format(\n                type(self).__name__, name),\n            [e for e in [self._path_to_item, name] if e]\n        )\n\n    __unset_attribute_value__ = object()\n\n    def get(self, name, default=None):\n        \"\"\"returns the value of an attribute or some default value if the attribute was not set\"\"\"\n        if name in self.required_properties:\n            return self.__dict__[name]\n\n        # get the attribute from the correct instance\n        model_instances = self._var_name_to_model_instances.get(\n            name, self._additional_properties_model_instances)\n        values = []\n        # A composed model stores child (oneof/anyOf/allOf) models under\n        # self._var_name_to_model_instances. A named property can exist in\n        # multiple child models. If the property is present in more than one\n        # child model, the value must be the same across all the child models.\n        if model_instances:\n            for model_instance in model_instances:\n                if name in model_instance._data_store:\n                    v = model_instance._data_store[name]\n                    if v not in values:\n                        values.append(v)\n        len_values = len(values)\n        if len_values == 0:\n            return default\n        elif len_values == 1:\n            return values[0]\n        elif len_values > 1:\n            raise ApiValueError(\n                \"Values stored for property {0} in {1} differ when looking \"\n                \"at self and self's composed instances. All values must be \"\n                \"the same\".format(name, type(self).__name__),\n                [e for e in [self._path_to_item, name] if e]\n            )\n\n    def __getitem__(self, name):\n        \"\"\"get the value of an attribute using square-bracket notation: `instance[attr]`\"\"\"\n        value = self.get(name, self.__unset_attribute_value__)\n        if value is self.__unset_attribute_value__:\n            raise ApiAttributeError(\n                \"{0} has no attribute '{1}'\".format(\n                    type(self).__name__, name),\n                    [e for e in [self._path_to_item, name] if e]\n            )\n        return value\n\n    def __contains__(self, name):\n        \"\"\"used by `in` operator to check if an attrbute value was set in an instance: `'attr' in instance`\"\"\"\n\n        if name in self.required_properties:\n            return name in self.__dict__\n\n        model_instances = self._var_name_to_model_instances.get(\n            name, self._additional_properties_model_instances)\n\n        if model_instances:\n            for model_instance in model_instances:\n                if name in model_instance._data_store:\n                    return True\n\n        return False\n\n    def to_dict(self):\n        \"\"\"Returns the model properties as a dict\"\"\"\n        return model_to_dict(self, serialize=False)\n\n    def to_str(self):\n        \"\"\"Returns the string representation of the model\"\"\"\n        return pprint.pformat(self.to_dict())\n\n    def __eq__(self, other):\n        \"\"\"Returns true if both objects are equal\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n\n        if not set(self._data_store.keys()) == set(other._data_store.keys()):\n            return False\n        for _var_name, this_val in self._data_store.items():\n            that_val = other._data_store[_var_name]\n            types = set()\n            types.add(this_val.__class__)\n            types.add(that_val.__class__)\n            vals_equal = this_val == that_val\n            if not vals_equal:\n                return False\n        return True\n\n\nCOERCION_INDEX_BY_TYPE = {\n    ModelComposed: 0,\n    ModelNormal: 1,\n    ModelSimple: 2,\n    none_type: 3,    # The type of 'None'.\n    list: 4,\n    dict: 5,\n    float: 6,\n    int: 7,\n    bool: 8,\n    datetime: 9,\n    date: 10,\n    str: 11,\n    file_type: 12,   # 'file_type' is an alias for the built-in 'file' or 'io.IOBase' type.\n}\n\n# these are used to limit what type conversions we try to do\n# when we have a valid type already and we want to try converting\n# to another type\nUPCONVERSION_TYPE_PAIRS = (\n    (str, datetime),\n    (str, date),\n    (int, float),             # A float may be serialized as an integer, e.g. '3' is a valid serialized float.\n    (list, ModelComposed),\n    (dict, ModelComposed),\n    (str, ModelComposed),\n    (int, ModelComposed),\n    (float, ModelComposed),\n    (list, ModelComposed),\n    (list, ModelNormal),\n    (dict, ModelNormal),\n    (str, ModelSimple),\n    (int, ModelSimple),\n    (float, ModelSimple),\n    (list, ModelSimple),\n)\n\nCOERCIBLE_TYPE_PAIRS = {\n    False: (  # client instantiation of a model with client data\n        # (dict, ModelComposed),\n        # (list, ModelComposed),\n        # (dict, ModelNormal),\n        # (list, ModelNormal),\n        # (str, ModelSimple),\n        # (int, ModelSimple),\n        # (float, ModelSimple),\n        # (list, ModelSimple),\n        # (str, int),\n        # (str, float),\n        # (str, datetime),\n        # (str, date),\n        # (int, str),\n        # (float, str),\n    ),\n    True: (  # server -> client data\n        (dict, ModelComposed),\n        (list, ModelComposed),\n        (dict, ModelNormal),\n        (list, ModelNormal),\n        (str, ModelSimple),\n        (int, ModelSimple),\n        (float, ModelSimple),\n        (list, ModelSimple),\n        # (str, int),\n        # (str, float),\n        (str, datetime),\n        (str, date),\n        # (int, str),\n        # (float, str),\n        (str, file_type)\n    ),\n}\n\n\ndef get_simple_class(input_value):\n    \"\"\"Returns an input_value's simple class that we will use for type checking\n    Python2:\n    float and int will return int, where int is the python3 int backport\n    str and unicode will return str, where str is the python3 str backport\n    Note: float and int ARE both instances of int backport\n    Note: str_py2 and unicode_py2 are NOT both instances of str backport\n\n    Args:\n        input_value (class/class_instance): the item for which we will return\n                                            the simple class\n    \"\"\"\n    if isinstance(input_value, type):\n        # input_value is a class\n        return input_value\n    elif isinstance(input_value, tuple):\n        return tuple\n    elif isinstance(input_value, list):\n        return list\n    elif isinstance(input_value, dict):\n        return dict\n    elif isinstance(input_value, none_type):\n        return none_type\n    elif isinstance(input_value, file_type):\n        return file_type\n    elif isinstance(input_value, bool):\n        # this must be higher than the int check because\n        # isinstance(True, int) == True\n        return bool\n    elif isinstance(input_value, int):\n        return int\n    elif isinstance(input_value, datetime):\n        # this must be higher than the date check because\n        # isinstance(datetime_instance, date) == True\n        return datetime\n    elif isinstance(input_value, date):\n        return date\n    elif isinstance(input_value, str):\n        return str\n    return type(input_value)\n\n\ndef check_allowed_values(allowed_values, input_variable_path, input_values):\n    \"\"\"Raises an exception if the input_values are not allowed\n\n    Args:\n        allowed_values (dict): the allowed_values dict\n        input_variable_path (tuple): the path to the input variable\n        input_values (list/str/int/float/date/datetime): the values that we\n            are checking to see if they are in allowed_values\n    \"\"\"\n    these_allowed_values = list(allowed_values[input_variable_path].values())\n    if (isinstance(input_values, list)\n            and not set(input_values).issubset(\n                set(these_allowed_values))):\n        invalid_values = \", \".join(\n            map(str, set(input_values) - set(these_allowed_values))),\n        raise ApiValueError(\n            \"Invalid values for `%s` [%s], must be a subset of [%s]\" %\n            (\n                input_variable_path[0],\n                invalid_values,\n                \", \".join(map(str, these_allowed_values))\n            )\n        )\n    elif (isinstance(input_values, dict)\n            and not set(\n                input_values.keys()).issubset(set(these_allowed_values))):\n        invalid_values = \", \".join(\n            map(str, set(input_values.keys()) - set(these_allowed_values)))\n        raise ApiValueError(\n            \"Invalid keys in `%s` [%s], must be a subset of [%s]\" %\n            (\n                input_variable_path[0],\n                invalid_values,\n                \", \".join(map(str, these_allowed_values))\n            )\n        )\n    elif (not isinstance(input_values, (list, dict))\n            and input_values not in these_allowed_values):\n        raise ApiValueError(\n            \"Invalid value for `%s` (%s), must be one of %s\" %\n            (\n                input_variable_path[0],\n                input_values,\n                these_allowed_values\n            )\n        )\n\n\ndef is_json_validation_enabled(schema_keyword, configuration=None):\n    \"\"\"Returns true if JSON schema validation is enabled for the specified\n    validation keyword. This can be used to skip JSON schema structural validation\n    as requested in the configuration.\n\n    Args:\n        schema_keyword (string): the name of a JSON schema validation keyword.\n        configuration (Configuration): the configuration class.\n    \"\"\"\n\n    return (configuration is None or\n        not hasattr(configuration, '_disabled_client_side_validations') or\n        schema_keyword not in configuration._disabled_client_side_validations)\n\n\ndef check_validations(\n        validations, input_variable_path, input_values,\n        configuration=None):\n    \"\"\"Raises an exception if the input_values are invalid\n\n    Args:\n        validations (dict): the validation dictionary.\n        input_variable_path (tuple): the path to the input variable.\n        input_values (list/str/int/float/date/datetime): the values that we\n            are checking.\n        configuration (Configuration): the configuration class.\n    \"\"\"\n\n    if input_values is None:\n        return\n\n    current_validations = validations[input_variable_path]\n    if (is_json_validation_enabled('multipleOf', configuration) and\n            'multiple_of' in current_validations and\n            isinstance(input_values, (int, float)) and\n            not (float(input_values) / current_validations['multiple_of']).is_integer()):\n        # Note 'multipleOf' will be as good as the floating point arithmetic.\n        raise ApiValueError(\n            \"Invalid value for `%s`, value must be a multiple of \"\n            \"`%s`\" % (\n                input_variable_path[0],\n                current_validations['multiple_of']\n            )\n        )\n\n    if (is_json_validation_enabled('maxLength', configuration) and\n            'max_length' in current_validations and\n            len(input_values) > current_validations['max_length']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, length must be less than or equal to \"\n            \"`%s`\" % (\n                input_variable_path[0],\n                current_validations['max_length']\n            )\n        )\n\n    if (is_json_validation_enabled('minLength', configuration) and\n            'min_length' in current_validations and\n            len(input_values) < current_validations['min_length']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, length must be greater than or equal to \"\n            \"`%s`\" % (\n                input_variable_path[0],\n                current_validations['min_length']\n            )\n        )\n\n    if (is_json_validation_enabled('maxItems', configuration) and\n            'max_items' in current_validations and\n            len(input_values) > current_validations['max_items']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, number of items must be less than or \"\n            \"equal to `%s`\" % (\n                input_variable_path[0],\n                current_validations['max_items']\n            )\n        )\n\n    if (is_json_validation_enabled('minItems', configuration) and\n            'min_items' in current_validations and\n            len(input_values) < current_validations['min_items']):\n        raise ValueError(\n            \"Invalid value for `%s`, number of items must be greater than or \"\n            \"equal to `%s`\" % (\n                input_variable_path[0],\n                current_validations['min_items']\n            )\n        )\n\n    items = ('exclusive_maximum', 'inclusive_maximum', 'exclusive_minimum',\n             'inclusive_minimum')\n    if (any(item in current_validations for item in items)):\n        if isinstance(input_values, list):\n            max_val = max(input_values)\n            min_val = min(input_values)\n        elif isinstance(input_values, dict):\n            max_val = max(input_values.values())\n            min_val = min(input_values.values())\n        else:\n            max_val = input_values\n            min_val = input_values\n\n    if (is_json_validation_enabled('exclusiveMaximum', configuration) and\n            'exclusive_maximum' in current_validations and\n            max_val >= current_validations['exclusive_maximum']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, must be a value less than `%s`\" % (\n                input_variable_path[0],\n                current_validations['exclusive_maximum']\n            )\n        )\n\n    if (is_json_validation_enabled('maximum', configuration) and\n            'inclusive_maximum' in current_validations and\n            max_val > current_validations['inclusive_maximum']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, must be a value less than or equal to \"\n            \"`%s`\" % (\n                input_variable_path[0],\n                current_validations['inclusive_maximum']\n            )\n        )\n\n    if (is_json_validation_enabled('exclusiveMinimum', configuration) and\n            'exclusive_minimum' in current_validations and\n            min_val <= current_validations['exclusive_minimum']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, must be a value greater than `%s`\" %\n            (\n                input_variable_path[0],\n                current_validations['exclusive_maximum']\n            )\n        )\n\n    if (is_json_validation_enabled('minimum', configuration) and\n            'inclusive_minimum' in current_validations and\n            min_val < current_validations['inclusive_minimum']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, must be a value greater than or equal \"\n            \"to `%s`\" % (\n                input_variable_path[0],\n                current_validations['inclusive_minimum']\n            )\n        )\n    flags = current_validations.get('regex', {}).get('flags', 0)\n    if (is_json_validation_enabled('pattern', configuration) and\n            'regex' in current_validations and\n            not re.search(current_validations['regex']['pattern'],\n                          input_values, flags=flags)):\n        err_msg = r\"Invalid value for `%s`, must match regular expression `%s`\" % (\n                    input_variable_path[0],\n                    current_validations['regex']['pattern']\n                )\n        if flags != 0:\n            # Don't print the regex flags if the flags are not\n            # specified in the OAS document.\n            err_msg = r\"%s with flags=`%s`\" % (err_msg, flags)\n        raise ApiValueError(err_msg)\n\n\ndef order_response_types(required_types):\n    \"\"\"Returns the required types sorted in coercion order\n\n    Args:\n        required_types (list/tuple): collection of classes or instance of\n            list or dict with class information inside it.\n\n    Returns:\n        (list): coercion order sorted collection of classes or instance\n            of list or dict with class information inside it.\n    \"\"\"\n\n    def index_getter(class_or_instance):\n        if isinstance(class_or_instance, list):\n            return COERCION_INDEX_BY_TYPE[list]\n        elif isinstance(class_or_instance, dict):\n            return COERCION_INDEX_BY_TYPE[dict]\n        elif (inspect.isclass(class_or_instance)\n                and issubclass(class_or_instance, ModelComposed)):\n            return COERCION_INDEX_BY_TYPE[ModelComposed]\n        elif (inspect.isclass(class_or_instance)\n                and issubclass(class_or_instance, ModelNormal)):\n            return COERCION_INDEX_BY_TYPE[ModelNormal]\n        elif (inspect.isclass(class_or_instance)\n                and issubclass(class_or_instance, ModelSimple)):\n            return COERCION_INDEX_BY_TYPE[ModelSimple]\n        elif class_or_instance in COERCION_INDEX_BY_TYPE:\n            return COERCION_INDEX_BY_TYPE[class_or_instance]\n        raise ApiValueError(\"Unsupported type: %s\" % class_or_instance)\n\n    sorted_types = sorted(\n        required_types,\n        key=lambda class_or_instance: index_getter(class_or_instance)\n    )\n    return sorted_types\n\n\ndef remove_uncoercible(required_types_classes, current_item, spec_property_naming,\n                       must_convert=True):\n    \"\"\"Only keeps the type conversions that are possible\n\n    Args:\n        required_types_classes (tuple): tuple of classes that are required\n                          these should be ordered by COERCION_INDEX_BY_TYPE\n        spec_property_naming (bool): True if the variable names in the input\n            data are serialized names as specified in the OpenAPI document.\n            False if the variables names in the input data are python\n            variable names in PEP-8 snake case.\n        current_item (any): the current item (input data) to be converted\n\n    Keyword Args:\n        must_convert (bool): if True the item to convert is of the wrong\n                          type and we want a big list of coercibles\n                          if False, we want a limited list of coercibles\n\n    Returns:\n        (list): the remaining coercible required types, classes only\n    \"\"\"\n    current_type_simple = get_simple_class(current_item)\n\n    results_classes = []\n    for required_type_class in required_types_classes:\n        # convert our models to OpenApiModel\n        required_type_class_simplified = required_type_class\n        if isinstance(required_type_class_simplified, type):\n            if issubclass(required_type_class_simplified, ModelComposed):\n                required_type_class_simplified = ModelComposed\n            elif issubclass(required_type_class_simplified, ModelNormal):\n                required_type_class_simplified = ModelNormal\n            elif issubclass(required_type_class_simplified, ModelSimple):\n                required_type_class_simplified = ModelSimple\n\n        if required_type_class_simplified == current_type_simple:\n            # don't consider converting to one's own class\n            continue\n\n        class_pair = (current_type_simple, required_type_class_simplified)\n        if must_convert and class_pair in COERCIBLE_TYPE_PAIRS[spec_property_naming]:\n            results_classes.append(required_type_class)\n        elif class_pair in UPCONVERSION_TYPE_PAIRS:\n            results_classes.append(required_type_class)\n    return results_classes\n\ndef get_discriminated_classes(cls):\n    \"\"\"\n    Returns all the classes that a discriminator converts to\n    TODO: lru_cache this\n    \"\"\"\n    possible_classes = []\n    key = list(cls.discriminator.keys())[0]\n    if is_type_nullable(cls):\n        possible_classes.append(cls)\n    for discr_cls in cls.discriminator[key].values():\n        if hasattr(discr_cls, 'discriminator') and discr_cls.discriminator is not None:\n            possible_classes.extend(get_discriminated_classes(discr_cls))\n        else:\n            possible_classes.append(discr_cls)\n    return possible_classes\n\n\ndef get_possible_classes(cls, from_server_context):\n    # TODO: lru_cache this\n    possible_classes = [cls]\n    if from_server_context:\n        return possible_classes\n    if hasattr(cls, 'discriminator') and cls.discriminator is not None:\n        possible_classes = []\n        possible_classes.extend(get_discriminated_classes(cls))\n    elif issubclass(cls, ModelComposed):\n        possible_classes.extend(composed_model_input_classes(cls))\n    return possible_classes\n\n\ndef get_required_type_classes(required_types_mixed, spec_property_naming):\n    \"\"\"Converts the tuple required_types into a tuple and a dict described\n    below\n\n    Args:\n        required_types_mixed (tuple/list): will contain either classes or\n            instance of list or dict\n        spec_property_naming (bool): if True these values came from the\n            server, and we use the data types in our endpoints.\n            If False, we are client side and we need to include\n            oneOf and discriminator classes inside the data types in our endpoints\n\n    Returns:\n        (valid_classes, dict_valid_class_to_child_types_mixed):\n            valid_classes (tuple): the valid classes that the current item\n                                   should be\n            dict_valid_class_to_child_types_mixed (dict):\n                valid_class (class): this is the key\n                child_types_mixed (list/dict/tuple): describes the valid child\n                    types\n    \"\"\"\n    valid_classes = []\n    child_req_types_by_current_type = {}\n    for required_type in required_types_mixed:\n        if isinstance(required_type, list):\n            valid_classes.append(list)\n            child_req_types_by_current_type[list] = required_type\n        elif isinstance(required_type, tuple):\n            valid_classes.append(tuple)\n            child_req_types_by_current_type[tuple] = required_type\n        elif isinstance(required_type, dict):\n            valid_classes.append(dict)\n            child_req_types_by_current_type[dict] = required_type[str]\n        else:\n            valid_classes.extend(get_possible_classes(required_type, spec_property_naming))\n    return tuple(valid_classes), child_req_types_by_current_type\n\n\ndef change_keys_js_to_python(input_dict, model_class):\n    \"\"\"\n    Converts from javascript_key keys in the input_dict to python_keys in\n    the output dict using the mapping in model_class.\n    If the input_dict contains a key which does not declared in the model_class,\n    the key is added to the output dict as is. The assumption is the model_class\n    may have undeclared properties (additionalProperties attribute in the OAS\n    document).\n    \"\"\"\n\n    if getattr(model_class, 'attribute_map', None) is None:\n        return input_dict\n    output_dict = {}\n    reversed_attr_map = {value: key for key, value in\n                         model_class.attribute_map.items()}\n    for javascript_key, value in input_dict.items():\n        python_key = reversed_attr_map.get(javascript_key)\n        if python_key is None:\n            # if the key is unknown, it is in error or it is an\n            # additionalProperties variable\n            python_key = javascript_key\n        output_dict[python_key] = value\n    return output_dict\n\n\ndef get_type_error(var_value, path_to_item, valid_classes, key_type=False):\n    error_msg = type_error_message(\n        var_name=path_to_item[-1],\n        var_value=var_value,\n        valid_classes=valid_classes,\n        key_type=key_type\n    )\n    return ApiTypeError(\n        error_msg,\n        path_to_item=path_to_item,\n        valid_classes=valid_classes,\n        key_type=key_type\n    )\n\n\ndef deserialize_primitive(data, klass, path_to_item):\n    \"\"\"Deserializes string to primitive type.\n\n    :param data: str/int/float\n    :param klass: str/class the class to convert to\n\n    :return: int, float, str, bool, date, datetime\n    \"\"\"\n    additional_message = \"\"\n    try:\n        if klass in {datetime, date}:\n            additional_message = (\n                \"If you need your parameter to have a fallback \"\n                \"string value, please set its type as `type: {}` in your \"\n                \"spec. That allows the value to be any type. \"\n            )\n            if klass == datetime:\n                if len(data) < 8:\n                    raise ValueError(\"This is not a datetime\")\n                # The string should be in iso8601 datetime format.\n                parsed_datetime = parse(data)\n                date_only = (\n                    parsed_datetime.hour == 0 and\n                    parsed_datetime.minute == 0 and\n                    parsed_datetime.second == 0 and\n                    parsed_datetime.tzinfo is None and\n                    8 <= len(data) <= 10\n                )\n                if date_only:\n                    raise ValueError(\"This is a date, not a datetime\")\n                return parsed_datetime\n            elif klass == date:\n                if len(data) < 8:\n                    raise ValueError(\"This is not a date\")\n                return parse(data).date()\n        else:\n            converted_value = klass(data)\n            if isinstance(data, str) and klass == float:\n                if str(converted_value) != data:\n                    # '7' -> 7.0 -> '7.0' != '7'\n                    raise ValueError('This is not a float')\n            return converted_value\n    except (OverflowError, ValueError) as ex:\n        # parse can raise OverflowError\n        raise ApiValueError(\n            \"{0}Failed to parse {1} as {2}\".format(\n                additional_message, repr(data), klass.__name__\n            ),\n            path_to_item=path_to_item\n        ) from ex\n\n\ndef get_discriminator_class(model_class,\n                            discr_name,\n                            discr_value, cls_visited):\n    \"\"\"Returns the child class specified by the discriminator.\n\n    Args:\n        model_class (OpenApiModel): the model class.\n        discr_name (string): the name of the discriminator property.\n        discr_value (any): the discriminator value.\n        cls_visited (list): list of model classes that have been visited.\n            Used to determine the discriminator class without\n            visiting circular references indefinitely.\n\n    Returns:\n        used_model_class (class/None): the chosen child class that will be used\n            to deserialize the data, for example dog.Dog.\n            If a class is not found, None is returned.\n    \"\"\"\n\n    if model_class in cls_visited:\n        # The class has already been visited and no suitable class was found.\n        return None\n    cls_visited.append(model_class)\n    used_model_class = None\n    if discr_name in model_class.discriminator:\n        class_name_to_discr_class = model_class.discriminator[discr_name]\n        used_model_class = class_name_to_discr_class.get(discr_value)\n    if used_model_class is None:\n        # We didn't find a discriminated class in class_name_to_discr_class.\n        # So look in the ancestor or descendant discriminators\n        # The discriminator mapping may exist in a descendant (anyOf, oneOf)\n        # or ancestor (allOf).\n        # Ancestor example: in the GrandparentAnimal -> ParentPet -> ChildCat\n        #   hierarchy, the discriminator mappings may be defined at any level\n        #   in the hierarchy.\n        # Descendant example:  mammal -> whale/zebra/Pig -> BasquePig/DanishPig\n        #   if we try to make BasquePig from mammal, we need to travel through\n        #   the oneOf descendant discriminators to find BasquePig\n        descendant_classes =  model_class._composed_schemas.get('oneOf', ()) + \\\n            model_class._composed_schemas.get('anyOf', ())\n        ancestor_classes = model_class._composed_schemas.get('allOf', ())\n        possible_classes = descendant_classes + ancestor_classes\n        for cls in possible_classes:\n            # Check if the schema has inherited discriminators.\n            if hasattr(cls, 'discriminator') and cls.discriminator is not None:\n                used_model_class = get_discriminator_class(\n                                    cls, discr_name, discr_value, cls_visited)\n                if used_model_class is not None:\n                    return used_model_class\n    return used_model_class\n\n\ndef deserialize_model(model_data, model_class, path_to_item, check_type,\n                      configuration, spec_property_naming):\n    \"\"\"Deserializes model_data to model instance.\n\n    Args:\n        model_data (int/str/float/bool/none_type/list/dict): data to instantiate the model\n        model_class (OpenApiModel): the model class\n        path_to_item (list): path to the model in the received data\n        check_type (bool): whether to check the data tupe for the values in\n            the model\n        configuration (Configuration): the instance to use to convert files\n        spec_property_naming (bool): True if the variable names in the input\n            data are serialized names as specified in the OpenAPI document.\n            False if the variables names in the input data are python\n            variable names in PEP-8 snake case.\n\n    Returns:\n        model instance\n\n    Raise:\n        ApiTypeError\n        ApiValueError\n        ApiKeyError\n    \"\"\"\n\n    kw_args = dict(_check_type=check_type,\n                   _path_to_item=path_to_item,\n                   _configuration=configuration,\n                   _spec_property_naming=spec_property_naming)\n\n    if issubclass(model_class, ModelSimple):\n        return model_class(model_data, **kw_args)\n    elif isinstance(model_data, list):\n        return model_class(*model_data, **kw_args)\n    if isinstance(model_data, dict):\n        kw_args.update(model_data)\n        return model_class(**kw_args)\n    elif isinstance(model_data, PRIMITIVE_TYPES):\n        return model_class(model_data, **kw_args)\n\n\ndef deserialize_file(response_data, configuration, content_disposition=None):\n    \"\"\"Deserializes body to file\n\n    Saves response body into a file in a temporary folder,\n    using the filename from the `Content-Disposition` header if provided.\n\n    Args:\n        param response_data (str):  the file data to write\n        configuration (Configuration): the instance to use to convert files\n\n    Keyword Args:\n        content_disposition (str):  the value of the Content-Disposition\n            header\n\n    Returns:\n        (file_type): the deserialized file which is open\n            The user is responsible for closing and reading the file\n    \"\"\"\n    fd, path = tempfile.mkstemp(dir=configuration.temp_folder_path)\n    os.close(fd)\n    os.remove(path)\n\n    if content_disposition:\n        filename = re.search(r'filename=[\\'\"]?([^\\'\"\\s]+)[\\'\"]?',\n                             content_disposition).group(1)\n        path = os.path.join(os.path.dirname(path), filename)\n\n    with open(path, \"wb\") as f:\n        if isinstance(response_data, str):\n            # change str to bytes so we can write it\n            response_data = response_data.encode('utf-8')\n        f.write(response_data)\n\n    f = open(path, \"rb\")\n    return f\n\n\ndef attempt_convert_item(input_value, valid_classes, path_to_item,\n                         configuration, spec_property_naming, key_type=False,\n                         must_convert=False, check_type=True):\n    \"\"\"\n    Args:\n        input_value (any): the data to convert\n        valid_classes (any): the classes that are valid\n        path_to_item (list): the path to the item to convert\n        configuration (Configuration): the instance to use to convert files\n        spec_property_naming (bool): True if the variable names in the input\n            data are serialized names as specified in the OpenAPI document.\n            False if the variables names in the input data are python\n            variable names in PEP-8 snake case.\n        key_type (bool): if True we need to convert a key type (not supported)\n        must_convert (bool): if True we must convert\n        check_type (bool): if True we check the type or the returned data in\n            ModelComposed/ModelNormal/ModelSimple instances\n\n    Returns:\n        instance (any) the fixed item\n\n    Raises:\n        ApiTypeError\n        ApiValueError\n        ApiKeyError\n    \"\"\"\n    valid_classes_ordered = order_response_types(valid_classes)\n    valid_classes_coercible = remove_uncoercible(\n        valid_classes_ordered, input_value, spec_property_naming)\n    if not valid_classes_coercible or key_type:\n        # we do not handle keytype errors, json will take care\n        # of this for us\n        if configuration is None or not configuration.discard_unknown_keys:\n            raise get_type_error(input_value, path_to_item, valid_classes,\n                                 key_type=key_type)\n    for valid_class in valid_classes_coercible:\n        try:\n            if issubclass(valid_class, OpenApiModel):\n                return deserialize_model(input_value, valid_class,\n                                         path_to_item, check_type,\n                                         configuration, spec_property_naming)\n            elif valid_class == file_type:\n                return deserialize_file(input_value, configuration)\n            return deserialize_primitive(input_value, valid_class,\n                                         path_to_item)\n        except (ApiTypeError, ApiValueError, ApiKeyError) as conversion_exc:\n            if must_convert:\n                raise conversion_exc\n            # if we have conversion errors when must_convert == False\n            # we ignore the exception and move on to the next class\n            continue\n    # we were unable to convert, must_convert == False\n    return input_value\n\n\ndef is_type_nullable(input_type):\n    \"\"\"\n    Returns true if None is an allowed value for the specified input_type.\n\n    A type is nullable if at least one of the following conditions is true:\n    1. The OAS 'nullable' attribute has been specified,\n    1. The type is the 'null' type,\n    1. The type is a anyOf/oneOf composed schema, and a child schema is\n       the 'null' type.\n    Args:\n        input_type (type): the class of the input_value that we are\n            checking\n    Returns:\n        bool\n    \"\"\"\n    if input_type is none_type:\n        return True\n    if issubclass(input_type, OpenApiModel) and input_type._nullable:\n        return True\n    if issubclass(input_type, ModelComposed):\n        # If oneOf/anyOf, check if the 'null' type is one of the allowed types.\n        for t in input_type._composed_schemas.get('oneOf', ()):\n            if is_type_nullable(t): return True\n        for t in input_type._composed_schemas.get('anyOf', ()):\n            if is_type_nullable(t): return True\n    return False\n\n\ndef is_valid_type(input_class_simple, valid_classes):\n    \"\"\"\n    Args:\n        input_class_simple (class): the class of the input_value that we are\n            checking\n        valid_classes (tuple): the valid classes that the current item\n            should be\n    Returns:\n        bool\n    \"\"\"\n    valid_type = input_class_simple in valid_classes\n    if not valid_type and (\n            issubclass(input_class_simple, OpenApiModel) or\n            input_class_simple is none_type):\n        for valid_class in valid_classes:\n            if input_class_simple is none_type and is_type_nullable(valid_class):\n                # Schema is oneOf/anyOf and the 'null' type is one of the allowed types.\n                return True\n            if not (issubclass(valid_class, OpenApiModel) and valid_class.discriminator):\n                continue\n            discr_propertyname_py = list(valid_class.discriminator.keys())[0]\n            discriminator_classes = (\n                valid_class.discriminator[discr_propertyname_py].values()\n            )\n            valid_type = is_valid_type(input_class_simple, discriminator_classes)\n            if valid_type:\n                return True\n    return valid_type\n\n\ndef validate_and_convert_types(input_value, required_types_mixed, path_to_item,\n                               spec_property_naming, _check_type, configuration=None):\n    \"\"\"Raises a TypeError is there is a problem, otherwise returns value\n\n    Args:\n        input_value (any): the data to validate/convert\n        required_types_mixed (list/dict/tuple): A list of\n            valid classes, or a list tuples of valid classes, or a dict where\n            the value is a tuple of value classes\n        path_to_item: (list) the path to the data being validated\n            this stores a list of keys or indices to get to the data being\n            validated\n        spec_property_naming (bool): True if the variable names in the input\n            data are serialized names as specified in the OpenAPI document.\n            False if the variables names in the input data are python\n            variable names in PEP-8 snake case.\n        _check_type: (boolean) if true, type will be checked and conversion\n            will be attempted.\n        configuration: (Configuration): the configuration class to use\n            when converting file_type items.\n            If passed, conversion will be attempted when possible\n            If not passed, no conversions will be attempted and\n            exceptions will be raised\n\n    Returns:\n        the correctly typed value\n\n    Raises:\n        ApiTypeError\n    \"\"\"\n    results = get_required_type_classes(required_types_mixed, spec_property_naming)\n    valid_classes, child_req_types_by_current_type = results\n\n    input_class_simple = get_simple_class(input_value)\n    valid_type = is_valid_type(input_class_simple, valid_classes)\n    if not valid_type:\n        if configuration:\n            # if input_value is not valid_type try to convert it\n            converted_instance = attempt_convert_item(\n                input_value,\n                valid_classes,\n                path_to_item,\n                configuration,\n                spec_property_naming,\n                key_type=False,\n                must_convert=True,\n                check_type=_check_type\n            )\n            return converted_instance\n        else:\n            raise get_type_error(input_value, path_to_item, valid_classes,\n                                 key_type=False)\n\n    # input_value's type is in valid_classes\n    if len(valid_classes) > 1 and configuration:\n        # there are valid classes which are not the current class\n        valid_classes_coercible = remove_uncoercible(\n            valid_classes, input_value, spec_property_naming, must_convert=False)\n        if valid_classes_coercible:\n            converted_instance = attempt_convert_item(\n                input_value,\n                valid_classes_coercible,\n                path_to_item,\n                configuration,\n                spec_property_naming,\n                key_type=False,\n                must_convert=False,\n                check_type=_check_type\n            )\n            return converted_instance\n\n    if child_req_types_by_current_type == {}:\n        # all types are of the required types and there are no more inner\n        # variables left to look at\n        return input_value\n    inner_required_types = child_req_types_by_current_type.get(\n        type(input_value)\n    )\n    if inner_required_types is None:\n        # for this type, there are not more inner variables left to look at\n        return input_value\n    if isinstance(input_value, list):\n        if input_value == []:\n            # allow an empty list\n            return input_value\n        for index, inner_value in enumerate(input_value):\n            inner_path = list(path_to_item)\n            inner_path.append(index)\n            input_value[index] = validate_and_convert_types(\n                inner_value,\n                inner_required_types,\n                inner_path,\n                spec_property_naming,\n                _check_type,\n                configuration=configuration\n            )\n    elif isinstance(input_value, dict):\n        if input_value == {}:\n            # allow an empty dict\n            return input_value\n        for inner_key, inner_val in input_value.items():\n            inner_path = list(path_to_item)\n            inner_path.append(inner_key)\n            if get_simple_class(inner_key) != str:\n                raise get_type_error(inner_key, inner_path, valid_classes,\n                                     key_type=True)\n            input_value[inner_key] = validate_and_convert_types(\n                inner_val,\n                inner_required_types,\n                inner_path,\n                spec_property_naming,\n                _check_type,\n                configuration=configuration\n            )\n    return input_value\n\n\ndef model_to_dict(model_instance, serialize=True):\n    \"\"\"Returns the model properties as a dict\n\n    Args:\n        model_instance (one of your model instances): the model instance that\n            will be converted to a dict.\n\n    Keyword Args:\n        serialize (bool): if True, the keys in the dict will be values from\n            attribute_map\n    \"\"\"\n    result = {}\n\n    model_instances = [model_instance]\n    if model_instance._composed_schemas:\n        model_instances.extend(model_instance._composed_instances)\n    for model_instance in model_instances:\n        for attr, value in model_instance._data_store.items():\n            if serialize:\n                # we use get here because additional property key names do not\n                # exist in attribute_map\n                attr = model_instance.attribute_map.get(attr, attr)\n            if isinstance(value, list):\n               if not value:\n                   # empty list or None\n                   result[attr] = value\n               else:\n                   res = []\n                   for v in value:\n                       if isinstance(v, PRIMITIVE_TYPES) or v is None:\n                           res.append(v)\n                       elif isinstance(v, ModelSimple):\n                           res.append(v.value)\n                       else:\n                           res.append(model_to_dict(v, serialize=serialize))\n                   result[attr] = res\n            elif isinstance(value, dict):\n                result[attr] = dict(map(\n                    lambda item: (item[0],\n                                  model_to_dict(item[1], serialize=serialize))\n                    if hasattr(item[1], '_data_store') else item,\n                    value.items()\n                ))\n            elif isinstance(value, ModelSimple):\n                result[attr] = value.value\n            elif hasattr(value, '_data_store'):\n                result[attr] = model_to_dict(value, serialize=serialize)\n            else:\n                result[attr] = value\n\n    return result\n\n\ndef type_error_message(var_value=None, var_name=None, valid_classes=None,\n                       key_type=None):\n    \"\"\"\n    Keyword Args:\n        var_value (any): the variable which has the type_error\n        var_name (str): the name of the variable which has the typ error\n        valid_classes (tuple): the accepted classes for current_item's\n                                  value\n        key_type (bool): False if our value is a value in a dict\n                         True if it is a key in a dict\n                         False if our item is an item in a list\n    \"\"\"\n    key_or_value = 'value'\n    if key_type:\n        key_or_value = 'key'\n    valid_classes_phrase = get_valid_classes_phrase(valid_classes)\n    msg = (\n        \"Invalid type for variable '{0}'. Required {1} type {2} and \"\n        \"passed type was {3}\".format(\n            var_name,\n            key_or_value,\n            valid_classes_phrase,\n            type(var_value).__name__,\n        )\n    )\n    return msg\n\n\ndef get_valid_classes_phrase(input_classes):\n    \"\"\"Returns a string phrase describing what types are allowed\n    \"\"\"\n    all_classes = list(input_classes)\n    all_classes = sorted(all_classes, key=lambda cls: cls.__name__)\n    all_class_names = [cls.__name__ for cls in all_classes]\n    if len(all_class_names) == 1:\n        return 'is {0}'.format(all_class_names[0])\n    return \"is one of [{0}]\".format(\", \".join(all_class_names))\n\n\ndef convert_js_args_to_python_args(fn):\n    from functools import wraps\n    @wraps(fn)\n    def wrapped_init(_self, *args, **kwargs):\n        \"\"\"\n        An attribute named `self` received from the api will conflicts with the reserved `self`\n        parameter of a class method. During generation, `self` attributes are mapped\n        to `_self` in models. Here, we name `_self` instead of `self` to avoid conflicts.\n        \"\"\"\n        spec_property_naming = kwargs.get('_spec_property_naming', False)\n        if spec_property_naming:\n            kwargs = change_keys_js_to_python(kwargs, _self.__class__)\n        return fn(_self, *args, **kwargs)\n    return wrapped_init\n\n\ndef get_allof_instances(self, model_args, constant_args):\n    \"\"\"\n    Args:\n        self: the class we are handling\n        model_args (dict): var_name to var_value\n            used to make instances\n        constant_args (dict): var_name to var_value\n            used to make instances\n\n    Returns\n        composed_instances (list)\n    \"\"\"\n    composed_instances = []\n    for allof_class in self._composed_schemas['allOf']:\n\n        # no need to handle changing js keys to python because\n        # for composed schemas, allof parameters are included in the\n        # composed schema and were changed to python keys in __new__\n        # extract a dict of only required keys from fixed_model_args\n        kwargs = {}\n        var_names = set(allof_class.openapi_types.keys())\n        for var_name in var_names:\n            if var_name in model_args:\n                kwargs[var_name] = model_args[var_name]\n\n        # and use it to make the instance\n        kwargs.update(constant_args)\n        try:\n            allof_instance = allof_class(**kwargs)\n            composed_instances.append(allof_instance)\n        except Exception as ex:\n            raise ApiValueError(\n                \"Invalid inputs given to generate an instance of '%s'. The \"\n                \"input data was invalid for the allOf schema '%s' in the composed \"\n                \"schema '%s'. Error=%s\" % (\n                    allof_class.__name__,\n                    allof_class.__name__,\n                    self.__class__.__name__,\n                    str(ex)\n                )\n            ) from ex\n    return composed_instances\n\n\ndef get_oneof_instance(cls, model_kwargs, constant_kwargs, model_arg=None):\n    \"\"\"\n    Find the oneOf schema that matches the input data (e.g. payload).\n    If exactly one schema matches the input data, an instance of that schema\n    is returned.\n    If zero or more than one schema match the input data, an exception is raised.\n    In OAS 3.x, the payload MUST, by validation, match exactly one of the\n    schemas described by oneOf.\n\n    Args:\n        cls: the class we are handling\n        model_kwargs (dict): var_name to var_value\n            The input data, e.g. the payload that must match a oneOf schema\n            in the OpenAPI document.\n        constant_kwargs (dict): var_name to var_value\n            args that every model requires, including configuration, server\n            and path to item.\n\n    Kwargs:\n        model_arg: (int, float, bool, str, date, datetime, ModelSimple, None):\n            the value to assign to a primitive class or ModelSimple class\n            Notes:\n            - this is only passed in when oneOf includes types which are not object\n            - None is used to suppress handling of model_arg, nullable models are handled in __new__\n\n    Returns\n        oneof_instance (instance)\n    \"\"\"\n    if len(cls._composed_schemas['oneOf']) == 0:\n        return None\n\n    oneof_instances = []\n    # Iterate over each oneOf schema and determine if the input data\n    # matches the oneOf schemas.\n    for oneof_class in cls._composed_schemas['oneOf']:\n        # The composed oneOf schema allows the 'null' type and the input data\n        # is the null value. This is a OAS >= 3.1 feature.\n        if oneof_class is none_type:\n            # skip none_types because we are deserializing dict data.\n            # none_type deserialization is handled in the __new__ method\n            continue\n\n        single_value_input = allows_single_value_input(oneof_class)\n\n        if not single_value_input:\n            # transform js keys from input data to python keys in fixed_model_args\n            fixed_model_args = change_keys_js_to_python(\n                model_kwargs, oneof_class)\n\n            # Extract a dict with the properties that are declared in the oneOf schema.\n            # Undeclared properties (e.g. properties that are allowed because of the\n            # additionalProperties attribute in the OAS document) are not added to\n            # the dict.\n            kwargs = {}\n            var_names = set(oneof_class.openapi_types.keys())\n            for var_name in var_names:\n                if var_name in fixed_model_args:\n                    kwargs[var_name] = fixed_model_args[var_name]\n\n            # do not try to make a model with no input args\n            if len(kwargs) == 0:\n                continue\n\n            # and use it to make the instance\n            kwargs.update(constant_kwargs)\n\n        try:\n            if not single_value_input:\n                oneof_instance = oneof_class(**kwargs)\n            else:\n                if issubclass(oneof_class, ModelSimple):\n                    oneof_instance = oneof_class(model_arg, **constant_kwargs)\n                elif oneof_class in PRIMITIVE_TYPES:\n                    oneof_instance = validate_and_convert_types(\n                        model_arg,\n                        (oneof_class,),\n                        constant_kwargs['_path_to_item'],\n                        constant_kwargs['_spec_property_naming'],\n                        constant_kwargs['_check_type'],\n                        configuration=constant_kwargs['_configuration']\n                    )\n            oneof_instances.append(oneof_instance)\n        except Exception:\n            pass\n    if len(oneof_instances) == 0:\n        raise ApiValueError(\n            \"Invalid inputs given to generate an instance of %s. None \"\n            \"of the oneOf schemas matched the input data.\" %\n            cls.__name__\n        )\n    elif len(oneof_instances) > 1:\n        raise ApiValueError(\n            \"Invalid inputs given to generate an instance of %s. Multiple \"\n            \"oneOf schemas matched the inputs, but a max of one is allowed.\" %\n            cls.__name__\n        )\n    return oneof_instances[0]\n\n\ndef get_anyof_instances(self, model_args, constant_args):\n    \"\"\"\n    Args:\n        self: the class we are handling\n        model_args (dict): var_name to var_value\n            The input data, e.g. the payload that must match at least one\n            anyOf child schema in the OpenAPI document.\n        constant_args (dict): var_name to var_value\n            args that every model requires, including configuration, server\n            and path to item.\n\n    Returns\n        anyof_instances (list)\n    \"\"\"\n    anyof_instances = []\n    if len(self._composed_schemas['anyOf']) == 0:\n        return anyof_instances\n\n    for anyof_class in self._composed_schemas['anyOf']:\n        # The composed oneOf schema allows the 'null' type and the input data\n        # is the null value. This is a OAS >= 3.1 feature.\n        if anyof_class is none_type:\n            # skip none_types because we are deserializing dict data.\n            # none_type deserialization is handled in the __new__ method\n            continue\n\n        # transform js keys to python keys in fixed_model_args\n        fixed_model_args = change_keys_js_to_python(model_args, anyof_class)\n\n        # extract a dict of only required keys from these_model_vars\n        kwargs = {}\n        var_names = set(anyof_class.openapi_types.keys())\n        for var_name in var_names:\n            if var_name in fixed_model_args:\n                kwargs[var_name] = fixed_model_args[var_name]\n\n        # do not try to make a model with no input args\n        if len(kwargs) == 0:\n            continue\n\n        # and use it to make the instance\n        kwargs.update(constant_args)\n        try:\n            anyof_instance = anyof_class(**kwargs)\n            anyof_instances.append(anyof_instance)\n        except Exception:\n            pass\n    if len(anyof_instances) == 0:\n        raise ApiValueError(\n            \"Invalid inputs given to generate an instance of %s. None of the \"\n            \"anyOf schemas matched the inputs.\" %\n            self.__class__.__name__\n        )\n    return anyof_instances\n\n\ndef get_additional_properties_model_instances(\n        composed_instances, self):\n    additional_properties_model_instances = []\n    all_instances = [self]\n    all_instances.extend(composed_instances)\n    for instance in all_instances:\n        if instance.additional_properties_type is not None:\n            additional_properties_model_instances.append(instance)\n    return additional_properties_model_instances\n\n\ndef get_var_name_to_model_instances(self, composed_instances):\n    var_name_to_model_instances = {}\n    all_instances = [self]\n    all_instances.extend(composed_instances)\n    for instance in all_instances:\n        for var_name in instance.openapi_types:\n            if var_name not in var_name_to_model_instances:\n                var_name_to_model_instances[var_name] = [instance]\n            else:\n                var_name_to_model_instances[var_name].append(instance)\n    return var_name_to_model_instances\n\n\ndef get_unused_args(self, composed_instances, model_args):\n    unused_args = dict(model_args)\n    # arguments apssed to self were already converted to python names\n    # before __init__ was called\n    for var_name_py in self.attribute_map:\n        if var_name_py in unused_args:\n            del unused_args[var_name_py]\n    for instance in composed_instances:\n        if instance.__class__ in self._composed_schemas['allOf']:\n            for var_name_py in instance.attribute_map:\n                if var_name_py in unused_args:\n                    del unused_args[var_name_py]\n        else:\n            for var_name_js in instance.attribute_map.values():\n                if var_name_js in unused_args:\n                    del unused_args[var_name_js]\n    return unused_args\n\n\ndef validate_get_composed_info(constant_args, model_args, self):\n    \"\"\"\n    For composed schemas, generate schema instances for\n    all schemas in the oneOf/anyOf/allOf definition. If additional\n    properties are allowed, also assign those properties on\n    all matched schemas that contain additionalProperties.\n    Openapi schemas are python classes.\n\n    Exceptions are raised if:\n    - 0 or > 1 oneOf schema matches the model_args input data\n    - no anyOf schema matches the model_args input data\n    - any of the allOf schemas do not match the model_args input data\n\n    Args:\n        constant_args (dict): these are the args that every model requires\n        model_args (dict): these are the required and optional spec args that\n            were passed in to make this model\n        self (class): the class that we are instantiating\n            This class contains self._composed_schemas\n\n    Returns:\n        composed_info (list): length three\n            composed_instances (list): the composed instances which are not\n                self\n            var_name_to_model_instances (dict): a dict going from var_name\n                to the model_instance which holds that var_name\n                the model_instance may be self or an instance of one of the\n                classes in self.composed_instances()\n            additional_properties_model_instances (list): a list of the\n                model instances which have the property\n                additional_properties_type. This list can include self\n    \"\"\"\n    # create composed_instances\n    composed_instances = []\n    allof_instances = get_allof_instances(self, model_args, constant_args)\n    composed_instances.extend(allof_instances)\n    oneof_instance = get_oneof_instance(self.__class__, model_args, constant_args)\n    if oneof_instance is not None:\n        composed_instances.append(oneof_instance)\n    anyof_instances = get_anyof_instances(self, model_args, constant_args)\n    composed_instances.extend(anyof_instances)\n\n    # map variable names to composed_instances\n    var_name_to_model_instances = get_var_name_to_model_instances(\n        self, composed_instances)\n\n    # set additional_properties_model_instances\n    additional_properties_model_instances = (\n        get_additional_properties_model_instances(composed_instances, self)\n    )\n\n    # set any remaining values\n    unused_args = get_unused_args(self, composed_instances, model_args)\n    if len(unused_args) > 0 and \\\n            len(additional_properties_model_instances) == 0 and \\\n            (self._configuration is None or\n                not self._configuration.discard_unknown_keys):\n        raise ApiValueError(\n            \"Invalid input arguments input when making an instance of \"\n            \"class %s. Not all inputs were used. The unused input data \"\n            \"is %s\" % (self.__class__.__name__, unused_args)\n        )\n\n    # no need to add additional_properties to var_name_to_model_instances here\n    # because additional_properties_model_instances will direct us to that\n    # instance when we use getattr or setattr\n    # and we update var_name_to_model_instances in setattr\n\n    return [\n      composed_instances,\n      var_name_to_model_instances,\n      additional_properties_model_instances,\n      unused_args\n    ]\n        \n      \n    \n        \n        \n        \n        \n        \n    \n        :\n    \n        \n    \n        \n        \n        \n\n        :\n        \n\n    \n        \n    \n\n    \n        \n        \n",
    "after": "\"\"\"\n    OpenAPI Petstore\n\n    This spec is mainly for testing Petstore server and contains fake endpoints, models. Please do not use this for any other purpose. Special characters: \\\" \\\\  # noqa: E501\n\n    The version of the OpenAPI document: 1.0.0\n    Generated by: https://openapi-generator.tech\n\"\"\"\n\n\nfrom datetime import date, datetime  # noqa: F401\nimport inspect\nimport io\nimport os\nimport pprint\nimport re\nimport tempfile\n\nfrom dateutil.parser import parse\n\nfrom petstore_api.exceptions import (\n    ApiKeyError,\n    ApiAttributeError,\n    ApiTypeError,\n    ApiValueError,\n)\n\nnone_type = type(None)\nfile_type = io.IOBase\n\n\nclass cached_property(object):\n    # this caches the result of the function call for fn with no inputs\n    # use this as a decorator on fuction methods that you want converted\n    # into cached properties\n    result_key = '_results'\n\n    def __init__(self, fn):\n        self._fn = fn\n\n    def __get__(self, instance, cls=None):\n        if self.result_key in vars(self):\n            return vars(self)[self.result_key]\n        else:\n            result = self._fn()\n            setattr(self, self.result_key, result)\n            return result\n\n\nPRIMITIVE_TYPES = (list, float, int, bool, datetime, date, str, file_type)\n\ndef allows_single_value_input(cls):\n    \"\"\"\n    This function returns True if the input composed schema model or any\n    descendant model allows a value only input\n    This is true for cases where oneOf contains items like:\n    oneOf:\n      - float\n      - NumberWithValidation\n      - StringEnum\n      - ArrayModel\n      - null\n    TODO: lru_cache this\n    \"\"\"\n    if (\n        issubclass(cls, ModelSimple) or\n        cls in PRIMITIVE_TYPES\n    ):\n        return True\n    elif issubclass(cls, ModelComposed):\n        if not cls._composed_schemas['oneOf']:\n            return False\n        return any(allows_single_value_input(c) for c in cls._composed_schemas['oneOf'])\n    return False\n\ndef composed_model_input_classes(cls):\n    \"\"\"\n    This function returns a list of the possible models that can be accepted as\n    inputs.\n    TODO: lru_cache this\n    \"\"\"\n    if issubclass(cls, ModelSimple) or cls in PRIMITIVE_TYPES:\n        return [cls]\n    elif issubclass(cls, ModelNormal):\n        if cls.discriminator is None:\n            return [cls]\n        else:\n            return get_discriminated_classes(cls)\n    elif issubclass(cls, ModelComposed):\n        if not cls._composed_schemas['oneOf']:\n            return []\n        if cls.discriminator is None:\n            input_classes = []\n            for c in cls._composed_schemas['oneOf']:\n                input_classes.extend(composed_model_input_classes(c))\n            return input_classes\n        else:\n            return get_discriminated_classes(cls)\n    return []\n\n\nclass OpenApiModel(object):\n    \"\"\"The base class for all OpenAPIModels\"\"\"\n\n    def set_attribute(self, name, value):\n        # this is only used to set properties on self\n\n        path_to_item = []\n        if self._path_to_item:\n            path_to_item.extend(self._path_to_item)\n        path_to_item.append(name)\n\n        if name in self.openapi_types:\n            required_types_mixed = self.openapi_types[name]\n        elif self.additional_properties_type is None:\n            raise ApiAttributeError(\n                \"{0} has no attribute '{1}'\".format(\n                    type(self).__name__, name),\n                path_to_item\n            )\n        elif self.additional_properties_type is not None:\n            required_types_mixed = self.additional_properties_type\n\n        if get_simple_class(name) != str:\n            error_msg = type_error_message(\n                var_name=name,\n                var_value=name,\n                valid_classes=(str,),\n                key_type=True\n            )\n            raise ApiTypeError(\n                error_msg,\n                path_to_item=path_to_item,\n                valid_classes=(str,),\n                key_type=True\n            )\n\n        if self._check_type:\n            value = validate_and_convert_types(\n                value, required_types_mixed, path_to_item, self._spec_property_naming,\n                self._check_type, configuration=self._configuration)\n        if (name,) in self.allowed_values:\n            check_allowed_values(\n                self.allowed_values,\n                (name,),\n                value\n            )\n        if (name,) in self.validations:\n            check_validations(\n                self.validations,\n                (name,),\n                value,\n                self._configuration\n            )\n        self.__dict__['_data_store'][name] = value\n\n    def __repr__(self):\n        \"\"\"For `print` and `pprint`\"\"\"\n        return self.to_str()\n\n    def __ne__(self, other):\n        \"\"\"Returns true if both objects are not equal\"\"\"\n        return not self == other\n\n    def __setattr__(self, attr, value):\n        \"\"\"set the value of an attribute using dot notation: `instance.attr = val`\"\"\"\n        self[attr] = value\n\n    def __getattr__(self, attr):\n        \"\"\"get the value of an attribute using dot notation: `instance.attr`\"\"\"\n        return self.__getitem__(attr)\n\n    def __new__(cls, *args, **kwargs):\n        # this function uses the discriminator to\n        # pick a new schema/class to instantiate because a discriminator\n        # propertyName value was passed in\n\n        if len(args) == 1:\n            arg = args[0]\n            if arg is None and is_type_nullable(cls):\n                # The input data is the 'null' value and the type is nullable.\n                return None\n\n            if issubclass(cls, ModelComposed) and allows_single_value_input(cls):\n                model_kwargs = {}\n                oneof_instance = get_oneof_instance(cls, model_kwargs, kwargs, model_arg=arg)\n                return oneof_instance\n\n\n        visited_composed_classes = kwargs.get('_visited_composed_classes', ())\n        if (\n            cls.discriminator is None or\n            cls in visited_composed_classes\n        ):\n            # Use case 1: this openapi schema (cls) does not have a discriminator\n            # Use case 2: we have already visited this class before and are sure that we\n            # want to instantiate it this time. We have visited this class deserializing\n            # a payload with a discriminator. During that process we traveled through\n            # this class but did not make an instance of it. Now we are making an\n            # instance of a composed class which contains cls in it, so this time make an instance of cls.\n            #\n            # Here's an example of use case 2: If Animal has a discriminator\n            # petType and we pass in \"Dog\", and the class Dog\n            # allOf includes Animal, we move through Animal\n            # once using the discriminator, and pick Dog.\n            # Then in the composed schema dog Dog, we will make an instance of the\n            # Animal class (because Dal has allOf: Animal) but this time we won't travel\n            # through Animal's discriminator because we passed in\n            # _visited_composed_classes = (Animal,)\n\n            return super(OpenApiModel, cls).__new__(cls)\n\n        # Get the name and value of the discriminator property.\n        # The discriminator name is obtained from the discriminator meta-data\n        # and the discriminator value is obtained from the input data.\n        discr_propertyname_py = list(cls.discriminator.keys())[0]\n        discr_propertyname_js = cls.attribute_map[discr_propertyname_py]\n        if discr_propertyname_js in kwargs:\n            discr_value = kwargs[discr_propertyname_js]\n        elif discr_propertyname_py in kwargs:\n            discr_value = kwargs[discr_propertyname_py]\n        else:\n            # The input data does not contain the discriminator property.\n            path_to_item = kwargs.get('_path_to_item', ())\n            raise ApiValueError(\n                \"Cannot deserialize input data due to missing discriminator. \"\n                \"The discriminator property '%s' is missing at path: %s\" %\n                (discr_propertyname_js, path_to_item)\n            )\n\n        # Implementation note: the last argument to get_discriminator_class\n        # is a list of visited classes. get_discriminator_class may recursively\n        # call itself and update the list of visited classes, and the initial\n        # value must be an empty list. Hence not using 'visited_composed_classes'\n        new_cls = get_discriminator_class(\n                    cls, discr_propertyname_py, discr_value, [])\n        if new_cls is None:\n            path_to_item = kwargs.get('_path_to_item', ())\n            disc_prop_value = kwargs.get(\n                discr_propertyname_js, kwargs.get(discr_propertyname_py))\n            raise ApiValueError(\n                \"Cannot deserialize input data due to invalid discriminator \"\n                \"value. The OpenAPI document has no mapping for discriminator \"\n                \"property '%s'='%s' at path: %s\" %\n                (discr_propertyname_js, disc_prop_value, path_to_item)\n            )\n\n        if new_cls in visited_composed_classes:\n            # if we are making an instance of a composed schema Descendent\n            # which allOf includes Ancestor, then Ancestor contains\n            # a discriminator that includes Descendent.\n            # So if we make an instance of Descendent, we have to make an\n            # instance of Ancestor to hold the allOf properties.\n            # This code detects that use case and makes the instance of Ancestor\n            # For example:\n            # When making an instance of Dog, _visited_composed_classes = (Dog,)\n            # then we make an instance of Animal to include in dog._composed_instances\n            # so when we are here, cls is Animal\n            # cls.discriminator != None\n            # cls not in _visited_composed_classes\n            # new_cls = Dog\n            # but we know we know that we already have Dog\n            # because it is in visited_composed_classes\n            # so make Animal here\n            return super(OpenApiModel, cls).__new__(cls)\n\n        # Build a list containing all oneOf and anyOf descendants.\n        oneof_anyof_classes = None\n        if cls._composed_schemas is not None:\n            oneof_anyof_classes = (\n                cls._composed_schemas.get('oneOf', ()) +\n                cls._composed_schemas.get('anyOf', ()))\n        oneof_anyof_child = new_cls in oneof_anyof_classes\n        kwargs['_visited_composed_classes'] = visited_composed_classes + (cls,)\n\n        if cls._composed_schemas.get('allOf') and oneof_anyof_child:\n            # Validate that we can make self because when we make the\n            # new_cls it will not include the allOf validations in self\n            self_inst = super(OpenApiModel, cls).__new__(cls)\n            self_inst.__init__(*args, **kwargs)\n\n        new_inst = new_cls.__new__(new_cls, *args, **kwargs)\n        new_inst.__init__(*args, **kwargs)\n        return new_inst\n\n\nclass ModelSimple(OpenApiModel):\n    \"\"\"the parent class of models whose type != object in their\n    swagger/openapi\"\"\"\n\n    def __setitem__(self, name, value):\n        \"\"\"set the value of an attribute using square-bracket notation: `instance[attr] = val`\"\"\"\n        if name in self.required_properties:\n            self.__dict__[name] = value\n            return\n\n        self.set_attribute(name, value)\n\n    def get(self, name, default=None):\n        \"\"\"returns the value of an attribute or some default value if the attribute was not set\"\"\"\n        if name in self.required_properties:\n            return self.__dict__[name]\n\n        return self.__dict__['_data_store'].get(name, default)\n\n    def __getitem__(self, name):\n        \"\"\"get the value of an attribute using square-bracket notation: `instance[attr]`\"\"\"\n        if name in self:\n            return self.get(name)\n\n        raise ApiAttributeError(\n            \"{0} has no attribute '{1}'\".format(\n                type(self).__name__, name),\n            [e for e in [self._path_to_item, name] if e]\n        )\n\n    def __contains__(self, name):\n        \"\"\"used by `in` operator to check if an attrbute value was set in an instance: `'attr' in instance`\"\"\"\n        if name in self.required_properties:\n            return name in self.__dict__\n\n        return name in self.__dict__['_data_store']\n\n    def to_str(self):\n        \"\"\"Returns the string representation of the model\"\"\"\n        return str(self.value)\n\n    def __eq__(self, other):\n        \"\"\"Returns true if both objects are equal\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n\n        this_val = self._data_store['value']\n        that_val = other._data_store['value']\n        types = set()\n        types.add(this_val.__class__)\n        types.add(that_val.__class__)\n        vals_equal = this_val == that_val\n        return vals_equal\n\n\nclass ModelNormal(OpenApiModel):\n    \"\"\"the parent class of models whose type == object in their\n    swagger/openapi\"\"\"\n\n    def __setitem__(self, name, value):\n        \"\"\"set the value of an attribute using square-bracket notation: `instance[attr] = val`\"\"\"\n        if name in self.required_properties:\n            self.__dict__[name] = value\n            return\n\n        self.set_attribute(name, value)\n\n    def get(self, name, default=None):\n        \"\"\"returns the value of an attribute or some default value if the attribute was not set\"\"\"\n        if name in self.required_properties:\n            return self.__dict__[name]\n\n        return self.__dict__['_data_store'].get(name, default)\n\n    def __getitem__(self, name):\n        \"\"\"get the value of an attribute using square-bracket notation: `instance[attr]`\"\"\"\n        if name in self:\n            return self.get(name)\n\n        raise ApiAttributeError(\n            \"{0} has no attribute '{1}'\".format(\n                type(self).__name__, name),\n            [e for e in [self._path_to_item, name] if e]\n        )\n\n    def __contains__(self, name):\n        \"\"\"used by `in` operator to check if an attrbute value was set in an instance: `'attr' in instance`\"\"\"\n        if name in self.required_properties:\n            return name in self.__dict__\n\n        return name in self.__dict__['_data_store']\n\n    def to_dict(self):\n        \"\"\"Returns the model properties as a dict\"\"\"\n        return model_to_dict(self, serialize=False)\n\n    def to_str(self):\n        \"\"\"Returns the string representation of the model\"\"\"\n        return pprint.pformat(self.to_dict())\n\n    def __eq__(self, other):\n        \"\"\"Returns true if both objects are equal\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n\n        if not set(self._data_store.keys()) == set(other._data_store.keys()):\n            return False\n        for _var_name, this_val in self._data_store.items():\n            that_val = other._data_store[_var_name]\n            types = set()\n            types.add(this_val.__class__)\n            types.add(that_val.__class__)\n            vals_equal = this_val == that_val\n            if not vals_equal:\n                return False\n        return True\n\n\nclass ModelComposed(OpenApiModel):\n    \"\"\"the parent class of models whose type == object in their\n    swagger/openapi and have oneOf/allOf/anyOf\n\n    When one sets a property we use var_name_to_model_instances to store the value in\n    the correct class instances + run any type checking + validation code.\n    When one gets a property we use var_name_to_model_instances to get the value\n    from the correct class instances.\n    This allows multiple composed schemas to contain the same property with additive\n    constraints on the value.\n\n    _composed_schemas (dict) stores the anyOf/allOf/oneOf classes\n    key (str): allOf/oneOf/anyOf\n    value (list): the classes in the XOf definition.\n        Note: none_type can be included when the openapi document version >= 3.1.0\n    _composed_instances (list): stores a list of instances of the composed schemas\n    defined in _composed_schemas. When properties are accessed in the self instance,\n    they are returned from the self._data_store or the data stores in the instances\n    in self._composed_schemas\n    _var_name_to_model_instances (dict): maps between a variable name on self and\n    the composed instances (self included) which contain that data\n    key (str): property name\n    value (list): list of class instances, self or instances in _composed_instances\n    which contain the value that the key is referring to.\n    \"\"\"\n\n    def __setitem__(self, name, value):\n        \"\"\"set the value of an attribute using square-bracket notation: `instance[attr] = val`\"\"\"\n        if name in self.required_properties:\n            self.__dict__[name] = value\n            return\n\n        # set the attribute on the correct instance\n        model_instances = self._var_name_to_model_instances.get(\n            name, self._additional_properties_model_instances)\n        if model_instances:\n            for model_instance in model_instances:\n                if model_instance == self:\n                    self.set_attribute(name, value)\n                else:\n                    setattr(model_instance, name, value)\n                if name not in self._var_name_to_model_instances:\n                    # we assigned an additional property\n                    self.__dict__['_var_name_to_model_instances'][name] = (\n                        model_instance\n                    )\n            return None\n\n        raise ApiAttributeError(\n            \"{0} has no attribute '{1}'\".format(\n                type(self).__name__, name),\n            [e for e in [self._path_to_item, name] if e]\n        )\n\n    __unset_attribute_value__ = object()\n\n    def get(self, name, default=None):\n        \"\"\"returns the value of an attribute or some default value if the attribute was not set\"\"\"\n        if name in self.required_properties:\n            return self.__dict__[name]\n\n        # get the attribute from the correct instance\n        model_instances = self._var_name_to_model_instances.get(\n            name, self._additional_properties_model_instances)\n        values = []\n        # A composed model stores child (oneof/anyOf/allOf) models under\n        # self._var_name_to_model_instances. A named property can exist in\n        # multiple child models. If the property is present in more than one\n        # child model, the value must be the same across all the child models.\n        if model_instances:\n            for model_instance in model_instances:\n                if name in model_instance._data_store:\n                    v = model_instance._data_store[name]\n                    if v not in values:\n                        values.append(v)\n        len_values = len(values)\n        if len_values == 0:\n            return default\n        elif len_values == 1:\n            return values[0]\n        elif len_values > 1:\n            raise ApiValueError(\n                \"Values stored for property {0} in {1} differ when looking \"\n                \"at self and self's composed instances. All values must be \"\n                \"the same\".format(name, type(self).__name__),\n                [e for e in [self._path_to_item, name] if e]\n            )\n\n    def __getitem__(self, name):\n        \"\"\"get the value of an attribute using square-bracket notation: `instance[attr]`\"\"\"\n        value = self.get(name, self.__unset_attribute_value__)\n        if value is self.__unset_attribute_value__:\n            raise ApiAttributeError(\n                \"{0} has no attribute '{1}'\".format(\n                    type(self).__name__, name),\n                    [e for e in [self._path_to_item, name] if e]\n            )\n        return value\n\n    def __contains__(self, name):\n        \"\"\"used by `in` operator to check if an attrbute value was set in an instance: `'attr' in instance`\"\"\"\n\n        if name in self.required_properties:\n            return name in self.__dict__\n\n        model_instances = self._var_name_to_model_instances.get(\n            name, self._additional_properties_model_instances)\n\n        if model_instances:\n            for model_instance in model_instances:\n                if name in model_instance._data_store:\n                    return True\n\n        return False\n\n    def to_dict(self):\n        \"\"\"Returns the model properties as a dict\"\"\"\n        return model_to_dict(self, serialize=False)\n\n    def to_str(self):\n        \"\"\"Returns the string representation of the model\"\"\"\n        return pprint.pformat(self.to_dict())\n\n    def __eq__(self, other):\n        \"\"\"Returns true if both objects are equal\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n\n        if not set(self._data_store.keys()) == set(other._data_store.keys()):\n            return False\n        for _var_name, this_val in self._data_store.items():\n            that_val = other._data_store[_var_name]\n            types = set()\n            types.add(this_val.__class__)\n            types.add(that_val.__class__)\n            vals_equal = this_val == that_val\n            if not vals_equal:\n                return False\n        return True\n\n\nCOERCION_INDEX_BY_TYPE = {\n    ModelComposed: 0,\n    ModelNormal: 1,\n    ModelSimple: 2,\n    none_type: 3,    # The type of 'None'.\n    list: 4,\n    dict: 5,\n    float: 6,\n    int: 7,\n    bool: 8,\n    datetime: 9,\n    date: 10,\n    str: 11,\n    file_type: 12,   # 'file_type' is an alias for the built-in 'file' or 'io.IOBase' type.\n}\n\n# these are used to limit what type conversions we try to do\n# when we have a valid type already and we want to try converting\n# to another type\nUPCONVERSION_TYPE_PAIRS = (\n    (str, datetime),\n    (str, date),\n    (int, float),             # A float may be serialized as an integer, e.g. '3' is a valid serialized float.\n    (list, ModelComposed),\n    (dict, ModelComposed),\n    (str, ModelComposed),\n    (int, ModelComposed),\n    (float, ModelComposed),\n    (list, ModelComposed),\n    (list, ModelNormal),\n    (dict, ModelNormal),\n    (str, ModelSimple),\n    (int, ModelSimple),\n    (float, ModelSimple),\n    (list, ModelSimple),\n)\n\nCOERCIBLE_TYPE_PAIRS = {\n    False: (  # client instantiation of a model with client data\n        # (dict, ModelComposed),\n        # (list, ModelComposed),\n        # (dict, ModelNormal),\n        # (list, ModelNormal),\n        # (str, ModelSimple),\n        # (int, ModelSimple),\n        # (float, ModelSimple),\n        # (list, ModelSimple),\n        # (str, int),\n        # (str, float),\n        # (str, datetime),\n        # (str, date),\n        # (int, str),\n        # (float, str),\n    ),\n    True: (  # server -> client data\n        (dict, ModelComposed),\n        (list, ModelComposed),\n        (dict, ModelNormal),\n        (list, ModelNormal),\n        (str, ModelSimple),\n        (int, ModelSimple),\n        (float, ModelSimple),\n        (list, ModelSimple),\n        # (str, int),\n        # (str, float),\n        (str, datetime),\n        (str, date),\n        # (int, str),\n        # (float, str),\n        (str, file_type)\n    ),\n}\n\n\ndef get_simple_class(input_value):\n    \"\"\"Returns an input_value's simple class that we will use for type checking\n    Python2:\n    float and int will return int, where int is the python3 int backport\n    str and unicode will return str, where str is the python3 str backport\n    Note: float and int ARE both instances of int backport\n    Note: str_py2 and unicode_py2 are NOT both instances of str backport\n\n    Args:\n        input_value (class/class_instance): the item for which we will return\n                                            the simple class\n    \"\"\"\n    if isinstance(input_value, type):\n        # input_value is a class\n        return input_value\n    elif isinstance(input_value, tuple):\n        return tuple\n    elif isinstance(input_value, list):\n        return list\n    elif isinstance(input_value, dict):\n        return dict\n    elif isinstance(input_value, none_type):\n        return none_type\n    elif isinstance(input_value, file_type):\n        return file_type\n    elif isinstance(input_value, bool):\n        # this must be higher than the int check because\n        # isinstance(True, int) == True\n        return bool\n    elif isinstance(input_value, int):\n        return int\n    elif isinstance(input_value, datetime):\n        # this must be higher than the date check because\n        # isinstance(datetime_instance, date) == True\n        return datetime\n    elif isinstance(input_value, date):\n        return date\n    elif isinstance(input_value, str):\n        return str\n    return type(input_value)\n\n\ndef check_allowed_values(allowed_values, input_variable_path, input_values):\n    \"\"\"Raises an exception if the input_values are not allowed\n\n    Args:\n        allowed_values (dict): the allowed_values dict\n        input_variable_path (tuple): the path to the input variable\n        input_values (list/str/int/float/date/datetime): the values that we\n            are checking to see if they are in allowed_values\n    \"\"\"\n    these_allowed_values = list(allowed_values[input_variable_path].values())\n    if (isinstance(input_values, list)\n            and not set(input_values).issubset(\n                set(these_allowed_values))):\n        invalid_values = \", \".join(\n            map(str, set(input_values) - set(these_allowed_values))),\n        raise ApiValueError(\n            \"Invalid values for `%s` [%s], must be a subset of [%s]\" %\n            (\n                input_variable_path[0],\n                invalid_values,\n                \", \".join(map(str, these_allowed_values))\n            )\n        )\n    elif (isinstance(input_values, dict)\n            and not set(\n                input_values.keys()).issubset(set(these_allowed_values))):\n        invalid_values = \", \".join(\n            map(str, set(input_values.keys()) - set(these_allowed_values)))\n        raise ApiValueError(\n            \"Invalid keys in `%s` [%s], must be a subset of [%s]\" %\n            (\n                input_variable_path[0],\n                invalid_values,\n                \", \".join(map(str, these_allowed_values))\n            )\n        )\n    elif (not isinstance(input_values, (list, dict))\n            and input_values not in these_allowed_values):\n        raise ApiValueError(\n            \"Invalid value for `%s` (%s), must be one of %s\" %\n            (\n                input_variable_path[0],\n                input_values,\n                these_allowed_values\n            )\n        )\n\n\ndef is_json_validation_enabled(schema_keyword, configuration=None):\n    \"\"\"Returns true if JSON schema validation is enabled for the specified\n    validation keyword. This can be used to skip JSON schema structural validation\n    as requested in the configuration.\n\n    Args:\n        schema_keyword (string): the name of a JSON schema validation keyword.\n        configuration (Configuration): the configuration class.\n    \"\"\"\n\n    return (configuration is None or\n        not hasattr(configuration, '_disabled_client_side_validations') or\n        schema_keyword not in configuration._disabled_client_side_validations)\n\n\ndef check_validations(\n        validations, input_variable_path, input_values,\n        configuration=None):\n    \"\"\"Raises an exception if the input_values are invalid\n\n    Args:\n        validations (dict): the validation dictionary.\n        input_variable_path (tuple): the path to the input variable.\n        input_values (list/str/int/float/date/datetime): the values that we\n            are checking.\n        configuration (Configuration): the configuration class.\n    \"\"\"\n\n    if input_values is None:\n        return\n\n    current_validations = validations[input_variable_path]\n    if (is_json_validation_enabled('multipleOf', configuration) and\n            'multiple_of' in current_validations and\n            isinstance(input_values, (int, float)) and\n            not (float(input_values) / current_validations['multiple_of']).is_integer()):\n        # Note 'multipleOf' will be as good as the floating point arithmetic.\n        raise ApiValueError(\n            \"Invalid value for `%s`, value must be a multiple of \"\n            \"`%s`\" % (\n                input_variable_path[0],\n                current_validations['multiple_of']\n            )\n        )\n\n    if (is_json_validation_enabled('maxLength', configuration) and\n            'max_length' in current_validations and\n            len(input_values) > current_validations['max_length']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, length must be less than or equal to \"\n            \"`%s`\" % (\n                input_variable_path[0],\n                current_validations['max_length']\n            )\n        )\n\n    if (is_json_validation_enabled('minLength', configuration) and\n            'min_length' in current_validations and\n            len(input_values) < current_validations['min_length']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, length must be greater than or equal to \"\n            \"`%s`\" % (\n                input_variable_path[0],\n                current_validations['min_length']\n            )\n        )\n\n    if (is_json_validation_enabled('maxItems', configuration) and\n            'max_items' in current_validations and\n            len(input_values) > current_validations['max_items']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, number of items must be less than or \"\n            \"equal to `%s`\" % (\n                input_variable_path[0],\n                current_validations['max_items']\n            )\n        )\n\n    if (is_json_validation_enabled('minItems', configuration) and\n            'min_items' in current_validations and\n            len(input_values) < current_validations['min_items']):\n        raise ValueError(\n            \"Invalid value for `%s`, number of items must be greater than or \"\n            \"equal to `%s`\" % (\n                input_variable_path[0],\n                current_validations['min_items']\n            )\n        )\n\n    items = ('exclusive_maximum', 'inclusive_maximum', 'exclusive_minimum',\n             'inclusive_minimum')\n    if (any(item in current_validations for item in items)):\n        if isinstance(input_values, list):\n            max_val = max(input_values)\n            min_val = min(input_values)\n        elif isinstance(input_values, dict):\n            max_val = max(input_values.values())\n            min_val = min(input_values.values())\n        else:\n            max_val = input_values\n            min_val = input_values\n\n    if (is_json_validation_enabled('exclusiveMaximum', configuration) and\n            'exclusive_maximum' in current_validations and\n            max_val >= current_validations['exclusive_maximum']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, must be a value less than `%s`\" % (\n                input_variable_path[0],\n                current_validations['exclusive_maximum']\n            )\n        )\n\n    if (is_json_validation_enabled('maximum', configuration) and\n            'inclusive_maximum' in current_validations and\n            max_val > current_validations['inclusive_maximum']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, must be a value less than or equal to \"\n            \"`%s`\" % (\n                input_variable_path[0],\n                current_validations['inclusive_maximum']\n            )\n        )\n\n    if (is_json_validation_enabled('exclusiveMinimum', configuration) and\n            'exclusive_minimum' in current_validations and\n            min_val <= current_validations['exclusive_minimum']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, must be a value greater than `%s`\" %\n            (\n                input_variable_path[0],\n                current_validations['exclusive_maximum']\n            )\n        )\n\n    if (is_json_validation_enabled('minimum', configuration) and\n            'inclusive_minimum' in current_validations and\n            min_val < current_validations['inclusive_minimum']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, must be a value greater than or equal \"\n            \"to `%s`\" % (\n                input_variable_path[0],\n                current_validations['inclusive_minimum']\n            )\n        )\n    flags = current_validations.get('regex', {}).get('flags', 0)\n    if (is_json_validation_enabled('pattern', configuration) and\n            'regex' in current_validations and\n            not re.search(current_validations['regex']['pattern'],\n                          input_values, flags=flags)):\n        err_msg = r\"Invalid value for `%s`, must match regular expression `%s`\" % (\n                    input_variable_path[0],\n                    current_validations['regex']['pattern']\n                )\n        if flags != 0:\n            # Don't print the regex flags if the flags are not\n            # specified in the OAS document.\n            err_msg = r\"%s with flags=`%s`\" % (err_msg, flags)\n        raise ApiValueError(err_msg)\n\n\ndef order_response_types(required_types):\n    \"\"\"Returns the required types sorted in coercion order\n\n    Args:\n        required_types (list/tuple): collection of classes or instance of\n            list or dict with class information inside it.\n\n    Returns:\n        (list): coercion order sorted collection of classes or instance\n            of list or dict with class information inside it.\n    \"\"\"\n\n    def index_getter(class_or_instance):\n        if isinstance(class_or_instance, list):\n            return COERCION_INDEX_BY_TYPE[list]\n        elif isinstance(class_or_instance, dict):\n            return COERCION_INDEX_BY_TYPE[dict]\n        elif (inspect.isclass(class_or_instance)\n                and issubclass(class_or_instance, ModelComposed)):\n            return COERCION_INDEX_BY_TYPE[ModelComposed]\n        elif (inspect.isclass(class_or_instance)\n                and issubclass(class_or_instance, ModelNormal)):\n            return COERCION_INDEX_BY_TYPE[ModelNormal]\n        elif (inspect.isclass(class_or_instance)\n                and issubclass(class_or_instance, ModelSimple)):\n            return COERCION_INDEX_BY_TYPE[ModelSimple]\n        elif class_or_instance in COERCION_INDEX_BY_TYPE:\n            return COERCION_INDEX_BY_TYPE[class_or_instance]\n        raise ApiValueError(\"Unsupported type: %s\" % class_or_instance)\n\n    sorted_types = sorted(\n        required_types,\n        key=lambda class_or_instance: index_getter(class_or_instance)\n    )\n    return sorted_types\n\n\ndef remove_uncoercible(required_types_classes, current_item, spec_property_naming,\n                       must_convert=True):\n    \"\"\"Only keeps the type conversions that are possible\n\n    Args:\n        required_types_classes (tuple): tuple of classes that are required\n                          these should be ordered by COERCION_INDEX_BY_TYPE\n        spec_property_naming (bool): True if the variable names in the input\n            data are serialized names as specified in the OpenAPI document.\n            False if the variables names in the input data are python\n            variable names in PEP-8 snake case.\n        current_item (any): the current item (input data) to be converted\n\n    Keyword Args:\n        must_convert (bool): if True the item to convert is of the wrong\n                          type and we want a big list of coercibles\n                          if False, we want a limited list of coercibles\n\n    Returns:\n        (list): the remaining coercible required types, classes only\n    \"\"\"\n    current_type_simple = get_simple_class(current_item)\n\n    results_classes = []\n    for required_type_class in required_types_classes:\n        # convert our models to OpenApiModel\n        required_type_class_simplified = required_type_class\n        if isinstance(required_type_class_simplified, type):\n            if issubclass(required_type_class_simplified, ModelComposed):\n                required_type_class_simplified = ModelComposed\n            elif issubclass(required_type_class_simplified, ModelNormal):\n                required_type_class_simplified = ModelNormal\n            elif issubclass(required_type_class_simplified, ModelSimple):\n                required_type_class_simplified = ModelSimple\n\n        if required_type_class_simplified == current_type_simple:\n            # don't consider converting to one's own class\n            continue\n\n        class_pair = (current_type_simple, required_type_class_simplified)\n        if must_convert and class_pair in COERCIBLE_TYPE_PAIRS[spec_property_naming]:\n            results_classes.append(required_type_class)\n        elif class_pair in UPCONVERSION_TYPE_PAIRS:\n            results_classes.append(required_type_class)\n    return results_classes\n\ndef get_discriminated_classes(cls):\n    \"\"\"\n    Returns all the classes that a discriminator converts to\n    TODO: lru_cache this\n    \"\"\"\n    possible_classes = []\n    key = list(cls.discriminator.keys())[0]\n    if is_type_nullable(cls):\n        possible_classes.append(cls)\n    for discr_cls in cls.discriminator[key].values():\n        if hasattr(discr_cls, 'discriminator') and discr_cls.discriminator is not None:\n            possible_classes.extend(get_discriminated_classes(discr_cls))\n        else:\n            possible_classes.append(discr_cls)\n    return possible_classes\n\n\ndef get_possible_classes(cls, from_server_context):\n    # TODO: lru_cache this\n    possible_classes = [cls]\n    if from_server_context:\n        return possible_classes\n    if hasattr(cls, 'discriminator') and cls.discriminator is not None:\n        possible_classes = []\n        possible_classes.extend(get_discriminated_classes(cls))\n    elif issubclass(cls, ModelComposed):\n        possible_classes.extend(composed_model_input_classes(cls))\n    return possible_classes\n\n\ndef get_required_type_classes(required_types_mixed, spec_property_naming):\n    \"\"\"Converts the tuple required_types into a tuple and a dict described\n    below\n\n    Args:\n        required_types_mixed (tuple/list): will contain either classes or\n            instance of list or dict\n        spec_property_naming (bool): if True these values came from the\n            server, and we use the data types in our endpoints.\n            If False, we are client side and we need to include\n            oneOf and discriminator classes inside the data types in our endpoints\n\n    Returns:\n        (valid_classes, dict_valid_class_to_child_types_mixed):\n            valid_classes (tuple): the valid classes that the current item\n                                   should be\n            dict_valid_class_to_child_types_mixed (dict):\n                valid_class (class): this is the key\n                child_types_mixed (list/dict/tuple): describes the valid child\n                    types\n    \"\"\"\n    valid_classes = []\n    child_req_types_by_current_type = {}\n    for required_type in required_types_mixed:\n        if isinstance(required_type, list):\n            valid_classes.append(list)\n            child_req_types_by_current_type[list] = required_type\n        elif isinstance(required_type, tuple):\n            valid_classes.append(tuple)\n            child_req_types_by_current_type[tuple] = required_type\n        elif isinstance(required_type, dict):\n            valid_classes.append(dict)\n            child_req_types_by_current_type[dict] = required_type[str]\n        else:\n            valid_classes.extend(get_possible_classes(required_type, spec_property_naming))\n    return tuple(valid_classes), child_req_types_by_current_type\n\n\ndef change_keys_js_to_python(input_dict, model_class):\n    \"\"\"\n    Converts from javascript_key keys in the input_dict to python_keys in\n    the output dict using the mapping in model_class.\n    If the input_dict contains a key which does not declared in the model_class,\n    the key is added to the output dict as is. The assumption is the model_class\n    may have undeclared properties (additionalProperties attribute in the OAS\n    document).\n    \"\"\"\n\n    if getattr(model_class, 'attribute_map', None) is None:\n        return input_dict\n    output_dict = {}\n    reversed_attr_map = {value: key for key, value in\n                         model_class.attribute_map.items()}\n    for javascript_key, value in input_dict.items():\n        python_key = reversed_attr_map.get(javascript_key)\n        if python_key is None:\n            # if the key is unknown, it is in error or it is an\n            # additionalProperties variable\n            python_key = javascript_key\n        output_dict[python_key] = value\n    return output_dict\n\n\ndef get_type_error(var_value, path_to_item, valid_classes, key_type=False):\n    error_msg = type_error_message(\n        var_name=path_to_item[-1],\n        var_value=var_value,\n        valid_classes=valid_classes,\n        key_type=key_type\n    )\n    return ApiTypeError(\n        error_msg,\n        path_to_item=path_to_item,\n        valid_classes=valid_classes,\n        key_type=key_type\n    )\n\n\ndef deserialize_primitive(data, klass, path_to_item):\n    \"\"\"Deserializes string to primitive type.\n\n    :param data: str/int/float\n    :param klass: str/class the class to convert to\n\n    :return: int, float, str, bool, date, datetime\n    \"\"\"\n    additional_message = \"\"\n    try:\n        if klass in {datetime, date}:\n            additional_message = (\n                \"If you need your parameter to have a fallback \"\n                \"string value, please set its type as `type: {}` in your \"\n                \"spec. That allows the value to be any type. \"\n            )\n            if klass == datetime:\n                if len(data) < 8:\n                    raise ValueError(\"This is not a datetime\")\n                # The string should be in iso8601 datetime format.\n                parsed_datetime = parse(data)\n                date_only = (\n                    parsed_datetime.hour == 0 and\n                    parsed_datetime.minute == 0 and\n                    parsed_datetime.second == 0 and\n                    parsed_datetime.tzinfo is None and\n                    8 <= len(data) <= 10\n                )\n                if date_only:\n                    raise ValueError(\"This is a date, not a datetime\")\n                return parsed_datetime\n            elif klass == date:\n                if len(data) < 8:\n                    raise ValueError(\"This is not a date\")\n                return parse(data).date()\n        else:\n            converted_value = klass(data)\n            if isinstance(data, str) and klass == float:\n                if str(converted_value) != data:\n                    # '7' -> 7.0 -> '7.0' != '7'\n                    raise ValueError('This is not a float')\n            return converted_value\n    except (OverflowError, ValueError) as ex:\n        # parse can raise OverflowError\n        raise ApiValueError(\n            \"{0}Failed to parse {1} as {2}\".format(\n                additional_message, repr(data), klass.__name__\n            ),\n            path_to_item=path_to_item\n        ) from ex\n\n\ndef get_discriminator_class(model_class,\n                            discr_name,\n                            discr_value, cls_visited):\n    \"\"\"Returns the child class specified by the discriminator.\n\n    Args:\n        model_class (OpenApiModel): the model class.\n        discr_name (string): the name of the discriminator property.\n        discr_value (any): the discriminator value.\n        cls_visited (list): list of model classes that have been visited.\n            Used to determine the discriminator class without\n            visiting circular references indefinitely.\n\n    Returns:\n        used_model_class (class/None): the chosen child class that will be used\n            to deserialize the data, for example dog.Dog.\n            If a class is not found, None is returned.\n    \"\"\"\n\n    if model_class in cls_visited:\n        # The class has already been visited and no suitable class was found.\n        return None\n    cls_visited.append(model_class)\n    used_model_class = None\n    if discr_name in model_class.discriminator:\n        class_name_to_discr_class = model_class.discriminator[discr_name]\n        used_model_class = class_name_to_discr_class.get(discr_value)\n    if used_model_class is None:\n        # We didn't find a discriminated class in class_name_to_discr_class.\n        # So look in the ancestor or descendant discriminators\n        # The discriminator mapping may exist in a descendant (anyOf, oneOf)\n        # or ancestor (allOf).\n        # Ancestor example: in the GrandparentAnimal -> ParentPet -> ChildCat\n        #   hierarchy, the discriminator mappings may be defined at any level\n        #   in the hierarchy.\n        # Descendant example:  mammal -> whale/zebra/Pig -> BasquePig/DanishPig\n        #   if we try to make BasquePig from mammal, we need to travel through\n        #   the oneOf descendant discriminators to find BasquePig\n        descendant_classes =  model_class._composed_schemas.get('oneOf', ()) + \\\n            model_class._composed_schemas.get('anyOf', ())\n        ancestor_classes = model_class._composed_schemas.get('allOf', ())\n        possible_classes = descendant_classes + ancestor_classes\n        for cls in possible_classes:\n            # Check if the schema has inherited discriminators.\n            if hasattr(cls, 'discriminator') and cls.discriminator is not None:\n                used_model_class = get_discriminator_class(\n                                    cls, discr_name, discr_value, cls_visited)\n                if used_model_class is not None:\n                    return used_model_class\n    return used_model_class\n\n\ndef deserialize_model(model_data, model_class, path_to_item, check_type,\n                      configuration, spec_property_naming):\n    \"\"\"Deserializes model_data to model instance.\n\n    Args:\n        model_data (int/str/float/bool/none_type/list/dict): data to instantiate the model\n        model_class (OpenApiModel): the model class\n        path_to_item (list): path to the model in the received data\n        check_type (bool): whether to check the data tupe for the values in\n            the model\n        configuration (Configuration): the instance to use to convert files\n        spec_property_naming (bool): True if the variable names in the input\n            data are serialized names as specified in the OpenAPI document.\n            False if the variables names in the input data are python\n            variable names in PEP-8 snake case.\n\n    Returns:\n        model instance\n\n    Raise:\n        ApiTypeError\n        ApiValueError\n        ApiKeyError\n    \"\"\"\n\n    kw_args = dict(_check_type=check_type,\n                   _path_to_item=path_to_item,\n                   _configuration=configuration,\n                   _spec_property_naming=spec_property_naming)\n\n    if issubclass(model_class, ModelSimple):\n        return model_class(model_data, **kw_args)\n    elif isinstance(model_data, list):\n        return model_class(*model_data, **kw_args)\n    if isinstance(model_data, dict):\n        kw_args.update(model_data)\n        return model_class(**kw_args)\n    elif isinstance(model_data, PRIMITIVE_TYPES):\n        return model_class(model_data, **kw_args)\n\n\ndef deserialize_file(response_data, configuration, content_disposition=None):\n    \"\"\"Deserializes body to file\n\n    Saves response body into a file in a temporary folder,\n    using the filename from the `Content-Disposition` header if provided.\n\n    Args:\n        param response_data (str):  the file data to write\n        configuration (Configuration): the instance to use to convert files\n\n    Keyword Args:\n        content_disposition (str):  the value of the Content-Disposition\n            header\n\n    Returns:\n        (file_type): the deserialized file which is open\n            The user is responsible for closing and reading the file\n    \"\"\"\n    fd, path = tempfile.mkstemp(dir=configuration.temp_folder_path)\n    os.close(fd)\n    os.remove(path)\n\n    if content_disposition:\n        filename = re.search(r'filename=[\\'\"]?([^\\'\"\\s]+)[\\'\"]?',\n                             content_disposition).group(1)\n        path = os.path.join(os.path.dirname(path), filename)\n\n    with open(path, \"wb\") as f:\n        if isinstance(response_data, str):\n            # change str to bytes so we can write it\n            response_data = response_data.encode('utf-8')\n        f.write(response_data)\n\n    f = open(path, \"rb\")\n    return f\n\n\ndef attempt_convert_item(input_value, valid_classes, path_to_item,\n                         configuration, spec_property_naming, key_type=False,\n                         must_convert=False, check_type=True):\n    \"\"\"\n    Args:\n        input_value (any): the data to convert\n        valid_classes (any): the classes that are valid\n        path_to_item (list): the path to the item to convert\n        configuration (Configuration): the instance to use to convert files\n        spec_property_naming (bool): True if the variable names in the input\n            data are serialized names as specified in the OpenAPI document.\n            False if the variables names in the input data are python\n            variable names in PEP-8 snake case.\n        key_type (bool): if True we need to convert a key type (not supported)\n        must_convert (bool): if True we must convert\n        check_type (bool): if True we check the type or the returned data in\n            ModelComposed/ModelNormal/ModelSimple instances\n\n    Returns:\n        instance (any) the fixed item\n\n    Raises:\n        ApiTypeError\n        ApiValueError\n        ApiKeyError\n    \"\"\"\n    valid_classes_ordered = order_response_types(valid_classes)\n    valid_classes_coercible = remove_uncoercible(\n        valid_classes_ordered, input_value, spec_property_naming)\n    if not valid_classes_coercible or key_type:\n        # we do not handle keytype errors, json will take care\n        # of this for us\n        if configuration is None or not configuration.discard_unknown_keys:\n            raise get_type_error(input_value, path_to_item, valid_classes,\n                                 key_type=key_type)\n    for valid_class in valid_classes_coercible:\n        try:\n            if issubclass(valid_class, OpenApiModel):\n                return deserialize_model(input_value, valid_class,\n                                         path_to_item, check_type,\n                                         configuration, spec_property_naming)\n            elif valid_class == file_type:\n                return deserialize_file(input_value, configuration)\n            return deserialize_primitive(input_value, valid_class,\n                                         path_to_item)\n        except (ApiTypeError, ApiValueError, ApiKeyError) as conversion_exc:\n            if must_convert:\n                raise conversion_exc\n            # if we have conversion errors when must_convert == False\n            # we ignore the exception and move on to the next class\n            continue\n    # we were unable to convert, must_convert == False\n    return input_value\n\n\ndef is_type_nullable(input_type):\n    \"\"\"\n    Returns true if None is an allowed value for the specified input_type.\n\n    A type is nullable if at least one of the following conditions is true:\n    1. The OAS 'nullable' attribute has been specified,\n    1. The type is the 'null' type,\n    1. The type is a anyOf/oneOf composed schema, and a child schema is\n       the 'null' type.\n    Args:\n        input_type (type): the class of the input_value that we are\n            checking\n    Returns:\n        bool\n    \"\"\"\n    if input_type is none_type:\n        return True\n    if issubclass(input_type, OpenApiModel) and input_type._nullable:\n        return True\n    if issubclass(input_type, ModelComposed):\n        # If oneOf/anyOf, check if the 'null' type is one of the allowed types.\n        for t in input_type._composed_schemas.get('oneOf', ()):\n            if is_type_nullable(t): return True\n        for t in input_type._composed_schemas.get('anyOf', ()):\n            if is_type_nullable(t): return True\n    return False\n\n\ndef is_valid_type(input_class_simple, valid_classes):\n    \"\"\"\n    Args:\n        input_class_simple (class): the class of the input_value that we are\n            checking\n        valid_classes (tuple): the valid classes that the current item\n            should be\n    Returns:\n        bool\n    \"\"\"\n    valid_type = input_class_simple in valid_classes\n    if not valid_type and (\n            issubclass(input_class_simple, OpenApiModel) or\n            input_class_simple is none_type):\n        for valid_class in valid_classes:\n            if input_class_simple is none_type and is_type_nullable(valid_class):\n                # Schema is oneOf/anyOf and the 'null' type is one of the allowed types.\n                return True\n            if not (issubclass(valid_class, OpenApiModel) and valid_class.discriminator):\n                continue\n            discr_propertyname_py = list(valid_class.discriminator.keys())[0]\n            discriminator_classes = (\n                valid_class.discriminator[discr_propertyname_py].values()\n            )\n            valid_type = is_valid_type(input_class_simple, discriminator_classes)\n            if valid_type:\n                return True\n    return valid_type\n\n\ndef validate_and_convert_types(input_value, required_types_mixed, path_to_item,\n                               spec_property_naming, _check_type, configuration=None):\n    \"\"\"Raises a TypeError is there is a problem, otherwise returns value\n\n    Args:\n        input_value (any): the data to validate/convert\n        required_types_mixed (list/dict/tuple): A list of\n            valid classes, or a list tuples of valid classes, or a dict where\n            the value is a tuple of value classes\n        path_to_item: (list) the path to the data being validated\n            this stores a list of keys or indices to get to the data being\n            validated\n        spec_property_naming (bool): True if the variable names in the input\n            data are serialized names as specified in the OpenAPI document.\n            False if the variables names in the input data are python\n            variable names in PEP-8 snake case.\n        _check_type: (boolean) if true, type will be checked and conversion\n            will be attempted.\n        configuration: (Configuration): the configuration class to use\n            when converting file_type items.\n            If passed, conversion will be attempted when possible\n            If not passed, no conversions will be attempted and\n            exceptions will be raised\n\n    Returns:\n        the correctly typed value\n\n    Raises:\n        ApiTypeError\n    \"\"\"\n    results = get_required_type_classes(required_types_mixed, spec_property_naming)\n    valid_classes, child_req_types_by_current_type = results\n\n    input_class_simple = get_simple_class(input_value)\n    valid_type = is_valid_type(input_class_simple, valid_classes)\n    if not valid_type:\n        if configuration:\n            # if input_value is not valid_type try to convert it\n            converted_instance = attempt_convert_item(\n                input_value,\n                valid_classes,\n                path_to_item,\n                configuration,\n                spec_property_naming,\n                key_type=False,\n                must_convert=True,\n                check_type=_check_type\n            )\n            return converted_instance\n        else:\n            raise get_type_error(input_value, path_to_item, valid_classes,\n                                 key_type=False)\n\n    # input_value's type is in valid_classes\n    if len(valid_classes) > 1 and configuration:\n        # there are valid classes which are not the current class\n        valid_classes_coercible = remove_uncoercible(\n            valid_classes, input_value, spec_property_naming, must_convert=False)\n        if valid_classes_coercible:\n            converted_instance = attempt_convert_item(\n                input_value,\n                valid_classes_coercible,\n                path_to_item,\n                configuration,\n                spec_property_naming,\n                key_type=False,\n                must_convert=False,\n                check_type=_check_type\n            )\n            return converted_instance\n\n    if child_req_types_by_current_type == {}:\n        # all types are of the required types and there are no more inner\n        # variables left to look at\n        return input_value\n    inner_required_types = child_req_types_by_current_type.get(\n        type(input_value)\n    )\n    if inner_required_types is None:\n        # for this type, there are not more inner variables left to look at\n        return input_value\n    if isinstance(input_value, list):\n        if input_value == []:\n            # allow an empty list\n            return input_value\n        for index, inner_value in enumerate(input_value):\n            inner_path = list(path_to_item)\n            inner_path.append(index)\n            input_value[index] = validate_and_convert_types(\n                inner_value,\n                inner_required_types,\n                inner_path,\n                spec_property_naming,\n                _check_type,\n                configuration=configuration\n            )\n    elif isinstance(input_value, dict):\n        if input_value == {}:\n            # allow an empty dict\n            return input_value\n        for inner_key, inner_val in input_value.items():\n            inner_path = list(path_to_item)\n            inner_path.append(inner_key)\n            if get_simple_class(inner_key) != str:\n                raise get_type_error(inner_key, inner_path, valid_classes,\n                                     key_type=True)\n            input_value[inner_key] = validate_and_convert_types(\n                inner_val,\n                inner_required_types,\n                inner_path,\n                spec_property_naming,\n                _check_type,\n                configuration=configuration\n            )\n    return input_value\n\n\ndef model_to_dict(model_instance, serialize=True):\n    \"\"\"Returns the model properties as a dict\n\n    Args:\n        model_instance (one of your model instances): the model instance that\n            will be converted to a dict.\n\n    Keyword Args:\n        serialize (bool): if True, the keys in the dict will be values from\n            attribute_map\n    \"\"\"\n    result = {}\n\n    model_instances = [model_instance]\n    if model_instance._composed_schemas:\n        model_instances.extend(model_instance._composed_instances)\n    for model_instance in model_instances:\n        for attr, value in model_instance._data_store.items():\n            if serialize:\n                # we use get here because additional property key names do not\n                # exist in attribute_map\n                attr = model_instance.attribute_map.get(attr, attr)\n            if isinstance(value, list):\n               if not value:\n                   # empty list or None\n                   result[attr] = value\n               else:\n                   res = []\n                   for v in value:\n                       if isinstance(v, PRIMITIVE_TYPES) or v is None:\n                           res.append(v)\n                       elif isinstance(v, ModelSimple):\n                           res.append(v.value)\n                       else:\n                           res.append(model_to_dict(v, serialize=serialize))\n                   result[attr] = res\n            elif isinstance(value, dict):\n                result[attr] = dict(map(\n                    lambda item: (item[0],\n                                  model_to_dict(item[1], serialize=serialize))\n                    if hasattr(item[1], '_data_store') else item,\n                    value.items()\n                ))\n            elif isinstance(value, ModelSimple):\n                result[attr] = value.value\n            elif hasattr(value, '_data_store'):\n                result[attr] = model_to_dict(value, serialize=serialize)\n            else:\n                result[attr] = value\n\n    return result\n\n\ndef type_error_message(var_value=None, var_name=None, valid_classes=None,\n                       key_type=None):\n    \"\"\"\n    Keyword Args:\n        var_value (any): the variable which has the type_error\n        var_name (str): the name of the variable which has the typ error\n        valid_classes (tuple): the accepted classes for current_item's\n                                  value\n        key_type (bool): False if our value is a value in a dict\n                         True if it is a key in a dict\n                         False if our item is an item in a list\n    \"\"\"\n    key_or_value = 'value'\n    if key_type:\n        key_or_value = 'key'\n    valid_classes_phrase = get_valid_classes_phrase(valid_classes)\n    msg = (\n        \"Invalid type for variable '{0}'. Required {1} type {2} and \"\n        \"passed type was {3}\".format(\n            var_name,\n            key_or_value,\n            valid_classes_phrase,\n            type(var_value).__name__,\n        )\n    )\n    return msg\n\n\ndef get_valid_classes_phrase(input_classes):\n    \"\"\"Returns a string phrase describing what types are allowed\n    \"\"\"\n    all_classes = list(input_classes)\n    all_classes = sorted(all_classes, key=lambda cls: cls.__name__)\n    all_class_names = [cls.__name__ for cls in all_classes]\n    if len(all_class_names) == 1:\n        return 'is {0}'.format(all_class_names[0])\n    return \"is one of [{0}]\".format(\", \".join(all_class_names))\n\n\ndef convert_js_args_to_python_args(fn):\n    from functools import wraps\n    @wraps(fn)\n    def wrapped_init(_self, *args, **kwargs):\n        \"\"\"\n        An attribute named `self` received from the api will conflicts with the reserved `self`\n        parameter of a class method. During generation, `self` attributes are mapped\n        to `_self` in models. Here, we name `_self` instead of `self` to avoid conflicts.\n        \"\"\"\n        spec_property_naming = kwargs.get('_spec_property_naming', False)\n        if spec_property_naming:\n            kwargs = change_keys_js_to_python(kwargs, _self.__class__)\n        return fn(_self, *args, **kwargs)\n    return wrapped_init\n\n\ndef get_allof_instances(self, model_args, constant_args):\n    \"\"\"\n    Args:\n        self: the class we are handling\n        model_args (dict): var_name to var_value\n            used to make instances\n        constant_args (dict): var_name to var_value\n            used to make instances\n\n    Returns\n        composed_instances (list)\n    \"\"\"\n    composed_instances = []\n    for allof_class in self._composed_schemas['allOf']:\n\n        # no need to handle changing js keys to python because\n        # for composed schemas, allof parameters are included in the\n        # composed schema and were changed to python keys in __new__\n        # extract a dict of only required keys from fixed_model_args\n        kwargs = {}\n        var_names = set(allof_class.openapi_types.keys())\n        for var_name in var_names:\n            if var_name in model_args:\n                kwargs[var_name] = model_args[var_name]\n\n        # and use it to make the instance\n        kwargs.update(constant_args)\n        try:\n            allof_instance = allof_class(**kwargs)\n            composed_instances.append(allof_instance)\n        except Exception as ex:\n            raise ApiValueError(\n                \"Invalid inputs given to generate an instance of '%s'. The \"\n                \"input data was invalid for the allOf schema '%s' in the composed \"\n                \"schema '%s'. Error=%s\" % (\n                    allof_class.__name__,\n                    allof_class.__name__,\n                    self.__class__.__name__,\n                    str(ex)\n                )\n            ) from ex\n    return composed_instances\n\n\ndef get_oneof_instance(cls, model_kwargs, constant_kwargs, model_arg=None):\n    \"\"\"\n    Find the oneOf schema that matches the input data (e.g. payload).\n    If exactly one schema matches the input data, an instance of that schema\n    is returned.\n    If zero or more than one schema match the input data, an exception is raised.\n    In OAS 3.x, the payload MUST, by validation, match exactly one of the\n    schemas described by oneOf.\n\n    Args:\n        cls: the class we are handling\n        model_kwargs (dict): var_name to var_value\n            The input data, e.g. the payload that must match a oneOf schema\n            in the OpenAPI document.\n        constant_kwargs (dict): var_name to var_value\n            args that every model requires, including configuration, server\n            and path to item.\n\n    Kwargs:\n        model_arg: (int, float, bool, str, date, datetime, ModelSimple, None):\n            the value to assign to a primitive class or ModelSimple class\n            Notes:\n            - this is only passed in when oneOf includes types which are not object\n            - None is used to suppress handling of model_arg, nullable models are handled in __new__\n\n    Returns\n        oneof_instance (instance)\n    \"\"\"\n    if len(cls._composed_schemas['oneOf']) == 0:\n        return None\n\n    oneof_instances = []\n    # Iterate over each oneOf schema and determine if the input data\n    # matches the oneOf schemas.\n    for oneof_class in cls._composed_schemas['oneOf']:\n        # The composed oneOf schema allows the 'null' type and the input data\n        # is the null value. This is a OAS >= 3.1 feature.\n        if oneof_class is none_type:\n            # skip none_types because we are deserializing dict data.\n            # none_type deserialization is handled in the __new__ method\n            continue\n\n        single_value_input = allows_single_value_input(oneof_class)\n\n        if not single_value_input:\n            # transform js keys from input data to python keys in fixed_model_args\n            fixed_model_args = change_keys_js_to_python(\n                model_kwargs, oneof_class)\n\n            # Extract a dict with the properties that are declared in the oneOf schema.\n            # Undeclared properties (e.g. properties that are allowed because of the\n            # additionalProperties attribute in the OAS document) are not added to\n            # the dict.\n            kwargs = {}\n            var_names = set(oneof_class.openapi_types.keys())\n            for var_name in var_names:\n                if var_name in fixed_model_args:\n                    kwargs[var_name] = fixed_model_args[var_name]\n\n            # do not try to make a model with no input args\n            if len(kwargs) == 0:\n                continue\n\n            # and use it to make the instance\n            kwargs.update(constant_kwargs)\n\n        try:\n            if not single_value_input:\n                oneof_instance = oneof_class(**kwargs)\n            else:\n                if issubclass(oneof_class, ModelSimple):\n                    oneof_instance = oneof_class(model_arg, **constant_kwargs)\n                elif oneof_class in PRIMITIVE_TYPES:\n                    oneof_instance = validate_and_convert_types(\n                        model_arg,\n                        (oneof_class,),\n                        constant_kwargs['_path_to_item'],\n                        constant_kwargs['_spec_property_naming'],\n                        constant_kwargs['_check_type'],\n                        configuration=constant_kwargs['_configuration']\n                    )\n            oneof_instances.append(oneof_instance)\n        except Exception:\n            pass\n    if len(oneof_instances) == 0:\n        raise ApiValueError(\n            \"Invalid inputs given to generate an instance of %s. None \"\n            \"of the oneOf schemas matched the input data.\" %\n            cls.__name__\n        )\n    elif len(oneof_instances) > 1:\n        raise ApiValueError(\n            \"Invalid inputs given to generate an instance of %s. Multiple \"\n            \"oneOf schemas matched the inputs, but a max of one is allowed.\" %\n            cls.__name__\n        )\n    return oneof_instances[0]\n\n\ndef get_anyof_instances(self, model_args, constant_args):\n    \"\"\"\n    Args:\n        self: the class we are handling\n        model_args (dict): var_name to var_value\n            The input data, e.g. the payload that must match at least one\n            anyOf child schema in the OpenAPI document.\n        constant_args (dict): var_name to var_value\n            args that every model requires, including configuration, server\n            and path to item.\n\n    Returns\n        anyof_instances (list)\n    \"\"\"\n    anyof_instances = []\n    if len(self._composed_schemas['anyOf']) == 0:\n        return anyof_instances\n\n    for anyof_class in self._composed_schemas['anyOf']:\n        # The composed oneOf schema allows the 'null' type and the input data\n        # is the null value. This is a OAS >= 3.1 feature.\n        if anyof_class is none_type:\n            # skip none_types because we are deserializing dict data.\n            # none_type deserialization is handled in the __new__ method\n            continue\n\n        # transform js keys to python keys in fixed_model_args\n        fixed_model_args = change_keys_js_to_python(model_args, anyof_class)\n\n        # extract a dict of only required keys from these_model_vars\n        kwargs = {}\n        var_names = set(anyof_class.openapi_types.keys())\n        for var_name in var_names:\n            if var_name in fixed_model_args:\n                kwargs[var_name] = fixed_model_args[var_name]\n\n        # do not try to make a model with no input args\n        if len(kwargs) == 0:\n            continue\n\n        # and use it to make the instance\n        kwargs.update(constant_args)\n        try:\n            anyof_instance = anyof_class(**kwargs)\n            anyof_instances.append(anyof_instance)\n        except Exception:\n            pass\n    if len(anyof_instances) == 0:\n        raise ApiValueError(\n            \"Invalid inputs given to generate an instance of %s. None of the \"\n            \"anyOf schemas matched the inputs.\" %\n            self.__class__.__name__\n        )\n    return anyof_instances\n\n\ndef get_additional_properties_model_instances(\n        composed_instances, self):\n    additional_properties_model_instances = []\n    all_instances = [self]\n    all_instances.extend(composed_instances)\n    for instance in all_instances:\n        if instance.additional_properties_type is not None:\n            additional_properties_model_instances.append(instance)\n    return additional_properties_model_instances\n\n\ndef get_var_name_to_model_instances(self, composed_instances):\n    var_name_to_model_instances = {}\n    all_instances = [self]\n    all_instances.extend(composed_instances)\n    for instance in all_instances:\n        for var_name in instance.openapi_types:\n            if var_name not in var_name_to_model_instances:\n                var_name_to_model_instances[var_name] = [instance]\n            else:\n                var_name_to_model_instances[var_name].append(instance)\n    return var_name_to_model_instances\n\n\ndef get_unused_args(self, composed_instances, model_args):\n    unused_args = dict(model_args)\n    # arguments apssed to self were already converted to python names\n    # before __init__ was called\n    for var_name_py in self.attribute_map:\n        if var_name_py in unused_args:\n            del unused_args[var_name_py]\n    for instance in composed_instances:\n        if instance.__class__ in self._composed_schemas['allOf']:\n            for var_name_py in instance.attribute_map:\n                if var_name_py in unused_args:\n                    del unused_args[var_name_py]\n        else:\n            for var_name_js in instance.attribute_map.values():\n                if var_name_js in unused_args:\n                    del unused_args[var_name_js]\n    return unused_args\n\n\ndef validate_get_composed_info(constant_args, model_args, self):\n    \"\"\"\n    For composed schemas, generate schema instances for\n    all schemas in the oneOf/anyOf/allOf definition. If additional\n    properties are allowed, also assign those properties on\n    all matched schemas that contain additionalProperties.\n    Openapi schemas are python classes.\n\n    Exceptions are raised if:\n    - 0 or > 1 oneOf schema matches the model_args input data\n    - no anyOf schema matches the model_args input data\n    - any of the allOf schemas do not match the model_args input data\n\n    Args:\n        constant_args (dict): these are the args that every model requires\n        model_args (dict): these are the required and optional spec args that\n            were passed in to make this model\n        self (class): the class that we are instantiating\n            This class contains self._composed_schemas\n\n    Returns:\n        composed_info (list): length three\n            composed_instances (list): the composed instances which are not\n                self\n            var_name_to_model_instances (dict): a dict going from var_name\n                to the model_instance which holds that var_name\n                the model_instance may be self or an instance of one of the\n                classes in self.composed_instances()\n            additional_properties_model_instances (list): a list of the\n                model instances which have the property\n                additional_properties_type. This list can include self\n    \"\"\"\n    # create composed_instances\n    composed_instances = []\n    allof_instances = get_allof_instances(self, model_args, constant_args)\n    composed_instances.extend(allof_instances)\n    oneof_instance = get_oneof_instance(self.__class__, model_args, constant_args)\n    if oneof_instance is not None:\n        composed_instances.append(oneof_instance)\n    anyof_instances = get_anyof_instances(self, model_args, constant_args)\n    composed_instances.extend(anyof_instances)\n\n    # map variable names to composed_instances\n    var_name_to_model_instances = get_var_name_to_model_instances(\n        self, composed_instances)\n\n    # set additional_properties_model_instances\n    additional_properties_model_instances = (\n        get_additional_properties_model_instances(composed_instances, self)\n    )\n\n    # set any remaining values\n    unused_args = get_unused_args(self, composed_instances, model_args)\n    if len(unused_args) > 0 and \\\n            len(additional_properties_model_instances) == 0 and \\\n            (self._configuration is None or\n                not self._configuration.discard_unknown_keys):\n        raise ApiValueError(\n            \"Invalid input arguments input when making an instance of \"\n            \"class %s. Not all inputs were used. The unused input data \"\n            \"is %s\" % (self.__class__.__name__, unused_args)\n        )\n\n    # no need to add additional_properties to var_name_to_model_instances here\n    # because additional_properties_model_instances will direct us to that\n    # instance when we use getattr or setattr\n    # and we update var_name_to_model_instances in setattr\n\n    return [\n      composed_instances,\n      var_name_to_model_instances,\n      additional_properties_model_instances,\n      unused_args\n    ]\n        \n    \n\n\n    return\n        if not\n        \n    \n\n        :\n        \n        \n        \n    \n        \n    :\n        (\n    \n    if not:\n        \n    )\n    \n        \n"
  },
  "feature_stats": {
    "indices": [
      0,
      2,
      2149,
      395,
      5856,
      5196,
      8457,
      5704,
      4513,
      6545,
      6718
    ],
    "f_before": [
      79.76641845703125,
      0.0,
      0.0,
      0.0,
      0.7180318236351013,
      0.0,
      0.0,
      0.0,
      0.0,
      0.3479645550251007,
      0.0
    ],
    "f_after": [
      79.76641845703125,
      0.0,
      0.0,
      0.0,
      0.7180318236351013,
      0.0,
      0.0,
      0.0,
      0.0,
      0.3479645550251007,
      0.0
    ],
    "g_before": [
      0.0489840991795063,
      46.336944580078125,
      8.823064804077148,
      8.393472671508789,
      8.270086288452148,
      7.683588981628418,
      0.04108268395066261,
      7.3965373039245605,
      7.447697639465332,
      7.665126323699951,
      0.08716336637735367
    ],
    "g_after": [
      0.0489840991795063,
      46.336944580078125,
      8.823064804077148,
      8.393472671508789,
      8.270086288452148,
      7.683588981628418,
      0.04108268395066261,
      7.3965373039245605,
      7.447697639465332,
      7.665126323699951,
      0.08716336637735367
    ],
    "num_batches_for_stats": 10
  },
  "loss_summary": {
    "train_mean_loss": 8.258803450644017,
    "train_mean_l2": 6.574597416497767,
    "train_mean_l1": 3.1238317955732344,
    "num_steps": 2000,
    "num_batches": 2000
  },
  "feature_std_summary": {
    "plot_path": "outputs/plots/20251128-151520/feature_std_layer_12.html",
    "mean_std": 1.8976119756698608,
    "max_std": 67.16454315185547
  }
}