{
  "model_name": "google/gemma-2-2b-it",
  "layer_idx": 12,
  "command": "python main.py experiment.use_multi_contrast=true sae.loss_option=2 sae.loss_module=option2_loss sae.guidance_method=contrastive sae.guidance_coeff=1.0 sae.alpha_concept.code=0.08 sae.alpha_concept.harm=0.0 sae.alpha_concept.struct=0.0 sae.use_l0=true sae.l0_coeff=0.002353998651181063 sae.role_sep_coeff=0.006500000000000001",
  "sae": {
    "input_dim": 2304,
    "sae_dim": 9216,
    "fixed_v_cnt": 3,
    "batch_size": 3,
    "epochs": 2,
    "max_steps": 2000,
    "l1_coeff": 0.005,
    "l0_coeff": 0.002353998651181063,
    "use_l0": true,
    "concept_samples_per_label": 100,
    "loss_option": 2,
    "loss_module": "option2_loss",
    "concept_feature_indices": {
      "code": 0,
      "harm": 1,
      "struct": 2
    },
    "alpha_concept": {
      "code": 0.08,
      "harm": 0.0,
      "struct": 0.0
    },
    "positive_targets": {
      "code": 1,
      "harm": 1,
      "struct": 1
    },
    "guidance_method": "contrastive",
    "guidance_margin": 0.0,
    "guidance_coeff": 1.0,
    "guidance_mse_pos_value": 1.0,
    "guidance_mse_neg_value": 0.0,
    "jumprelu_bandwidth": 0.001,
    "jumprelu_init_threshold": 0.001,
    "role_sep_coeff": 0.006500000000000001
  },
  "gnn": {
    "use_gnn": true,
    "top_k": 10
  },
  "experiment": {
    "device": "cuda",
    "dataset_name": "wikitext",
    "dataset_config": "wikitext-2-raw-v1",
    "use_multi_contrast": true,
    "num_steering_samples_per_label": 10,
    "top_k_for_plot": 10,
    "layer_sweep": [
      12
    ],
    "strength_sweep": [
      15.0
    ]
  },
  "steering": {
    "label": "struct",
    "feature_idx": 2,
    "strength": 15.0,
    "hook_layer_idx": 11
  },
  "prompt": "﻿# -*- coding: utf-8 -*-\nimport pandas as pd\nfrom futu.common import RspHandlerBase\nfrom futu.quote.quote_query import *\n\n\nclass StockQuoteHandlerBase(RspHandlerBase):\n    \"\"\"\n    异步处理推送的订阅股票的报价。\n\n    .. code:: python\n\n        class StockQuoteTest(StockQuoteHandlerBase):\n            def on_recv_rsp(self, rsp_str):\n                ret_code, content = super(StockQuoteTest,self).on_recv_rsp(rsp_str)\n                if ret_code != RET_OK",
  "output": {
    "before": "﻿# -*- coding: utf-8 -*-\nimport pandas as pd\nfrom futu.common import RspHandlerBase\nfrom futu.quote.quote_query import *\n\n\nclass StockQuoteHandlerBase(RspHandlerBase):\n    \"\"\"\n    异步处理推送的订阅股票的报价。\n\n    .. code:: python\n\n        class StockQuoteTest(StockQuoteHandlerBase):\n            def on_recv_rsp(self, rsp_str):\n                ret_code, content = super(StockQuoteTest,self).on_recv_rsp(rsp_str)\n                if ret_code != RET_OK:\n                    print(\"StockQuoteTest: error, msg: %s\" % content)\n                    return RET_ERROR, content\n\n                print(\"StockQuoteTest \", content) # StockQuoteTest自己的处理逻辑\n\n                return RET_OK, content\n    \"\"\"\n    @classmethod\n    def parse_rsp_pb(cls, rsp_pb):\n        ret_code, msg, quote_list = StockQuoteQuery.unpack_rsp(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, msg\n        else:\n            return RET_OK, quote_list\n\n    def on_recv_rsp(self, rsp_pb):\n        \"\"\"\n        在收到实时报价推送后会回调到该函数，使用者需要在派生类中覆盖此方法\n\n        注意该回调是在独立子线程中\n\n        :param rsp_pb: 派生类中不需要直接处理该参数\n        :return: 参见get_stock_quote的返回值\n        \"\"\"\n        ret_code, content = self.parse_rsp_pb(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, content\n        else:\n            col_list = [\n                'code', 'data_date', 'data_time', 'last_price', 'open_price',\n                'high_price', 'low_price', 'prev_close_price', 'volume',\n                'turnover', 'turnover_rate', 'amplitude', 'suspension',\n                'listing_date', 'price_spread', 'dark_status', 'sec_status', 'strike_price',\n                'contract_size', 'open_interest', 'implied_volatility',\n                'premium', 'delta', 'gamma', 'vega', 'theta', 'rho',\n                'net_open_interest', 'expiry_date_distance', 'contract_nominal_value', \n                'owner_lot_multiplier', 'option_area_type', 'contract_multiplier',\n                'last_settle_price','position','position_change'\n            ]\n\n            col_list.extend(row[0] for row in pb_field_map_PreAfterMarketData_pre)\n            col_list.extend(row[0] for row in pb_field_map_PreAfterMarketData_after)\n\n            quote_frame_table = pd.DataFrame(content, columns=col_list)\n\n            return RET_OK, quote_frame_table\n\n\nclass OrderBookHandlerBase(RspHandlerBase):\n    \"\"\"\n    异步处理推送的实时摆盘。\n\n    .. code:: python\n\n        class OrderBookTest(OrderBookHandlerBase):\n            def on_recv_rsp(self, rsp_str):\n                ret_code, data = super(OrderBookTest,self).on_recv_rsp(rsp_str)\n                if ret_code != RET_OK:\n                    print(\"OrderBookTest: error, msg: %s\" % data)\n                    return RET_ERROR, data\n\n                print(\"OrderBookTest \", data) # OrderBookTest自己的处理逻辑\n\n                return RET_OK, content\n    \"\"\"\n    @classmethod\n    def parse_rsp_pb(cls, rsp_pb):\n        ret_code, msg, order_book = OrderBookQuery.unpack_rsp(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, msg\n        else:\n            return RET_OK, order_book\n\n    def on_recv_rsp(self, rsp_pb):\n        \"\"\"\n        在收到实摆盘数据推送后会回调到该函数，使用者需要在派生类中覆盖此方法\n\n        注意该回调是在独立子线程中\n\n        :param rsp_pb: 派生类中不需要直接处理该参数\n        :return: 参见get_order_book的返回值\n        \"\"\"\n        ret_code, content = self.parse_rsp_pb(rsp_pb)\n        if ret_code == RET_OK:\n            self.on_recv_log(content)\n\n        return ret_code, content\n\n\nclass CurKlineHandlerBase(RspHandlerBase):\n    \"\"\"\n    异步处理推送的k线数据。\n\n    .. code:: python\n\n        class CurKlineTest(CurKlineHandlerBase):\n            def on_recv_rsp(self, rsp_str):\n                ret_code, data = super(CurKlineTest,self).on_recv_rsp(rsp_str)\n                if ret_code != RET_OK:\n                    print(\"CurKlineTest: error, msg: %s\" % data)\n                    return RET_ERROR, data\n\n                print(\"CurKlineTest \", data) # CurKlineTest自己的处理逻辑\n\n                return RET_OK, content\n    \"\"\"\n    @classmethod\n    def parse_rsp_pb(cls, rsp_pb):\n        ret_code, msg, kline_list = CurKlinePush.unpack_rsp(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, msg\n        else:\n            return RET_OK, kline_list\n\n    def on_recv_rsp(self, rsp_pb):\n        \"\"\"\n        在收到实时k线数据推送后会回调到该函数，使用者需要在派生类中覆盖此方法\n\n        注意该回调是在独立子线程中\n\n        :param rsp_pb: 派生类中不需要直接处理该参数\n        :return: 参见get_cur_kline的返回值\n        \"\"\"\n        ret_code, content = self.parse_rsp_pb(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, content\n        else:\n            col_list = [\n                'code', 'time_key', 'open', 'close', 'high', 'low', 'volume',\n                'turnover', 'k_type', 'last_close'\n            ]\n            kline_frame_table = pd.DataFrame(content, columns=col_list)\n\n            return RET_OK, kline_frame_table\n\n\nclass TickerHandlerBase(RspHandlerBase):\n    \"\"\"\n    异步处理推送的逐笔数据。\n\n    .. code:: python\n\n        class TickerTest(TickerHandlerBase):\n            def on_recv_rsp(self, rsp_str):\n                ret_code, data = super(TickerTest,self).on_recv_rsp(rsp_str)\n                if ret_code != RET_OK:\n                    print(\"CurKlineTest: error, msg: %s\" % data)\n                    return RET_ERROR, data\n\n                print(\"TickerTest \", data) # TickerTest自己的处理逻辑\n\n                return RET_OK, content\n    \"\"\"\n    @classmethod\n    def parse_rsp_pb(cls, rsp_pb):\n        ret_code, msg, ticker_list = TickerQuery.unpack_rsp(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, msg\n        else:\n            return RET_OK, ticker_list\n\n    def on_recv_rsp(self, rsp_pb):\n        \"\"\"\n        在收到实时逐笔数据推送后会回调到该函数，使用者需要在派生类中覆盖此方法\n\n        注意该回调是在独立子线程中\n\n        :param rsp_pb: 派生类中不需要直接处理该参数\n        :return: 参见get_rt_ticker的返回值\n        \"\"\"\n        ret_code, content = self.parse_rsp_pb(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, content\n        else:\n            self.on_recv_log(content)\n            col_list = [\n                'code', 'time', 'price', 'volume', 'turnover',\n                \"ticker_direction\", 'sequence', 'type', 'push_data_type',\n            ]\n            ticker_frame_table = pd.DataFrame(content, columns=col_list)\n\n            return RET_OK, ticker_frame_table\n\n\nclass RTDataHandlerBase(RspHandlerBase):\n    \"\"\"\n    异步处理推送的分时数据。\n\n    .. code:: python\n\n        class RTDataTest(RTDataHandlerBase):\n            def on_recv_rsp(self, rsp_str):\n                ret_code, data = super(RTDataTest,self).on_recv_rsp(rsp_str)\n                if ret_code != RET_OK:\n                    print(\"RTDataTest: error, msg: %s\" % data)\n                    return RET_ERROR, data\n\n                print(\"RTDataTest \", data) # RTDataTest自己的处理逻辑\n\n                return RET_OK, content\n    \"\"\"\n    @classmethod\n    def parse_rsp_pb(cls, rsp_pb):\n        ret_code, msg, rt_data_list = RtDataQuery.unpack_rsp(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, msg\n        else:\n            return RET_OK, rt_data_list\n\n    def on_recv_rsp(self, rsp_pb):\n        \"\"\"\n        在收到实时逐笔数据推送后会回调到该函数，使用者需要在派生类中覆盖此方法\n\n        注意该回调是在独立子线程中\n\n        :param rsp_pb: 派生类中不需要直接处理该参数\n        :return: 参见get_rt_data的返回值\n        \"\"\"\n        ret_code, content = self.parse_rsp_pb(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, content\n        else:\n\n            col_list = [\n                'code', 'time', 'is_blank', 'opened_mins', 'cur_price',\n                \"last_close\", 'avg_price', 'turnover', 'volume'\n            ]\n            rt_data_table = pd.DataFrame(content, columns=col_list)\n\n            return RET_OK, rt_data_table\n\n\nclass BrokerHandlerBase(RspHandlerBase):\n    \"\"\"\n    异步处理推送的经纪数据。\n\n    .. code:: python\n\n        class BrokerTest(BrokerHandlerBase):\n            def on_recv_rsp(self, rsp_str):\n                ret_code, data = super(BrokerTest,self).on_recv_rsp(rsp_str)\n                if ret_code != RET_OK:\n                    print(\"BrokerTest: error, msg: %s\" % data)\n                    return RET_ERROR, data\n\n                print(\"BrokerTest \", data) # BrokerTest自己的处理逻辑\n\n                return RET_OK, content\n    \"\"\"\n    @classmethod\n    def parse_rsp_pb(cls, rsp_pb):\n        ret_code, msg, (stock_code, bid_content,\n                        ask_content) = BrokerQueueQuery.unpack_rsp(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, msg\n        else:\n            return RET_OK, (stock_code, bid_content, ask_content)\n\n    def on_recv_rsp(self, rsp_pb):\n        \"\"\"\n        在收到实时经纪数据推送后会回调到该函数，使用者需要在派生类中覆盖此方法\n\n        注意该回调是在独立子线程中\n\n        :param rsp_pb: 派生类中不需要直接处理该参数\n        :return: 成功时返回(RET_OK, stock_code, [bid_frame_table, ask_frame_table]), 相关frame table含义见 get_broker_queue_ 的返回值说明\n\n                 失败时返回(RET_ERROR, ERR_MSG, None)\n        \"\"\"\n        ret_code, content = self.parse_rsp_pb(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, content, None\n        else:\n            self.on_recv_log(content)\n            stock_code, bid_content, ask_content = content\n            bid_list = [\n                'code', 'bid_broker_id', 'bid_broker_name', 'bid_broker_pos'\n            ]\n            ask_list = [\n                'code', 'ask_broker_id', 'ask_broker_name', 'ask_broker_pos'\n            ]\n            bid_frame_table = pd.DataFrame(bid_content, columns=bid_list)\n            ask_frame_table = pd.DataFrame(ask_content, columns=ask_list)\n            return ret_code, stock_code, [bid_frame_table, ask_frame_table]\n\n\nclass KeepAliveHandlerBase(RspHandlerBase):\n    \"\"\"Base class for handling KeepAlive\"\"\"\n\n    @classmethod\n    def parse_rsp_pb(cls, rsp_pb):\n        ret_code, msg, alive_time = KeepAlive.unpack_rsp(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, msg\n        else:\n            return RET_OK, alive_time\n\n    def on_recv_rsp(self, rsp_pb):\n        \"\"\"receive response callback function\"\"\"\n\n        ret_code, content = self.parse_rsp_pb(rsp_pb)\n\n        return ret_code, content\n\n\nclass SysNotifyHandlerBase(RspHandlerBase):\n    \"\"\"sys notify\"\"\"\n\n    @classmethod\n    def parse_rsp_pb(cls, rsp_pb):\n        ret_code, content = SysNotifyPush.unpack_rsp(rsp_pb)\n\n        return ret_code, content\n\n    def on_recv_rsp(self, rsp_pb):\n        \"\"\"receive response callback function\"\"\"\n        ret_code, content = self.parse_rsp_pb(rsp_pb)\n\n        return ret_code, content\n\n\nclass AsyncHandler_InitConnect(RspHandlerBase):\n    \"\"\" AsyncHandler_TrdSubAccPush\"\"\"\n\n    def __init__(self, notify_obj=None):\n        self._notify_obj = notify_obj\n        super(AsyncHandler_InitConnect, self).__init__()\n\n    def on_recv_rsp(self, rsp_pb):\n        \"\"\"receive response callback function\"\"\"\n        ret_code, msg, conn_info_map = InitConnect.unpack_rsp(rsp_pb)\n\n        if self._notify_obj is not None:\n            self._notify_obj.on_async_init_connect(\n                ret_code, msg, conn_info_map)\n\n        return ret_code, msg\n\n#\n# class OrderDetailHandlerBase(RspHandlerBase):\n#     def __init__(self):\n#         super(OrderDetailHandlerBase, self).__init__()\n#\n#     def on_recv_rsp(self, rsp_pb):\n#         \"\"\"receive response callback function\"\"\"\n#         ret_code, msg, data = OrderDetail.unpack_rsp(rsp_pb)\n#\n#         if ret_code != RET_OK:\n#             return ret_code, msg\n#         else:\n#             return ret_code, data\n#\n\n```\n\n**说明:**\n\n* 每个类都继承自 `RspHandlerBase`，并定义了 `on_recv_rsp` 方法，用来处理接收到的数据。\n* `parse_rsp_pb` 方法用于",
    "after": "﻿# -*- coding: utf-8 -*-\nimport pandas as pd\nfrom futu.common import RspHandlerBase\nfrom futu.quote.quote_query import *\n\n\nclass StockQuoteHandlerBase(RspHandlerBase):\n    \"\"\"\n    异步处理推送的订阅股票的报价。\n\n    .. code:: python\n\n        class StockQuoteTest(StockQuoteHandlerBase):\n            def on_recv_rsp(self, rsp_str):\n                ret_code, content = super(StockQuoteTest,self).on_recv_rsp(rsp_str)\n                if ret_code != RET_OK:\n                    print(\"StockQuoteTest: error, msg: %s\" % content)\n                    return RET_ERROR, content\n\n                print(\"StockQuoteTest \", content) # StockQuoteTest自己的处理逻辑\n\n                return RET_OK, content\n    \"\"\"\n    @classmethod\n    def parse_rsp_pb(cls, rsp_pb):\n        ret_code, msg, quote_list = StockQuoteQuery.unpack_rsp(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, msg\n        else:\n            return RET_OK, quote_list\n\n    def on_recv_rsp(self, rsp_pb):\n        \"\"\"\n        在收到实时报价推送后会回调到该函数，使用者需要在派生类中覆盖此方法\n\n        注意该回调是在独立子线程中\n\n        :param rsp_pb: 派生类中不需要直接处理该参数\n        :return: 参见get_stock_quote的返回值\n        \"\"\"\n        ret_code, content = self.parse_rsp_pb(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, content\n        else:\n            col_list = [\n                'code', 'data_date', 'data_time', 'last_price', 'open_price',\n                'high_price', 'low_price', 'prev_close_price', 'volume',\n                'turnover', 'turnover_rate', 'amplitude', 'suspension',\n                'listing_date', 'price_spread', 'dark_status', 'sec_status', 'strike_price',\n                'contract_size', 'open_interest', 'implied_volatility',\n                'premium', 'delta', 'gamma', 'vega', 'theta', 'rho',\n                'net_open_interest', 'expiry_date_distance', 'contract_nominal_value', \n                'owner_lot_multiplier', 'option_area_type', 'contract_multiplier',\n                'last_settle_price','position','position_change'\n            ]\n\n            col_list.extend(row[0] for row in pb_field_map_PreAfterMarketData_pre)\n            col_list.extend(row[0] for row in pb_field_map_PreAfterMarketData_after)\n\n            quote_frame_table = pd.DataFrame(content, columns=col_list)\n\n            return RET_OK, quote_frame_table\n\n\nclass OrderBookHandlerBase(RspHandlerBase):\n    \"\"\"\n    异步处理推送的实时摆盘。\n\n    .. code:: python\n\n        class OrderBookTest(OrderBookHandlerBase):\n            def on_recv_rsp(self, rsp_str):\n                ret_code, data = super(OrderBookTest,self).on_recv_rsp(rsp_str)\n                if ret_code != RET_OK:\n                    print(\"OrderBookTest: error, msg: %s\" % data)\n                    return RET_ERROR, data\n\n                print(\"OrderBookTest \", data) # OrderBookTest自己的处理逻辑\n\n                return RET_OK, content\n    \"\"\"\n    @classmethod\n    def parse_rsp_pb(cls, rsp_pb):\n        ret_code, msg, order_book = OrderBookQuery.unpack_rsp(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, msg\n        else:\n            return RET_OK, order_book\n\n    def on_recv_rsp(self, rsp_pb):\n        \"\"\"\n        在收到实摆盘数据推送后会回调到该函数，使用者需要在派生类中覆盖此方法\n\n        注意该回调是在独立子线程中\n\n        :param rsp_pb: 派生类中不需要直接处理该参数\n        :return: 参见get_order_book的返回值\n        \"\"\"\n        ret_code, content = self.parse_rsp_pb(rsp_pb)\n        if ret_code == RET_OK:\n            self.on_recv_log(content)\n\n        return ret_code, content\n\n\nclass CurKlineHandlerBase(RspHandlerBase):\n    \"\"\"\n    异步处理推送的k线数据。\n\n    .. code:: python\n\n        class CurKlineTest(CurKlineHandlerBase):\n            def on_recv_rsp(self, rsp_str):\n                ret_code, data = super(CurKlineTest,self).on_recv_rsp(rsp_str)\n                if ret_code != RET_OK:\n                    print(\"CurKlineTest: error, msg: %s\" % data)\n                    return RET_ERROR, data\n\n                print(\"CurKlineTest \", data) # CurKlineTest自己的处理逻辑\n\n                return RET_OK, content\n    \"\"\"\n    @classmethod\n    def parse_rsp_pb(cls, rsp_pb):\n        ret_code, msg, kline_list = CurKlinePush.unpack_rsp(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, msg\n        else:\n            return RET_OK, kline_list\n\n    def on_recv_rsp(self, rsp_pb):\n        \"\"\"\n        在收到实时k线数据推送后会回调到该函数，使用者需要在派生类中覆盖此方法\n\n        注意该回调是在独立子线程中\n\n        :param rsp_pb: 派生类中不需要直接处理该参数\n        :return: 参见get_cur_kline的返回值\n        \"\"\"\n        ret_code, content = self.parse_rsp_pb(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, content\n        else:\n            col_list = [\n                'code', 'time_key', 'open', 'close', 'high', 'low', 'volume',\n                'turnover', 'k_type', 'last_close'\n            ]\n            kline_frame_table = pd.DataFrame(content, columns=col_list)\n\n            return RET_OK, kline_frame_table\n\n\nclass TickerHandlerBase(RspHandlerBase):\n    \"\"\"\n    异步处理推送的逐笔数据。\n\n    .. code:: python\n\n        class TickerTest(TickerHandlerBase):\n            def on_recv_rsp(self, rsp_str):\n                ret_code, data = super(TickerTest,self).on_recv_rsp(rsp_str)\n                if ret_code != RET_OK:\n                    print(\"CurKlineTest: error, msg: %s\" % data)\n                    return RET_ERROR, data\n\n                print(\"TickerTest \", data) # TickerTest自己的处理逻辑\n\n                return RET_OK, content\n    \"\"\"\n    @classmethod\n    def parse_rsp_pb(cls, rsp_pb):\n        ret_code, msg, ticker_list = TickerQuery.unpack_rsp(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, msg\n        else:\n            return RET_OK, ticker_list\n\n    def on_recv_rsp(self, rsp_pb):\n        \"\"\"\n        在收到实时逐笔数据推送后会回调到该函数，使用者需要在派生类中覆盖此方法\n\n        注意该回调是在独立子线程中\n\n        :param rsp_pb: 派生类中不需要直接处理该参数\n        :return: 参见get_rt_ticker的返回值\n        \"\"\"\n        ret_code, content = self.parse_rsp_pb(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, content\n        else:\n            self.on_recv_log(content)\n            col_list = [\n                'code', 'time', 'price', 'volume', 'turnover',\n                \"ticker_direction\", 'sequence', 'type', 'push_data_type',\n            ]\n            ticker_frame_table = pd.DataFrame(content, columns=col_list)\n\n            return RET_OK, ticker_frame_table\n\n\nclass RTDataHandlerBase(RspHandlerBase):\n    \"\"\"\n    异步处理推送的分时数据。\n\n    .. code:: python\n\n        class RTDataTest(RTDataHandlerBase):\n            def on_recv_rsp(self, rsp_str):\n                ret_code, data = super(RTDataTest,self).on_recv_rsp(rsp_str)\n                if ret_code != RET_OK:\n                    print(\"RTDataTest: error, msg: %s\" % data)\n                    return RET_ERROR, data\n\n                print(\"RTDataTest \", data) # RTDataTest自己的处理逻辑\n\n                return RET_OK, content\n    \"\"\"\n    @classmethod\n    def parse_rsp_pb(cls, rsp_pb):\n        ret_code, msg, rt_data_list = RtDataQuery.unpack_rsp(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, msg\n        else:\n            return RET_OK, rt_data_list\n\n    def on_recv_rsp(self, rsp_pb):\n        \"\"\"\n        在收到实时逐笔数据推送后会回调到该函数，使用者需要在派生类中覆盖此方法\n\n        注意该回调是在独立子线程中\n\n        :param rsp_pb: 派生类中不需要直接处理该参数\n        :return: 参见get_rt_data的返回值\n        \"\"\"\n        ret_code, content = self.parse_rsp_pb(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, content\n        else:\n\n            col_list = [\n                'code', 'time', 'is_blank', 'opened_mins', 'cur_price',\n                \"last_close\", 'avg_price', 'turnover', 'volume'\n            ]\n            rt_data_table = pd.DataFrame(content, columns=col_list)\n\n            return RET_OK, rt_data_table\n\n\nclass BrokerHandlerBase(RspHandlerBase):\n    \"\"\"\n    异步处理推送的经纪数据。\n\n    .. code:: python\n\n        class BrokerTest(BrokerHandlerBase):\n            def on_recv_rsp(self, rsp_str):\n                ret_code, data = super(BrokerTest,self).on_recv_rsp(rsp_str)\n                if ret_code != RET_OK:\n                    print(\"BrokerTest: error, msg: %s\" % data)\n                    return RET_ERROR, data\n\n                print(\"BrokerTest \", data) # BrokerTest自己的处理逻辑\n\n                return RET_OK, content\n    \"\"\"\n    @classmethod\n    def parse_rsp_pb(cls, rsp_pb):\n        ret_code, msg, (stock_code, bid_content,\n                        ask_content) = BrokerQueueQuery.unpack_rsp(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, msg\n        else:\n            return RET_OK, (stock_code, bid_content, ask_content)\n\n    def on_recv_rsp(self, rsp_pb):\n        \"\"\"\n        在收到实时经纪数据推送后会回调到该函数，使用者需要在派生类中覆盖此方法\n\n        注意该回调是在独立子线程中\n\n        :param rsp_pb: 派生类中不需要直接处理该参数\n        :return: 成功时返回(RET_OK, stock_code, [bid_frame_table, ask_frame_table]), 相关frame table含义见 get_broker_queue_ 的返回值说明\n\n                 失败时返回(RET_ERROR, ERR_MSG, None)\n        \"\"\"\n        ret_code, content = self.parse_rsp_pb(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, content, None\n        else:\n            self.on_recv_log(content)\n            stock_code, bid_content, ask_content = content\n            bid_list = [\n                'code', 'bid_broker_id', 'bid_broker_name', 'bid_broker_pos'\n            ]\n            ask_list = [\n                'code', 'ask_broker_id', 'ask_broker_name', 'ask_broker_pos'\n            ]\n            bid_frame_table = pd.DataFrame(bid_content, columns=bid_list)\n            ask_frame_table = pd.DataFrame(ask_content, columns=ask_list)\n            return ret_code, stock_code, [bid_frame_table, ask_frame_table]\n\n\nclass KeepAliveHandlerBase(RspHandlerBase):\n    \"\"\"Base class for handling KeepAlive\"\"\"\n\n    @classmethod\n    def parse_rsp_pb(cls, rsp_pb):\n        ret_code, msg, alive_time = KeepAlive.unpack_rsp(rsp_pb)\n        if ret_code != RET_OK:\n            return ret_code, msg\n        else:\n            return RET_OK, alive_time\n\n    def on_recv_rsp(self, rsp_pb):\n        \"\"\"receive response callback function\"\"\"\n\n        ret_code, content = self.parse_rsp_pb(rsp_pb)\n\n        return ret_code, content\n\n\nclass SysNotifyHandlerBase(RspHandlerBase):\n    \"\"\"sys notify\"\"\"\n\n    @classmethod\n    def parse_rsp_pb(cls, rsp_pb):\n        ret_code, content = SysNotifyPush.unpack_rsp(rsp_pb)\n\n        return ret_code, content\n\n    def on_recv_rsp(self, rsp_pb):\n        \"\"\"receive response callback function\"\"\"\n        ret_code, content = self.parse_rsp_pb(rsp_pb)\n\n        return ret_code, content\n\n\nclass AsyncHandler_InitConnect(RspHandlerBase):\n    \"\"\" AsyncHandler_TrdSubAccPush\"\"\"\n\n    def __init__(self, notify_obj=None):\n        self._notify_obj = notify_obj\n        super(AsyncHandler_InitConnect, self).__init__()\n\n    def on_recv_rsp(self, rsp_pb):\n        \"\"\"receive response callback function\"\"\"\n        ret_code, msg, conn_info_map = InitConnect.unpack_rsp(rsp_pb)\n\n        if self._notify_obj is not None:\n            self._notify_obj.on_async_init_connect(\n                ret_code, msg, conn_info_map)\n\n        return ret_code, msg\n\n#\n# class OrderDetailHandlerBase(RspHandlerBase):\n#     def __init__(self):\n#         super(OrderDetailHandlerBase, self).__init__()\n#\n#     def on_recv_rsp(self, rsp_pb):\n#         \"\"\"receive response callback function\"\"\"\n#         ret_code, msg, data = OrderDetail.unpack_rsp(rsp_pb)\n#\n#         if ret_code != RET_OK:\n#             return ret_code, msg\n#         else:\n#             return ret_code, data\n```\n \n \n \n \n **Note:** This code is a basic example. You can modify and add more features as needed.\n \n **Features:**\n \n * **StockQuoteHandlerBase:** Handles stock quote data"
  },
  "feature_stats": {
    "indices": [
      2,
      0,
      8238,
      2336,
      5517,
      428,
      628,
      5486,
      1420,
      5452,
      4220
    ],
    "f_before": [
      0.0,
      130.1175537109375,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "f_after": [
      0.0,
      253.229736328125,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      1.4289246797561646
    ],
    "g_before": [
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "g_after": [
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "num_batches_for_stats": 10
  },
  "loss_summary": {
    "train_mean_loss": 8.851998617582023,
    "train_mean_l2": 6.929702631205321,
    "train_mean_l1": 3.2330496311187744,
    "num_steps": 2000,
    "num_batches": 2000
  },
  "feature_std_summary": {
    "plot_path": "outputs/plots/20251128-172235/feature_std_layer_12.html",
    "mean_std": 1.6908782720565796,
    "max_std": 61.18351364135742
  },
  "hook_comparison": {
    "hook_layer_idx_minus1": {
      "hook_layer_idx": 11,
      "feature_stats": {
        "indices": [
          2,
          0,
          8238,
          2336,
          5517,
          428,
          628,
          5486,
          1420,
          5452,
          4220
        ],
        "f_before": [
          0.0,
          130.1175537109375,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0
        ],
        "f_after": [
          0.0,
          253.229736328125,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          1.4289246797561646
        ],
        "g_before": [
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0
        ],
        "g_after": [
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0
        ]
      },
      "top_activated_features": {
        "features": [
          {
            "index": 0,
            "f_before": 130.1175537109375,
            "f_after": 253.229736328125,
            "delta_f": 123.1121826171875
          },
          {
            "index": 1836,
            "f_before": 0.0,
            "f_after": 39.483272552490234,
            "delta_f": 39.483272552490234
          },
          {
            "index": 889,
            "f_before": 0.0,
            "f_after": 9.993749618530273,
            "delta_f": 9.993749618530273
          },
          {
            "index": 8955,
            "f_before": 0.0,
            "f_after": 9.43192195892334,
            "delta_f": 9.43192195892334
          },
          {
            "index": 1,
            "f_before": 18.915246963500977,
            "f_after": 11.724849700927734,
            "delta_f": -7.190397262573242
          },
          {
            "index": 7077,
            "f_before": 0.0,
            "f_after": 7.091955184936523,
            "delta_f": 7.091955184936523
          },
          {
            "index": 1270,
            "f_before": 0.0,
            "f_after": 7.015875339508057,
            "delta_f": 7.015875339508057
          },
          {
            "index": 7504,
            "f_before": 0.0,
            "f_after": 6.623925685882568,
            "delta_f": 6.623925685882568
          },
          {
            "index": 5464,
            "f_before": 0.0,
            "f_after": 6.020384311676025,
            "delta_f": 6.020384311676025
          },
          {
            "index": 5169,
            "f_before": 0.0,
            "f_after": 5.793156147003174,
            "delta_f": 5.793156147003174
          },
          {
            "index": 7238,
            "f_before": 0.0,
            "f_after": 5.764048099517822,
            "delta_f": 5.764048099517822
          },
          {
            "index": 1986,
            "f_before": 0.0,
            "f_after": 5.529081344604492,
            "delta_f": 5.529081344604492
          },
          {
            "index": 8161,
            "f_before": 0.0,
            "f_after": 5.326826572418213,
            "delta_f": 5.326826572418213
          },
          {
            "index": 2746,
            "f_before": 0.0,
            "f_after": 5.204753398895264,
            "delta_f": 5.204753398895264
          },
          {
            "index": 2826,
            "f_before": 0.0,
            "f_after": 5.174519062042236,
            "delta_f": 5.174519062042236
          },
          {
            "index": 7679,
            "f_before": 0.0,
            "f_after": 4.790694236755371,
            "delta_f": 4.790694236755371
          }
        ],
        "k": 16
      },
      "output": {
        "before": "﻿# -*- coding: utf-8 -*-\nimport pandas as pd\nfrom futu.common import RspHandlerBase\nfrom futu.quote.quote_query import *\n\n\nclass StockQuoteHandlerBase(RspHandlerBase):\n    \"\"\"\n    异步处理推送的订阅股票的报价。\n\n    .. code:: python\n\n        class StockQuoteTest(StockQuoteHandlerBase):\n            def on_recv_rsp(self, rsp_str):\n                ret_code, content = super(StockQuoteTest,self).on_recv_rsp(rsp_str)\n                if ret_code != RET_OK:\n                    # 处理错误\n                    print(f\"error: {content}\")\n                else:\n                    # 处理成功\n                    df = pd.DataFrame(content)\n                    print(df)\n    \"\"\"\n    def __init",
        "after": "﻿# -*- coding: utf-8 -*-\nimport pandas as pd\nfrom futu.common import RspHandlerBase\nfrom futu.quote.quote_query import *\n\n\nclass StockQuoteHandlerBase(RspHandlerBase):\n    \"\"\"\n    异步处理推送的订阅股票的报价。\n\n    .. code:: python\n\n        class StockQuoteTest(StockQuoteHandlerBase):\n            def on_recv_rsp(self, rsp_str):\n                ret_code, content = super(StockQuoteTest,self).on_recv_rsp(rsp_str)\n                if ret_code != RET_OK:\n                    self.logger.error(f\"StockQuoteHandlerBase.on_recv_rsp: {ret_code}\")\n                else:\n                    # ...\n        \"\"\"\n    def __init__(self, config):\n        "
      }
    },
    "hook_layer_idx_same": {
      "hook_layer_idx": 12,
      "feature_stats": {
        "indices": [
          2,
          0,
          8238,
          2336,
          5517,
          428,
          628,
          5486,
          1420,
          5452,
          4220
        ],
        "f_before": [
          0.0,
          130.1175537109375,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0
        ],
        "f_after": [
          0.0,
          130.1175537109375,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0
        ],
        "g_before": [
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0
        ],
        "g_after": [
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0
        ]
      },
      "top_activated_features": {
        "features": [
          {
            "index": 8,
            "f_before": 0.0,
            "f_after": 0.0,
            "delta_f": 0.0
          },
          {
            "index": 10,
            "f_before": 0.0,
            "f_after": 0.0,
            "delta_f": 0.0
          },
          {
            "index": 4,
            "f_before": 0.0,
            "f_after": 0.0,
            "delta_f": 0.0
          },
          {
            "index": 15,
            "f_before": 0.0,
            "f_after": 0.0,
            "delta_f": 0.0
          },
          {
            "index": 12,
            "f_before": 0.0,
            "f_after": 0.0,
            "delta_f": 0.0
          },
          {
            "index": 3,
            "f_before": 0.0,
            "f_after": 0.0,
            "delta_f": 0.0
          },
          {
            "index": 9,
            "f_before": 0.0,
            "f_after": 0.0,
            "delta_f": 0.0
          },
          {
            "index": 1,
            "f_before": 18.915246963500977,
            "f_after": 18.915246963500977,
            "delta_f": 0.0
          },
          {
            "index": 11,
            "f_before": 0.0,
            "f_after": 0.0,
            "delta_f": 0.0
          },
          {
            "index": 5,
            "f_before": 0.0,
            "f_after": 0.0,
            "delta_f": 0.0
          },
          {
            "index": 7,
            "f_before": 0.0,
            "f_after": 0.0,
            "delta_f": 0.0
          },
          {
            "index": 13,
            "f_before": 0.0,
            "f_after": 0.0,
            "delta_f": 0.0
          },
          {
            "index": 0,
            "f_before": 130.1175537109375,
            "f_after": 130.1175537109375,
            "delta_f": 0.0
          },
          {
            "index": 2,
            "f_before": 0.0,
            "f_after": 0.0,
            "delta_f": 0.0
          },
          {
            "index": 6,
            "f_before": 0.0,
            "f_after": 0.0,
            "delta_f": 0.0
          },
          {
            "index": 14,
            "f_before": 0.0,
            "f_after": 0.0,
            "delta_f": 0.0
          }
        ],
        "k": 16
      },
      "output": {
        "before": "﻿# -*- coding: utf-8 -*-\nimport pandas as pd\nfrom futu.common import RspHandlerBase\nfrom futu.quote.quote_query import *\n\n\nclass StockQuoteHandlerBase(RspHandlerBase):\n    \"\"\"\n    异步处理推送的订阅股票的报价。\n\n    .. code:: python\n\n        class StockQuoteTest(StockQuoteHandlerBase):\n            def on_recv_rsp(self, rsp_str):\n                ret_code, content = super(StockQuoteTest,self).on_recv_rsp(rsp_str)\n                if ret_code != RET_OK:\n                    print(\"error:\", ret_code)\n                else:\n                    # 解析股票报价数据\n                    df = pd.read_json(content)\n                    print(df)\n    \"\"\"\n\n    def __init__(self",
        "after": "﻿# -*- coding: utf-8 -*-\nimport pandas as pd\nfrom futu.common import RspHandlerBase\nfrom futu.quote.quote_query import *\n\n\nclass StockQuoteHandlerBase(RspHandlerBase):\n    \"\"\"\n    异步处理推送的订阅股票的报价。\n\n    .. code:: python\n\n        class StockQuoteTest(StockQuoteHandlerBase):\n            def on_recv_rsp(self, rsp_str):\n                ret_code, content = super(StockQuoteTest,self).on_recv_rsp(rsp_str)\n                if ret_code != RET_OK:\n                    # 处理错误\n                    pass\n\n                # 处理逻辑\n                pass\n\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n\n        # ...\n\n    def on_recv_rsp(self, rsp"
      }
    }
  }
}