{
  "model_name": "google/gemma-2-2b-it",
  "layer_idx": 12,
  "command": "python main.py experiment.use_multi_contrast=true sae.loss_option=2 sae.loss_module=option2_loss sae.guidance_method=contrastive sae.guidance_coeff=1.0 sae.alpha_concept.code=0.065 sae.alpha_concept.harm=0.06 sae.alpha_concept.struct=0.0 sae.use_l0=true sae.l0_coeff=0.0006999351784843934 sae.role_sep_coeff=0.008",
  "sae": {
    "input_dim": 2304,
    "sae_dim": 9216,
    "fixed_v_cnt": 3,
    "batch_size": 3,
    "epochs": 2,
    "max_steps": 2000,
    "l1_coeff": 0.005,
    "l0_coeff": 0.0006999351784843934,
    "use_l0": true,
    "concept_samples_per_label": 100,
    "loss_option": 2,
    "loss_module": "option2_loss",
    "concept_feature_indices": {
      "code": 0,
      "harm": 1,
      "struct": 2
    },
    "alpha_concept": {
      "code": 0.065,
      "harm": 0.06,
      "struct": 0.0
    },
    "positive_targets": {
      "code": 1,
      "harm": 1,
      "struct": 1
    },
    "guidance_method": "contrastive",
    "guidance_margin": 0.0,
    "guidance_coeff": 1.0,
    "guidance_mse_pos_value": 1.0,
    "guidance_mse_neg_value": 0.0,
    "jumprelu_bandwidth": 0.001,
    "jumprelu_init_threshold": 0.001,
    "role_sep_coeff": 0.008
  },
  "gnn": {
    "use_gnn": true,
    "top_k": 10
  },
  "experiment": {
    "device": "cuda",
    "dataset_name": "wikitext",
    "dataset_config": "wikitext-2-raw-v1",
    "use_multi_contrast": true,
    "num_steering_samples_per_label": 10,
    "top_k_for_plot": 10,
    "layer_sweep": [
      12
    ],
    "strength_sweep": [
      15.0
    ]
  },
  "steering": {
    "label": "struct",
    "feature_idx": 2,
    "strength": 15.0
  },
  "prompt": "##############################################################################\n# Copyright (c) 2017 Huawei Technologies Co.,Ltd.\n#\n# All rights reserved. This program and the accompanying materials\n# are made available under the terms of the Apache License, Version 2.0\n# which accompanies this distribution, and is available at\n# http://www.apache.org/licenses/LICENSE-2.0\n##############################################################################\nfrom __future__ import absolute_import\n\nimport logging\nimport threading\nimport time\nimport uuid\nimport os\nimport glob\n\nfrom six.moves import configparser\nfrom oslo_serialization import jsonutils\nfrom docker import Client\n\nfrom api import ApiResource\nfrom api.utils import influx\nfrom api.database.v2.handlers import V2ContainerHandler\nfrom api.database.v2.handlers import V2EnvironmentHandler\nfrom yardstick.common import constants as consts\nfrom yardstick.common import utils\nfrom yardstick.common.utils import result_handler\nfrom yardstick.common.utils import get_free_port\nfrom yardstick.common.httpClient import HttpClient\n\n\nLOG = logging.getLogger(__name__)\nLOG.setLevel(logging.DEBUG)\n\nenvironment_handler = V2EnvironmentHandler()\ncontainer_handler = V2ContainerHandler()\n\n\nclass V2Containers(ApiResource):\n\n    def post(self):\n        return self._dispatch_post()\n\n    def create_influxdb(self, args):\n        try:\n            environment_id = args['environment_id']\n        except KeyError:\n            return result_handler(consts.API_ERROR, 'environment_id must be provided')\n\n        try:\n            uuid.UUID(environment_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'invalid environment id')\n\n        try:\n            environment = environment_handler.get_by_uuid(environment_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'no such environment id')\n\n        container_info = environment.container_id\n        container_info = jsonutils.loads(container_info) if container_info else {}\n\n        if container_info.get('influxdb'):\n            return result_handler(consts.API_ERROR, 'influxdb container already exist')\n\n        name = 'influxdb-{}'.format(environment_id[:8])\n        port = get_free_port(consts.SERVER_IP)\n        container_id = str(uuid.uuid4())\n        LOG.info('%s will launch on : %s', name, port)\n\n        LOG.info('launch influxdb background')\n        args = (name, port, container_id)\n        thread = threading.Thread(target=self._create_influxdb, args=args)\n        thread.start()\n\n        LOG.info('record container in database')\n        container_init_data = {\n            'uuid': container_id,\n            'environment_id': environment_id,\n            'name': name,\n            'port': port,\n            'status': 0\n        }\n        container_handler.insert(container_init_data)\n\n        LOG.info('update container in environment')\n        container_info['influxdb'] = container_id\n        environment_info = {'container_id': jsonutils.dumps(container_info)}\n        environment_handler.update_attr(environment_id, environment_info)\n\n        return result_handler(consts.API_SUCCESS, {'uuid': container_id})\n\n    def _check_image_exist(self, client, t):\n        return any(t in a['RepoTags'][0]\n                   for a in client.images() if a['RepoTags'])\n\n    def _create_influxdb(self, name, port, container_id):\n        client = Client(base_url=consts.DOCKER_URL)\n\n        try:\n            LOG.info('Checking if influxdb image exist')\n            if not self._check_image_exist(client, '%s:%s' %\n                                           (consts.INFLUXDB_IMAGE,\n                                            consts.INFLUXDB_TAG)):\n                LOG.info('Influxdb image not exist, start pulling')\n                client.pull(consts.INFLUXDB_IMAGE, tag=consts.INFLUXDB_TAG)\n\n            LOG.info('Createing influxdb container')\n            container = self._create_influxdb_container(client, name, port)\n            LOG.info('Influxdb container is created')\n\n            time.sleep(5)\n\n            container = client.inspect_container(container['Id'])\n            ip = container['NetworkSettings']['Networks']['bridge']['IPAddress']\n            LOG.debug('container ip is: %s', ip)\n\n            LOG.info('Changing output to influxdb')\n            self._change_output_to_influxdb(ip)\n\n            LOG.info('Config influxdb')\n            self._config_influxdb()\n\n            container_handler.update_attr(container_id, {'status': 1})\n\n            LOG.info('Finished')\n        except Exception:\n            container_handler.update_attr(container_id, {'status': 2})\n            LOG.exception('Creating influxdb failed')\n\n    def _create_influxdb_container(self, client, name, port):\n\n        ports = [port]\n        port_bindings = {8086: port}\n        restart_policy = {\"MaximumRetryCount\": 0, \"Name\": \"always\"}\n        host_config = client.create_host_config(port_bindings=port_bindings,\n                                                restart_policy=restart_policy)\n\n        LOG.info('Creating container')\n        container = client.create_container(image='%s:%s' %\n                                            (consts.INFLUXDB_IMAGE,\n                                             consts.INFLUXDB_TAG),\n                                            ports=ports,\n                                            name=name,\n                                            detach=True,\n                                            tty=True,\n                                            host_config=host_config)\n        LOG.info('Starting container')\n        client.start(container)\n        return container\n\n    def _config_influxdb(self):\n        try:\n            client = influx.get_data_db_client()\n            client.create_user(consts.INFLUXDB_USER,\n                               consts.INFLUXDB_PASS,\n                               consts.INFLUXDB_DB_NAME)\n            client.create_database(consts.INFLUXDB_DB_NAME)\n            LOG.info('Success to config influxDB')\n        except Exception:\n            LOG.exception('Config influxdb failed')\n\n    def _change_output_to_influxdb(self, ip):\n        utils.makedirs(consts.CONF_DIR)\n\n        parser = configparser.ConfigParser()\n        LOG.info('Reading output sample configuration')\n        parser.read(consts.CONF_SAMPLE_FILE)\n\n        LOG.info('Set dispatcher to influxdb')\n        parser.set('DEFAULT', 'dispatcher', 'influxdb')\n        parser.set('dispatcher_influxdb', 'target',\n                   'http://{}:{}'.format(ip, 8086))\n\n        LOG.info('Writing to %s', consts.CONF_FILE)\n        with open(consts.CONF_FILE, 'w') as f:\n            parser.write(f)\n\n    def create_grafana(self, args):\n        try:\n            environment_id = args['environment_id']\n        except KeyError:\n            return result_handler(consts.API_ERROR, 'environment_id must be provided')\n\n        try:\n            uuid.UUID(environment_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'invalid environment id')\n\n        try:\n            environment = environment_handler.get_by_uuid(environment_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'no such environment id')\n\n        container_info = environment.container_id\n        container_info = jsonutils.loads(container_info) if container_info else {}\n\n        if not container_info.get('influxdb'):\n            return result_handler(consts.API_ERROR, 'influxdb not set')\n\n        if container_info.get('grafana'):\n            return result_handler(consts.API_ERROR, 'grafana container already exists')\n\n        name = 'grafana-{}'.format(environment_id[:8])\n        port = get_free_port(consts.SERVER_IP)\n        container_id = str(uuid.uuid4())\n\n        args = (name, port, container_id)\n        thread = threading.Thread(target=self._create_grafana, args=args)\n        thread.start()\n\n        container_init_data = {\n            'uuid': container_id,\n            'environment_id': environment_id,\n            'name': name,\n            'port': port,\n            'status': 0\n        }\n        container_handler.insert(container_init_data)\n\n        container_info['grafana'] = container_id\n        environment_info = {'container_id': jsonutils.dumps(container_info)}\n        environment_handler.update_attr(environment_id, environment_info)\n\n        return result_handler(consts.API_SUCCESS, {'uuid': container_id})\n\n    def _create_grafana(self, name, port, container_id):\n        client = Client(base_url=consts.DOCKER_URL)\n\n        try:\n            LOG.info('Checking if grafana image exist')\n            image = '{}:{}'.format(consts.GRAFANA_IMAGE, consts.GRAFANA_TAG)\n            if not self._check_image_exist(client, image):\n                LOG.info('Grafana image not exist, start pulling')\n                client.pull(consts.GRAFANA_IMAGE, consts.GRAFANA_TAG)\n\n            LOG.info('Createing grafana container')\n            container = self._create_grafana_container(client, name, port)\n            LOG.info('Grafana container is created')\n\n            time.sleep(5)\n\n            container = client.inspect_container(container['Id'])\n            ip = container['NetworkSettings']['Networks']['bridge']['IPAddress']\n            LOG.debug('container ip is: %s', ip)\n\n            LOG.info('Creating data source for grafana')\n            self._create_data_source(ip)\n\n            LOG.info('Creating dashboard for grafana')\n            self._create_dashboard(ip)\n\n            container_handler.update_attr(container_id, {'status': 1})\n            LOG.info('Finished')\n        except Exception:\n            container_handler.update_attr(container_id, {'status': 2})\n            LOG.exception('Create grafana failed')\n\n    def _create_dashboard(self, ip):\n        url = 'http://admin:admin@{}:{}/api/dashboards/db'.format(ip, 3000)\n        path = os.path.join(consts.REPOS_DIR, 'dashboard', 'opnfv_yardstick_tc*.json')\n\n        for i in sorted(glob.iglob(path)):\n            with open(i) as f:\n                data = jsonutils.load(f)\n            try:\n                HttpClient().post(url, {'dashboard': data})\n            except Exception:\n                LOG.exception('Create dashboard %s failed', i)\n                raise\n\n    def _create_data_source(self, ip):\n        url = 'http://admin:admin@{}:{}/api/datasources'.format(ip, 3000)\n        influx_conf = utils.parse_ini_file(consts.CONF_FILE).get('dispatcher_influxdb', {})\n\n        data = {\n            \"name\": \"yardstick\",\n            \"type\": \"influxdb\",\n            \"access\": \"proxy\",\n            \"url\": influx_conf.get('target', ''),\n            \"password\": influx_conf.get('password', ''),\n            \"user\": influx_conf.get('username', ''),\n            \"database\": \"yardstick\",\n            \"basicAuth\": True,\n            \"basicAuthUser\": \"admin\",\n            \"basicAuthPassword\": \"admin\",\n            \"isDefault\": False,\n        }\n        try:\n            HttpClient().post(url, data)\n        except Exception:\n            LOG.exception('Create datasources failed')\n            raise\n\n    def _create_grafana_container(self, client, name, port):\n        ports = [3000]\n        port_bindings = {3000: port}\n        restart_policy = {\"MaximumRetryCount\": 0, \"Name\": \"always\"}\n        host_config = client.create_host_config(port_bindings=port_bindings,\n                                                restart_policy=restart_policy)\n\n        LOG.info('Creating container')\n        container = client.create_container(image='%s:%s' %\n                                            (consts.GRAFANA_IMAGE,\n                                             consts.GRAFANA_TAG),\n                                            name=name,\n                                            ports=ports,\n                                            detach=True,\n                                            tty=True,\n                                            host_config=host_config)\n        LOG.info('Starting container')\n        client.start(container)\n        return container\n\n\nclass V2Container(ApiResource):\n\n    def get(self, container_id):\n        try:\n            uuid.UUID(container_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'invalid container id')\n\n        try:\n            container = container_handler.get_by_uuid(container_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'no such container id')\n\n        name = container.name\n        client = Client(base_url=consts.DOCKER_URL)\n        info = client.inspect_container(name)\n\n        data = {\n            'name': name,\n            'status': info.get('State', {}).get('Status', 'error'),\n            'time': info.get('Created'),\n            'port': container.port\n        }\n\n        return result_handler(consts.API_SUCCESS, {'container': data})\n\n    def delete(self, container_id):\n        try:\n            uuid.UUID(container_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'invalid container id')\n\n        try:\n            container = container_handler.get_by_uuid(container_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'no such container id')\n\n        environment_id = container.environment_id\n\n        client = Client(base_url=consts.DOCKER_URL)\n        LOG.info('delete container: %s', container.name)\n        try:\n            client.remove_container(container.name, force=True)\n        except Exception:\n            LOG.exception('delete container failed')\n            return result_handler(consts.API_ERROR, 'delete container failed')\n\n        LOG.info('delete container in database')\n        container_handler.delete_by_uuid(container_id)\n\n        LOG.info('update container in environment')\n        environment = environment_handler.get_by_uuid(environment_id)\n        container_info = jsonutils.loads(environment.container_id)\n        key = next((k for k, v in container_info.items() if v == container_id))\n        container_info.pop(key)\n        environment_delete_data = {\n            'container_id': jsonutils.dumps(container_info)\n        }\n        environment_handler.update_attr(environment_id, environment_delete_data)\n\n        return result_handler(consts.API_SUCCESS, {'container': container_id})\n",
  "output": {
    "before": "##############################################################################\n# Copyright (c) 2017 Huawei Technologies Co.,Ltd.\n#\n# All rights reserved. This program and the accompanying materials\n# are made available under the terms of the Apache License, Version 2.0\n# which accompanies this distribution, and is available at\n# http://www.apache.org/licenses/LICENSE-2.0\n##############################################################################\nfrom __future__ import absolute_import\n\nimport logging\nimport threading\nimport time\nimport uuid\nimport os\nimport glob\n\nfrom six.moves import configparser\nfrom oslo_serialization import jsonutils\nfrom docker import Client\n\nfrom api import ApiResource\nfrom api.utils import influx\nfrom api.database.v2.handlers import V2ContainerHandler\nfrom api.database.v2.handlers import V2EnvironmentHandler\nfrom yardstick.common import constants as consts\nfrom yardstick.common import utils\nfrom yardstick.common.utils import result_handler\nfrom yardstick.common.utils import get_free_port\nfrom yardstick.common.httpClient import HttpClient\n\n\nLOG = logging.getLogger(__name__)\nLOG.setLevel(logging.DEBUG)\n\nenvironment_handler = V2EnvironmentHandler()\ncontainer_handler = V2ContainerHandler()\n\n\nclass V2Containers(ApiResource):\n\n    def post(self):\n        return self._dispatch_post()\n\n    def create_influxdb(self, args):\n        try:\n            environment_id = args['environment_id']\n        except KeyError:\n            return result_handler(consts.API_ERROR, 'environment_id must be provided')\n\n        try:\n            uuid.UUID(environment_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'invalid environment id')\n\n        try:\n            environment = environment_handler.get_by_uuid(environment_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'no such environment id')\n\n        container_info = environment.container_id\n        container_info = jsonutils.loads(container_info) if container_info else {}\n\n        if container_info.get('influxdb'):\n            return result_handler(consts.API_ERROR, 'influxdb container already exist')\n\n        name = 'influxdb-{}'.format(environment_id[:8])\n        port = get_free_port(consts.SERVER_IP)\n        container_id = str(uuid.uuid4())\n        LOG.info('%s will launch on : %s', name, port)\n\n        LOG.info('launch influxdb background')\n        args = (name, port, container_id)\n        thread = threading.Thread(target=self._create_influxdb, args=args)\n        thread.start()\n\n        LOG.info('record container in database')\n        container_init_data = {\n            'uuid': container_id,\n            'environment_id': environment_id,\n            'name': name,\n            'port': port,\n            'status': 0\n        }\n        container_handler.insert(container_init_data)\n\n        LOG.info('update container in environment')\n        container_info['influxdb'] = container_id\n        environment_info = {'container_id': jsonutils.dumps(container_info)}\n        environment_handler.update_attr(environment_id, environment_info)\n\n        return result_handler(consts.API_SUCCESS, {'uuid': container_id})\n\n    def _check_image_exist(self, client, t):\n        return any(t in a['RepoTags'][0]\n                   for a in client.images() if a['RepoTags'])\n\n    def _create_influxdb(self, name, port, container_id):\n        client = Client(base_url=consts.DOCKER_URL)\n\n        try:\n            LOG.info('Checking if influxdb image exist')\n            if not self._check_image_exist(client, '%s:%s' %\n                                           (consts.INFLUXDB_IMAGE,\n                                            consts.INFLUXDB_TAG)):\n                LOG.info('Influxdb image not exist, start pulling')\n                client.pull(consts.INFLUXDB_IMAGE, tag=consts.INFLUXDB_TAG)\n\n            LOG.info('Createing influxdb container')\n            container = self._create_influxdb_container(client, name, port)\n            LOG.info('Influxdb container is created')\n\n            time.sleep(5)\n\n            container = client.inspect_container(container['Id'])\n            ip = container['NetworkSettings']['Networks']['bridge']['IPAddress']\n            LOG.debug('container ip is: %s', ip)\n\n            LOG.info('Changing output to influxdb')\n            self._change_output_to_influxdb(ip)\n\n            LOG.info('Config influxdb')\n            self._config_influxdb()\n\n            container_handler.update_attr(container_id, {'status': 1})\n\n            LOG.info('Finished')\n        except Exception:\n            container_handler.update_attr(container_id, {'status': 2})\n            LOG.exception('Creating influxdb failed')\n\n    def _create_influxdb_container(self, client, name, port):\n\n        ports = [port]\n        port_bindings = {8086: port}\n        restart_policy = {\"MaximumRetryCount\": 0, \"Name\": \"always\"}\n        host_config = client.create_host_config(port_bindings=port_bindings,\n                                                restart_policy=restart_policy)\n\n        LOG.info('Creating container')\n        container = client.create_container(image='%s:%s' %\n                                            (consts.INFLUXDB_IMAGE,\n                                             consts.INFLUXDB_TAG),\n                                            ports=ports,\n                                            name=name,\n                                            detach=True,\n                                            tty=True,\n                                            host_config=host_config)\n        LOG.info('Starting container')\n        client.start(container)\n        return container\n\n    def _config_influxdb(self):\n        try:\n            client = influx.get_data_db_client()\n            client.create_user(consts.INFLUXDB_USER,\n                               consts.INFLUXDB_PASS,\n                               consts.INFLUXDB_DB_NAME)\n            client.create_database(consts.INFLUXDB_DB_NAME)\n            LOG.info('Success to config influxDB')\n        except Exception:\n            LOG.exception('Config influxdb failed')\n\n    def _change_output_to_influxdb(self, ip):\n        utils.makedirs(consts.CONF_DIR)\n\n        parser = configparser.ConfigParser()\n        LOG.info('Reading output sample configuration')\n        parser.read(consts.CONF_SAMPLE_FILE)\n\n        LOG.info('Set dispatcher to influxdb')\n        parser.set('DEFAULT', 'dispatcher', 'influxdb')\n        parser.set('dispatcher_influxdb', 'target',\n                   'http://{}:{}'.format(ip, 8086))\n\n        LOG.info('Writing to %s', consts.CONF_FILE)\n        with open(consts.CONF_FILE, 'w') as f:\n            parser.write(f)\n\n    def create_grafana(self, args):\n        try:\n            environment_id = args['environment_id']\n        except KeyError:\n            return result_handler(consts.API_ERROR, 'environment_id must be provided')\n\n        try:\n            uuid.UUID(environment_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'invalid environment id')\n\n        try:\n            environment = environment_handler.get_by_uuid(environment_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'no such environment id')\n\n        container_info = environment.container_id\n        container_info = jsonutils.loads(container_info) if container_info else {}\n\n        if not container_info.get('influxdb'):\n            return result_handler(consts.API_ERROR, 'influxdb not set')\n\n        if container_info.get('grafana'):\n            return result_handler(consts.API_ERROR, 'grafana container already exists')\n\n        name = 'grafana-{}'.format(environment_id[:8])\n        port = get_free_port(consts.SERVER_IP)\n        container_id = str(uuid.uuid4())\n\n        args = (name, port, container_id)\n        thread = threading.Thread(target=self._create_grafana, args=args)\n        thread.start()\n\n        container_init_data = {\n            'uuid': container_id,\n            'environment_id': environment_id,\n            'name': name,\n            'port': port,\n            'status': 0\n        }\n        container_handler.insert(container_init_data)\n\n        container_info['grafana'] = container_id\n        environment_info = {'container_id': jsonutils.dumps(container_info)}\n        environment_handler.update_attr(environment_id, environment_info)\n\n        return result_handler(consts.API_SUCCESS, {'uuid': container_id})\n\n    def _create_grafana(self, name, port, container_id):\n        client = Client(base_url=consts.DOCKER_URL)\n\n        try:\n            LOG.info('Checking if grafana image exist')\n            image = '{}:{}'.format(consts.GRAFANA_IMAGE, consts.GRAFANA_TAG)\n            if not self._check_image_exist(client, image):\n                LOG.info('Grafana image not exist, start pulling')\n                client.pull(consts.GRAFANA_IMAGE, consts.GRAFANA_TAG)\n\n            LOG.info('Createing grafana container')\n            container = self._create_grafana_container(client, name, port)\n            LOG.info('Grafana container is created')\n\n            time.sleep(5)\n\n            container = client.inspect_container(container['Id'])\n            ip = container['NetworkSettings']['Networks']['bridge']['IPAddress']\n            LOG.debug('container ip is: %s', ip)\n\n            LOG.info('Creating data source for grafana')\n            self._create_data_source(ip)\n\n            LOG.info('Creating dashboard for grafana')\n            self._create_dashboard(ip)\n\n            container_handler.update_attr(container_id, {'status': 1})\n            LOG.info('Finished')\n        except Exception:\n            container_handler.update_attr(container_id, {'status': 2})\n            LOG.exception('Create grafana failed')\n\n    def _create_dashboard(self, ip):\n        url = 'http://admin:admin@{}:{}/api/dashboards/db'.format(ip, 3000)\n        path = os.path.join(consts.REPOS_DIR, 'dashboard', 'opnfv_yardstick_tc*.json')\n\n        for i in sorted(glob.iglob(path)):\n            with open(i) as f:\n                data = jsonutils.load(f)\n            try:\n                HttpClient().post(url, {'dashboard': data})\n            except Exception:\n                LOG.exception('Create dashboard %s failed', i)\n                raise\n\n    def _create_data_source(self, ip):\n        url = 'http://admin:admin@{}:{}/api/datasources'.format(ip, 3000)\n        influx_conf = utils.parse_ini_file(consts.CONF_FILE).get('dispatcher_influxdb', {})\n\n        data = {\n            \"name\": \"yardstick\",\n            \"type\": \"influxdb\",\n            \"access\": \"proxy\",\n            \"url\": influx_conf.get('target', ''),\n            \"password\": influx_conf.get('password', ''),\n            \"user\": influx_conf.get('username', ''),\n            \"database\": \"yardstick\",\n            \"basicAuth\": True,\n            \"basicAuthUser\": \"admin\",\n            \"basicAuthPassword\": \"admin\",\n            \"isDefault\": False,\n        }\n        try:\n            HttpClient().post(url, data)\n        except Exception:\n            LOG.exception('Create datasources failed')\n            raise\n\n    def _create_grafana_container(self, client, name, port):\n        ports = [3000]\n        port_bindings = {3000: port}\n        restart_policy = {\"MaximumRetryCount\": 0, \"Name\": \"always\"}\n        host_config = client.create_host_config(port_bindings=port_bindings,\n                                                restart_policy=restart_policy)\n\n        LOG.info('Creating container')\n        container = client.create_container(image='%s:%s' %\n                                            (consts.GRAFANA_IMAGE,\n                                             consts.GRAFANA_TAG),\n                                            name=name,\n                                            ports=ports,\n                                            detach=True,\n                                            tty=True,\n                                            host_config=host_config)\n        LOG.info('Starting container')\n        client.start(container)\n        return container\n\n\nclass V2Container(ApiResource):\n\n    def get(self, container_id):\n        try:\n            uuid.UUID(container_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'invalid container id')\n\n        try:\n            container = container_handler.get_by_uuid(container_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'no such container id')\n\n        name = container.name\n        client = Client(base_url=consts.DOCKER_URL)\n        info = client.inspect_container(name)\n\n        data = {\n            'name': name,\n            'status': info.get('State', {}).get('Status', 'error'),\n            'time': info.get('Created'),\n            'port': container.port\n        }\n\n        return result_handler(consts.API_SUCCESS, {'container': data})\n\n    def delete(self, container_id):\n        try:\n            uuid.UUID(container_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'invalid container id')\n\n        try:\n            container = container_handler.get_by_uuid(container_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'no such container id')\n\n        environment_id = container.environment_id\n\n        client = Client(base_url=consts.DOCKER_URL)\n        LOG.info('delete container: %s', container.name)\n        try:\n            client.remove_container(container.name, force=True)\n        except Exception:\n            LOG.exception('delete container failed')\n            return result_handler(consts.API_ERROR, 'delete container failed')\n\n        LOG.info('delete container in database')\n        container_handler.delete_by_uuid(container_id)\n\n        LOG.info('update container in environment')\n        environment = environment_handler.get_by_uuid(environment_id)\n        container_info = jsonutils.loads(environment.container_id)\n        key = next((k for k, v in container_info.items() if v == container_id))\n        container_info.pop(key)\n        environment_delete_data = {\n            'container_id': jsonutils.dumps(container_info)\n        }\n        environment_handler.update_attr(environment_id, environment_delete_data)\n\n        return result_handler(consts.API_SUCCESS, {'container': container_id})\n```\n\n**Usage:**\n1. Create a new API resource class that inherits from `ApiResource`.\n2. Override the `post` and `get` methods to handle the API requests.\n3. Implement the necessary logic to interact with",
    "after": "##############################################################################\n# Copyright (c) 2017 Huawei Technologies Co.,Ltd.\n#\n# All rights reserved. This program and the accompanying materials\n# are made available under the terms of the Apache License, Version 2.0\n# which accompanies this distribution, and is available at\n# http://www.apache.org/licenses/LICENSE-2.0\n##############################################################################\nfrom __future__ import absolute_import\n\nimport logging\nimport threading\nimport time\nimport uuid\nimport os\nimport glob\n\nfrom six.moves import configparser\nfrom oslo_serialization import jsonutils\nfrom docker import Client\n\nfrom api import ApiResource\nfrom api.utils import influx\nfrom api.database.v2.handlers import V2ContainerHandler\nfrom api.database.v2.handlers import V2EnvironmentHandler\nfrom yardstick.common import constants as consts\nfrom yardstick.common import utils\nfrom yardstick.common.utils import result_handler\nfrom yardstick.common.utils import get_free_port\nfrom yardstick.common.httpClient import HttpClient\n\n\nLOG = logging.getLogger(__name__)\nLOG.setLevel(logging.DEBUG)\n\nenvironment_handler = V2EnvironmentHandler()\ncontainer_handler = V2ContainerHandler()\n\n\nclass V2Containers(ApiResource):\n\n    def post(self):\n        return self._dispatch_post()\n\n    def create_influxdb(self, args):\n        try:\n            environment_id = args['environment_id']\n        except KeyError:\n            return result_handler(consts.API_ERROR, 'environment_id must be provided')\n\n        try:\n            uuid.UUID(environment_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'invalid environment id')\n\n        try:\n            environment = environment_handler.get_by_uuid(environment_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'no such environment id')\n\n        container_info = environment.container_id\n        container_info = jsonutils.loads(container_info) if container_info else {}\n\n        if container_info.get('influxdb'):\n            return result_handler(consts.API_ERROR, 'influxdb container already exist')\n\n        name = 'influxdb-{}'.format(environment_id[:8])\n        port = get_free_port(consts.SERVER_IP)\n        container_id = str(uuid.uuid4())\n        LOG.info('%s will launch on : %s', name, port)\n\n        LOG.info('launch influxdb background')\n        args = (name, port, container_id)\n        thread = threading.Thread(target=self._create_influxdb, args=args)\n        thread.start()\n\n        LOG.info('record container in database')\n        container_init_data = {\n            'uuid': container_id,\n            'environment_id': environment_id,\n            'name': name,\n            'port': port,\n            'status': 0\n        }\n        container_handler.insert(container_init_data)\n\n        LOG.info('update container in environment')\n        container_info['influxdb'] = container_id\n        environment_info = {'container_id': jsonutils.dumps(container_info)}\n        environment_handler.update_attr(environment_id, environment_info)\n\n        return result_handler(consts.API_SUCCESS, {'uuid': container_id})\n\n    def _check_image_exist(self, client, t):\n        return any(t in a['RepoTags'][0]\n                   for a in client.images() if a['RepoTags'])\n\n    def _create_influxdb(self, name, port, container_id):\n        client = Client(base_url=consts.DOCKER_URL)\n\n        try:\n            LOG.info('Checking if influxdb image exist')\n            if not self._check_image_exist(client, '%s:%s' %\n                                           (consts.INFLUXDB_IMAGE,\n                                            consts.INFLUXDB_TAG)):\n                LOG.info('Influxdb image not exist, start pulling')\n                client.pull(consts.INFLUXDB_IMAGE, tag=consts.INFLUXDB_TAG)\n\n            LOG.info('Createing influxdb container')\n            container = self._create_influxdb_container(client, name, port)\n            LOG.info('Influxdb container is created')\n\n            time.sleep(5)\n\n            container = client.inspect_container(container['Id'])\n            ip = container['NetworkSettings']['Networks']['bridge']['IPAddress']\n            LOG.debug('container ip is: %s', ip)\n\n            LOG.info('Changing output to influxdb')\n            self._change_output_to_influxdb(ip)\n\n            LOG.info('Config influxdb')\n            self._config_influxdb()\n\n            container_handler.update_attr(container_id, {'status': 1})\n\n            LOG.info('Finished')\n        except Exception:\n            container_handler.update_attr(container_id, {'status': 2})\n            LOG.exception('Creating influxdb failed')\n\n    def _create_influxdb_container(self, client, name, port):\n\n        ports = [port]\n        port_bindings = {8086: port}\n        restart_policy = {\"MaximumRetryCount\": 0, \"Name\": \"always\"}\n        host_config = client.create_host_config(port_bindings=port_bindings,\n                                                restart_policy=restart_policy)\n\n        LOG.info('Creating container')\n        container = client.create_container(image='%s:%s' %\n                                            (consts.INFLUXDB_IMAGE,\n                                             consts.INFLUXDB_TAG),\n                                            ports=ports,\n                                            name=name,\n                                            detach=True,\n                                            tty=True,\n                                            host_config=host_config)\n        LOG.info('Starting container')\n        client.start(container)\n        return container\n\n    def _config_influxdb(self):\n        try:\n            client = influx.get_data_db_client()\n            client.create_user(consts.INFLUXDB_USER,\n                               consts.INFLUXDB_PASS,\n                               consts.INFLUXDB_DB_NAME)\n            client.create_database(consts.INFLUXDB_DB_NAME)\n            LOG.info('Success to config influxDB')\n        except Exception:\n            LOG.exception('Config influxdb failed')\n\n    def _change_output_to_influxdb(self, ip):\n        utils.makedirs(consts.CONF_DIR)\n\n        parser = configparser.ConfigParser()\n        LOG.info('Reading output sample configuration')\n        parser.read(consts.CONF_SAMPLE_FILE)\n\n        LOG.info('Set dispatcher to influxdb')\n        parser.set('DEFAULT', 'dispatcher', 'influxdb')\n        parser.set('dispatcher_influxdb', 'target',\n                   'http://{}:{}'.format(ip, 8086))\n\n        LOG.info('Writing to %s', consts.CONF_FILE)\n        with open(consts.CONF_FILE, 'w') as f:\n            parser.write(f)\n\n    def create_grafana(self, args):\n        try:\n            environment_id = args['environment_id']\n        except KeyError:\n            return result_handler(consts.API_ERROR, 'environment_id must be provided')\n\n        try:\n            uuid.UUID(environment_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'invalid environment id')\n\n        try:\n            environment = environment_handler.get_by_uuid(environment_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'no such environment id')\n\n        container_info = environment.container_id\n        container_info = jsonutils.loads(container_info) if container_info else {}\n\n        if not container_info.get('influxdb'):\n            return result_handler(consts.API_ERROR, 'influxdb not set')\n\n        if container_info.get('grafana'):\n            return result_handler(consts.API_ERROR, 'grafana container already exists')\n\n        name = 'grafana-{}'.format(environment_id[:8])\n        port = get_free_port(consts.SERVER_IP)\n        container_id = str(uuid.uuid4())\n\n        args = (name, port, container_id)\n        thread = threading.Thread(target=self._create_grafana, args=args)\n        thread.start()\n\n        container_init_data = {\n            'uuid': container_id,\n            'environment_id': environment_id,\n            'name': name,\n            'port': port,\n            'status': 0\n        }\n        container_handler.insert(container_init_data)\n\n        container_info['grafana'] = container_id\n        environment_info = {'container_id': jsonutils.dumps(container_info)}\n        environment_handler.update_attr(environment_id, environment_info)\n\n        return result_handler(consts.API_SUCCESS, {'uuid': container_id})\n\n    def _create_grafana(self, name, port, container_id):\n        client = Client(base_url=consts.DOCKER_URL)\n\n        try:\n            LOG.info('Checking if grafana image exist')\n            image = '{}:{}'.format(consts.GRAFANA_IMAGE, consts.GRAFANA_TAG)\n            if not self._check_image_exist(client, image):\n                LOG.info('Grafana image not exist, start pulling')\n                client.pull(consts.GRAFANA_IMAGE, consts.GRAFANA_TAG)\n\n            LOG.info('Createing grafana container')\n            container = self._create_grafana_container(client, name, port)\n            LOG.info('Grafana container is created')\n\n            time.sleep(5)\n\n            container = client.inspect_container(container['Id'])\n            ip = container['NetworkSettings']['Networks']['bridge']['IPAddress']\n            LOG.debug('container ip is: %s', ip)\n\n            LOG.info('Creating data source for grafana')\n            self._create_data_source(ip)\n\n            LOG.info('Creating dashboard for grafana')\n            self._create_dashboard(ip)\n\n            container_handler.update_attr(container_id, {'status': 1})\n            LOG.info('Finished')\n        except Exception:\n            container_handler.update_attr(container_id, {'status': 2})\n            LOG.exception('Create grafana failed')\n\n    def _create_dashboard(self, ip):\n        url = 'http://admin:admin@{}:{}/api/dashboards/db'.format(ip, 3000)\n        path = os.path.join(consts.REPOS_DIR, 'dashboard', 'opnfv_yardstick_tc*.json')\n\n        for i in sorted(glob.iglob(path)):\n            with open(i) as f:\n                data = jsonutils.load(f)\n            try:\n                HttpClient().post(url, {'dashboard': data})\n            except Exception:\n                LOG.exception('Create dashboard %s failed', i)\n                raise\n\n    def _create_data_source(self, ip):\n        url = 'http://admin:admin@{}:{}/api/datasources'.format(ip, 3000)\n        influx_conf = utils.parse_ini_file(consts.CONF_FILE).get('dispatcher_influxdb', {})\n\n        data = {\n            \"name\": \"yardstick\",\n            \"type\": \"influxdb\",\n            \"access\": \"proxy\",\n            \"url\": influx_conf.get('target', ''),\n            \"password\": influx_conf.get('password', ''),\n            \"user\": influx_conf.get('username', ''),\n            \"database\": \"yardstick\",\n            \"basicAuth\": True,\n            \"basicAuthUser\": \"admin\",\n            \"basicAuthPassword\": \"admin\",\n            \"isDefault\": False,\n        }\n        try:\n            HttpClient().post(url, data)\n        except Exception:\n            LOG.exception('Create datasources failed')\n            raise\n\n    def _create_grafana_container(self, client, name, port):\n        ports = [3000]\n        port_bindings = {3000: port}\n        restart_policy = {\"MaximumRetryCount\": 0, \"Name\": \"always\"}\n        host_config = client.create_host_config(port_bindings=port_bindings,\n                                                restart_policy=restart_policy)\n\n        LOG.info('Creating container')\n        container = client.create_container(image='%s:%s' %\n                                            (consts.GRAFANA_IMAGE,\n                                             consts.GRAFANA_TAG),\n                                            name=name,\n                                            ports=ports,\n                                            detach=True,\n                                            tty=True,\n                                            host_config=host_config)\n        LOG.info('Starting container')\n        client.start(container)\n        return container\n\n\nclass V2Container(ApiResource):\n\n    def get(self, container_id):\n        try:\n            uuid.UUID(container_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'invalid container id')\n\n        try:\n            container = container_handler.get_by_uuid(container_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'no such container id')\n\n        name = container.name\n        client = Client(base_url=consts.DOCKER_URL)\n        info = client.inspect_container(name)\n\n        data = {\n            'name': name,\n            'status': info.get('State', {}).get('Status', 'error'),\n            'time': info.get('Created'),\n            'port': container.port\n        }\n\n        return result_handler(consts.API_SUCCESS, {'container': data})\n\n    def delete(self, container_id):\n        try:\n            uuid.UUID(container_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'invalid container id')\n\n        try:\n            container = container_handler.get_by_uuid(container_id)\n        except ValueError:\n            return result_handler(consts.API_ERROR, 'no such container id')\n\n        environment_id = container.environment_id\n\n        client = Client(base_url=consts.DOCKER_URL)\n        LOG.info('delete container: %s', container.name)\n        try:\n            client.remove_container(container.name, force=True)\n        except Exception:\n            LOG.exception('delete container failed')\n            return result_handler(consts.API_ERROR, 'delete container failed')\n\n        LOG.info('delete container in database')\n        container_handler.delete_by_uuid(container_id)\n\n        LOG.info('update container in environment')\n        environment = environment_handler.get_by_uuid(environment_id)\n        container_info = jsonutils.loads(environment.container_id)\n        key = next((k for k, v in container_info.items() if v == container_id))\n        container_info.pop(key)\n        environment_delete_data = {\n            'container_id': jsonutils.dumps(container_info)\n        }\n        environment_handler.update_attr(environment_id, environment_delete_data)\n\n        return result_handler(consts.API_SUCCESS, {'container': container_id})\n```\n\n\n```python\n# docker_container_v2.py\nfrom __future__ import absolute_import\n\nimport logging\n\nfrom six import iteritems\n\nfrom api import ApiResource\nfrom api.database.v2.handlers import V"
  },
  "feature_stats": {
    "indices": [
      2,
      0,
      6378,
      4920,
      4112,
      4074,
      3440,
      5482,
      8919,
      5680,
      9154
    ],
    "f_before": [
      0.0,
      119.9527359008789,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "f_after": [
      0.0,
      119.9527359008789,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "g_before": [
      69.1720199584961,
      0.0,
      11.635873794555664,
      0.0,
      11.467917442321777,
      0.00024581843172200024,
      0.0,
      0.0,
      11.875704765319824,
      12.427691459655762,
      11.34575366973877
    ],
    "g_after": [
      69.1720199584961,
      0.0,
      11.635873794555664,
      0.0,
      11.467917442321777,
      0.00024581843172200024,
      0.0,
      0.0,
      11.875704765319824,
      12.427691459655762,
      11.34575366973877
    ],
    "num_batches_for_stats": 10
  },
  "loss_summary": {
    "train_mean_loss": 7.487854688763618,
    "train_mean_l2": 6.38045088583976,
    "train_mean_l1": 3.5515932783186437,
    "num_steps": 2000,
    "num_batches": 2000
  },
  "feature_std_summary": {
    "plot_path": "outputs/plots/20251128-133020/feature_std_layer_12.html",
    "mean_std": 2.113823652267456,
    "max_std": 93.83219909667969
  }
}