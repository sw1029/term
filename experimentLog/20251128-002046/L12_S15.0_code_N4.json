{
  "model_name": "google/gemma-2-2b-it",
  "layer_idx": 12,
  "command": "main.py sae.loss_option=1 sae.loss_module=option1_loss experiment.use_multi_contrast=true sae.use_l0=true sae.l0_coeff=0.001",
  "sae": {
    "input_dim": 2304,
    "sae_dim": 9216,
    "fixed_v_cnt": 3,
    "batch_size": 4,
    "epochs": 2,
    "max_steps": 2000,
    "l1_coeff": 0.005,
    "l0_coeff": 0.001,
    "use_l0": true,
    "concept_samples_per_label": 100,
    "loss_option": 1,
    "loss_module": "option1_loss",
    "concept_feature_indices": {
      "code": 0,
      "harm": 1,
      "struct": 2
    },
    "alpha_concept": {
      "code": 0.0,
      "harm": 0.0,
      "struct": 0.0
    },
    "positive_targets": {
      "code": 1,
      "harm": 1,
      "struct": 1
    },
    "guidance_method": "contrastive",
    "guidance_margin": 0.0,
    "guidance_coeff": 1.0,
    "guidance_mse_pos_value": 1.0,
    "guidance_mse_neg_value": 0.0,
    "jumprelu_bandwidth": 0.001,
    "jumprelu_init_threshold": 0.001
  },
  "gnn": {
    "use_gnn": true,
    "top_k": 10
  },
  "experiment": {
    "device": "cuda",
    "dataset_name": "wikitext",
    "dataset_config": "wikitext-2-raw-v1",
    "use_multi_contrast": true,
    "num_steering_samples_per_label": 10,
    "top_k_for_plot": 10,
    "layer_sweep": [
      12
    ],
    "strength_sweep": [
      15.0
    ]
  },
  "steering": {
    "label": "code",
    "feature_idx": 0,
    "strength": 15.0
  },
  "prompt": "# \n# Copyright (c) 2017, Massachusetts Institute of Technology All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# Redistributions of source code must retain the above copyright notice, this\n# list of conditions and the following disclaimer.\n#\n# Redistributions in binary form must reproduce the above copyright notice, this\n# list of conditions and the following disclaimer in the documentation and/or\n# other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n\nimport MDSplus\nimport ctypes\n\ndef pointer(x):\n    \"\"\"Returns a ctypes pointer\"\"\"\n    ptr = ctypes.pointer(x)\n    return ptr\n\ndef kill(proc_pid):\n    import psutil\n\n    process = psutil.Process(proc_pid)\n    print \"Process is \", process\n    for proc in process.children(recursive=True):\n        proc.kill()\n    process.kill()\n\n\nclass PICAM(MDSplus.Device):\n    \"\"\"\n    Device class to support Princeton Instruments cameras with the PiCam library.\n\n    methods:\n      init\n      store\n    \"\"\"\n\n    parts = [\n        {'path':':COMMENT','type':'text'},\n        {'path':':SERIAL_NO','type':'text','options':('no_write_shot',)},\n        {'path':':EXPOSURE','type':'numeric','value':1,'options':('no_write_shot',)},\n        {'path':':NUM_FRAMES','type':'numeric','value':30,'options':('no_write_shot',)},\n        {'path':':ROIS','type':'numeric','options':('no_write_shot',)},\n        {'path':':TIMEOUT','type':'numeric','value':100000,'options':('no_write_shot',)},\n        {'path':':TRG_RESPONSE','type':'text', 'value':'StartOnSingleTrigger', 'options':('no_write_shot',)},\n\n        {'path':':MODEL','type':'text','options':('no_write_model','write_once',)},\n        {'path':':SENSOR','type':'text','options':('no_write_model','write_once',)},\n        {'path':':LIB_VERSION','type':'text','options':('no_write_model','write_once',)},\n        {'path':':SENSOR_TEMP','type':'numeric','options':('no_write_model','write_once',)},\n        {'path':':READOUT_TIME','type':'numeric','options':('no_write_model','write_once',)},\n\n        {'path':':FRAMES','type':'numeric','options':('no_write_model','write_once',)},\n\n        {'path':':INIT_ACTION','type':'action',\n         'valueExpr':\"Action(Dispatch('CAMAC_SERVER','INIT',50,None),Method(None,'INIT',head))\",\n         'options':('no_write_shot',)}]\n\n    cameras = []\n\n    class camera_proc():\n        def __init__(self, camera):\n            self.camera = camera\n            self.subproc = None\n\n    def init(self):\n        \"\"\"\n        Init method for the raspberry pi camera device.\n\n        Start by deleting any running subrocesses that may be left\n        over from previous inits, note the subprocess is stored in a\n        class variable (ONLY one of these per server !)\n\n        Read all of the settings and create a script to take the data.\n\n        Note:  This device supports at most 1 camera per server.  Which is\n        OK since the raspberry pis only have one camera port.\n        \"\"\"\n\n        import os\n        import subprocess\n\n        self.debugging = os.getenv('DEBUG_DEVICES')\n        camera = str(self.serial_no.record)\n\n        c_rec = None\n        for c in PICAM.cameras:\n            if c.camera == camera :\n                try:\n                    if self.debugging:\n                        print \"PICAM killing \", c.subproc, c.subproc.pid\n                    kill(c.subproc.pid)\n                except Exception, e:\n                    if self.debugging:\n                        print \"PICAM kill exception\", e\n                    pass\n                c_rec = c\n        if c_rec is None:\n            c = PICAM.camera_proc(camera)\n            PICAM.cameras.append(c)\n        if not c.camera == camera:\n            c = PICAM.camera_proc(camera)\n            PICAM.cameras.append(c)\n\n        tree = self.local_tree\n        shot = self.tree.shot\n        path = self.local_path\n        c.subproc = subprocess.Popen('mdstcl 2>&1', stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True)\n        c.subproc.stdin.write('set tree %s /shot = %d\\n'%(tree, shot,))\n        c.subproc.stdin.write('do/meth %s acquire\\n'%(path,))\n        c.subproc.stdin.write('exit\\n')\n        c.subproc.stdin.flush()\n        return 1\n    INIT=init\n\n    def acquire(self):\n        import os\n        import ctypes as ctypes\n        import numpy as np\n        from MDSplus.mdsExceptions import DevCOMM_ERROR\n        from MDSplus.mdsExceptions import DevBAD_PARAMETER\n        from MDSplus.mdsExceptions import DevPY_INTERFACE_LIBRARY_NOT_FOUND\n\n        try:\n            import PythonForPicam as pfp\n        except:\n            raise DevPY_INTERFACE_LIBRARY_NOT_FOUND(\"Picam error importing PythonForPicam\")\n\n        self.debugging = os.getenv('DEBUG_DEVICES')\n        exposure = float(self.exposure)\n        exposure = pfp.piflt(exposure)\n        num_frames = int(self.num_frames)\n        timeout = int(self.timeout)\n        serial_no = str(self.serial_no.record)\n        try:\n            if self.debugging:\n                print \"PICAM about to try to read the ROIS\"\n            rois = self.rois.data()\n            if self.debugging:\n                print \"PICAM got the rois \", rois\n        except Exception,e:\n            if self.debugging:\n                print \"PICAM could not read the ROIS\"\n            rois = None\n        \n        print \"Acquire  - debugging is \", self.debugging\n\n        # initialize the library\n        pfp.Picam_InitializeLibrary()\n\n        # get library version information\n        major = pfp.piint()\n        minor = pfp.piint()\n        distribution = pfp.piint()\n        release = pfp.piint()\n        pfp.Picam_GetVersion(pointer(major),pointer(minor),pointer(distribution),pointer(release))\n        self.lib_version.record = 'Picam Version %d.%d.%d Released %d' % (major.value,minor.value,distribution.value,release.value,)\n\n        available = ctypes.POINTER(ctypes.c_int)()\n        availableCount = pfp.piint();\n\n        status = pfp.Picam_GetAvailableCameraIDs(ctypes.byref(available), ctypes.byref(availableCount))\n        camera = pfp.PicamHandle()\n        cameras_type = pfp.PicamCameraID*availableCount.value\n        cameras_pointer = ctypes.POINTER(cameras_type)\n        cameras = ctypes.cast(available, cameras_pointer)\n        found = False\n        for c in cameras.contents:\n            if self.debugging:\n                print \"checking \",c.serial_number\n            if c.serial_number == serial_no:\n                status = pfp.Picam_OpenCamera(pointer(c),ctypes.addressof(camera))\n                if not status == \"PicamError_None\":\n                    raise DevCOMM_ERROR(\"PiCam - could not open camera serial no %d - %s\"% (serial_no,status,))\n                found = True\n        if not found:\n            raise DevBAD_PARAMETER(\"PiCam - Could not find camera %d\"%serial_no)\n \n#        Picam_OpenCamera(ctypes.addressof(camera))\n        PicamID = pfp.PicamCameraID()  \n\n        pfp.Picam_GetCameraID(camera,  pointer(PicamID))\n        self.model.record = str(PicamID.model)\n        self.sensor.record = str(PicamID.sensor_name)\n\n        trigger_response = str(self.trg_response.record)\n        if trigger_response == 'NoResponse':\n            trigger_resp = pfp.PicamTriggerResponse_NoResponse\n        elif trigger_response == 'ReadoutPerTrigger':\n            trigger_resp = pfp.PicamTriggerResponse_ReadoutPerTrigger\n        elif trigger_response == 'ShiftPerTrigger':\n            trigger_resp = pfp.PicamTriggerResponse_ShiftPerTrigger\n        elif trigger_response == 'ExposeDuringTriggerPulse':\n            trigger_resp = pfp.PicamTriggerResponse_ExposeDuringTriggerPulse\n        elif trigger_response == 'StartOnSingleTrigger':\n            trigger_resp = pfp.PicamTriggerResponse_StartOnSingleTrigger\n        else:\n            raise DevBAD_PARAMETER(\"PiCam - TRG_RESPONSE must be one of ('NoResponse','ReadoutPerTrigger','ShiftPerTrigger','ExposeDuringTriggerPulse', 'StartOnSingleTrigger')\")\n\n        if self.debugging:\n            print \"Picam_SetParameterIntegerValue(camera, PicamParameter_TriggerResponse,\",trigger_resp,\")\"\n        pfp.Picam_SetParameterIntegerValue( camera, pfp.PicamParameter_TriggerResponse, trigger_resp )\n        pfp.Picam_SetParameterIntegerValue( camera, pfp.PicamParameter_TriggerDetermination, pfp.PicamTriggerDetermination_PositivePolarity )\n        pfp.Picam_SetParameterIntegerValue( camera, pfp.PicamParameter_OutputSignal, pfp.PicamOutputSignal_Exposing )\n\n        # set the exposure\n        if self.debugging:\n            print \"Picam_SetParameterFloatingPointValue( camera, PicamParameter_ExposureTime, \",exposure,\")\"\n        pfp.Picam_SetParameterFloatingPointValue( camera, pfp.PicamParameter_ExposureTime, exposure )\n\n        failCount = pfp.piint()\n        paramsFailed = pfp.piint()\n        if self.debugging:\n            print \"Picam_CommitParameters(camera, pointer(paramsFailed), ctypes.byref(failCount))\"\n        pfp.Picam_CommitParameters(camera, pointer(paramsFailed), ctypes.byref(failCount))\n        if self.debugging:\n            print \"failcount is \", failCount\n        pfp.Picam_DestroyParameters(pointer(paramsFailed))\n\n        width = pfp.piint(0)\n        pfp.Picam_GetParameterIntegerValue( camera, ctypes.c_int(pfp.PicamParameter_SensorActiveWidth), ctypes.byref(width) );\n        width = width.value\n\n        # if there are rois set the rois\n        if rois is not None:\n            if self.debugging:\n                print \"PICAM have rois\"\n            shape = rois.shape\n            if shape[1] == 6 :\n                if self.debugging:\n                    print \"PICAM  it is  nx6\"\n                Rois = pfp.PicamRois(shape[0])\n                for i in range(shape[0]):\n                    Rois.roi_array[i].x = rois[i,0]\n                    Rois.roi_array[i].width = rois[i,1]\n                    Rois.roi_array[i].x_binning = rois[i,2]\n                    Rois.roi_array[i].y = rois[i,3]\n                    Rois.roi_array[i].height = rois[i,4]\n                    Rois.roi_array[i].y_binning = rois[i,5]\n                    width = rois[i,1]\n                if self.debugging:\n                    print \"PICAM The Rois are: \", Rois\n                status = pfp.Picam_SetParameterRoisValue(camera, pfp.PicamParameter_Rois, pointer(Rois)) \n                if not status == \"PicamError_None\":\n                    raise DevCOMM_ERROR(\"PiCam - error setting ROI- %s\"% status)\n                failCount = pfp.piint()\n                paramsFailed = pfp.piint()\n                status = pfp.Picam_CommitParameters(camera, pointer(paramsFailed), ctypes.byref(failCount)) \n                if not status == \"PicamError_None\":\n                    raise DevCOMM_ERROR(\"PiCam - error committing ROI Parameter Change %s\" % status)\n                if not failCount.value == 0:\n                    raise DevCOMM_ERROR(\"PiCam - ROI commit failure count  > 0\", failCount)\n                pfp.Picam_DestroyParameters(pointer(paramsFailed))\n            else:\n                raise DevBAD_PARAMETER(\"PiCAM Rois must be 6xN array\")\n\n        errors = pfp.PicamAcquisitionErrorsMask()\n        readout_count = pfp.pi64s(num_frames)\n        readout_time_out = pfp.piint(-1)\n        available = pfp.PicamAvailableData(0, 0)\n\n        if self.debugging:\n            print \"about to call Picam_Acquire\"\n        status = pfp.Picam_Acquire(camera, readout_count, readout_time_out, ctypes.byref(available), ctypes.byref(errors)) \n        if not status == \"PicamError_None\":\n            print \"Picam_Acquire returned \",status\n            raise DevCOMM_ERROR(\"PiCam - non zero return from Picam_Acquire - %s\" % status)\n\n        if self.debugging:\n            print \"back from aquire\"\n\n        temperature = pfp.piflt(0.0)\n        status = pfp.Picam_GetParameterFloatingPointValue( camera, ctypes.c_int(pfp.PicamParameter_SensorTemperatureReading), ctypes.byref(temperature) )\n        if status == \"PicamError_None\" :\n            self.sensor_temp.record = temperature.value\n            if self.debugging :\n                print \"PICAM read back sensor temperature \", temperature\n        else:\n            print \"PICAM could not read back sensor temperature \", status\n\n        readout_time = pfp.piflt(0.0)\n        status = pfp.Picam_GetParameterFloatingPointValue( camera, ctypes.c_int(pfp.PicamParameter_ReadoutTimeCalculation), ctypes.byref(readout_time) )\n        if status == \"PicamError_None\" :\n            self.readout_time.record = readout_time.value\n            if self.debugging :\n                print \"PICAM read back ReadoutTimeCalculation \", readout_time\n        else:\n            print \"PICAM could not read back readout time \", status\n\n        readoutstride = pfp.piint(0)\n        status = pfp.Picam_GetParameterIntegerValue( camera, ctypes.c_int(pfp.PicamParameter_ReadoutStride), ctypes.byref(readoutstride) )\n        if self.debugging:\n            print \"Picam_GetParameterIntegerValue( camera, ctypes.c_int(PicamParameter_ReadoutStride),\",readoutstride,\" )\", status\n            \n        if  not status == \"PicamError_None\" :\n            raise DevCOMM_ERROR(\"PiCam - could not read readout stride - %s\"% status)\n            \n        sz = readout_count.value*readoutstride.value/2\n        if self.debugging:\n            print \"sz is \",sz, \" num_frames is \", num_frames, \"readout_count is \", readout_count, \" readoutstride is \", readoutstride\n\n        DataArrayType = pfp.pi16u*sz\n\n        \"\"\" Create pointer type for the above array type \"\"\"\n        DataArrayPointerType = ctypes.POINTER(pfp.pi16u*sz)\n\n        if self.debugging:\n            print \"PICAM - cast the read data into the pointer type\"\n        \"\"\" Create an instance of the pointer type, and point it to initial readout contents (memory address?) \"\"\"\n        DataPointer = ctypes.cast(available.initial_readout,DataArrayPointerType)\n\n        if self.debugging:\n            print \"PICAM now deference the pointer\"\n\n        \"\"\" Create a separate array with readout contents \"\"\"\n        data = DataPointer.contents\n        if self.debugging:\n            print \"PICAM - now make an np.empty of shorts (%d)\"%sz\n        ans = np.empty(sz,np.short)\n        if self.debugging:\n            print \"PICAM - fill it in \"\n        ans[:] = data\n        if self.debugging:\n            print \"PICAM reshape the data to be (%d, %d, %d)\"%(num_frames, readoutstride.value/2/width, width)\n        ans = ans.reshape((num_frames, readoutstride.value/2/width, width))\n        self.frames.record = ans\n\n        if self.debugging:\n            print \"un initialize the library\"\n        pfp.Picam_UninitializeLibrary()\n\n        return 1\n\n    ACQUIRE=acquire\n",
  "output": {
    "before": "# \n# Copyright (c) 2017, Massachusetts Institute of Technology All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# Redistributions of source code must retain the above copyright notice, this\n# list of conditions and the following disclaimer.\n#\n# Redistributions in binary form must reproduce the above copyright notice, this\n# list of conditions and the following disclaimer in the documentation and/or\n# other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n\nimport MDSplus\nimport ctypes\n\ndef pointer(x):\n    \"\"\"Returns a ctypes pointer\"\"\"\n    ptr = ctypes.pointer(x)\n    return ptr\n\ndef kill(proc_pid):\n    import psutil\n\n    process = psutil.Process(proc_pid)\n    print \"Process is \", process\n    for proc in process.children(recursive=True):\n        proc.kill()\n    process.kill()\n\n\nclass PICAM(MDSplus.Device):\n    \"\"\"\n    Device class to support Princeton Instruments cameras with the PiCam library.\n\n    methods:\n      init\n      store\n    \"\"\"\n\n    parts = [\n        {'path':':COMMENT','type':'text'},\n        {'path':':SERIAL_NO','type':'text','options':('no_write_shot',)},\n        {'path':':EXPOSURE','type':'numeric','value':1,'options':('no_write_shot',)},\n        {'path':':NUM_FRAMES','type':'numeric','value':30,'options':('no_write_shot',)},\n        {'path':':ROIS','type':'numeric','options':('no_write_shot',)},\n        {'path':':TIMEOUT','type':'numeric','value':100000,'options':('no_write_shot',)},\n        {'path':':TRG_RESPONSE','type':'text', 'value':'StartOnSingleTrigger', 'options':('no_write_shot',)},\n\n        {'path':':MODEL','type':'text','options':('no_write_model','write_once',)},\n        {'path':':SENSOR','type':'text','options':('no_write_model','write_once',)},\n        {'path':':LIB_VERSION','type':'text','options':('no_write_model','write_once',)},\n        {'path':':SENSOR_TEMP','type':'numeric','options':('no_write_model','write_once',)},\n        {'path':':READOUT_TIME','type':'numeric','options':('no_write_model','write_once',)},\n\n        {'path':':FRAMES','type':'numeric','options':('no_write_model','write_once',)},\n\n        {'path':':INIT_ACTION','type':'action',\n         'valueExpr':\"Action(Dispatch('CAMAC_SERVER','INIT',50,None),Method(None,'INIT',head))\",\n         'options':('no_write_shot',)}]\n\n    cameras = []\n\n    class camera_proc():\n        def __init__(self, camera):\n            self.camera = camera\n            self.subproc = None\n\n    def init(self):\n        \"\"\"\n        Init method for the raspberry pi camera device.\n\n        Start by deleting any running subrocesses that may be left\n        over from previous inits, note the subprocess is stored in a\n        class variable (ONLY one of these per server !)\n\n        Read all of the settings and create a script to take the data.\n\n        Note:  This device supports at most 1 camera per server.  Which is\n        OK since the raspberry pis only have one camera port.\n        \"\"\"\n\n        import os\n        import subprocess\n\n        self.debugging = os.getenv('DEBUG_DEVICES')\n        camera = str(self.serial_no.record)\n\n        c_rec = None\n        for c in PICAM.cameras:\n            if c.camera == camera :\n                try:\n                    if self.debugging:\n                        print \"PICAM killing \", c.subproc, c.subproc.pid\n                    kill(c.subproc.pid)\n                except Exception, e:\n                    if self.debugging:\n                        print \"PICAM kill exception\", e\n                    pass\n                c_rec = c\n        if c_rec is None:\n            c = PICAM.camera_proc(camera)\n            PICAM.cameras.append(c)\n        if not c.camera == camera:\n            c = PICAM.camera_proc(camera)\n            PICAM.cameras.append(c)\n\n        tree = self.local_tree\n        shot = self.tree.shot\n        path = self.local_path\n        c.subproc = subprocess.Popen('mdstcl 2>&1', stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True)\n        c.subproc.stdin.write('set tree %s /shot = %d\\n'%(tree, shot,))\n        c.subproc.stdin.write('do/meth %s acquire\\n'%(path,))\n        c.subproc.stdin.write('exit\\n')\n        c.subproc.stdin.flush()\n        return 1\n    INIT=init\n\n    def acquire(self):\n        import os\n        import ctypes as ctypes\n        import numpy as np\n        from MDSplus.mdsExceptions import DevCOMM_ERROR\n        from MDSplus.mdsExceptions import DevBAD_PARAMETER\n        from MDSplus.mdsExceptions import DevPY_INTERFACE_LIBRARY_NOT_FOUND\n\n        try:\n            import PythonForPicam as pfp\n        except:\n            raise DevPY_INTERFACE_LIBRARY_NOT_FOUND(\"Picam error importing PythonForPicam\")\n\n        self.debugging = os.getenv('DEBUG_DEVICES')\n        exposure = float(self.exposure)\n        exposure = pfp.piflt(exposure)\n        num_frames = int(self.num_frames)\n        timeout = int(self.timeout)\n        serial_no = str(self.serial_no.record)\n        try:\n            if self.debugging:\n                print \"PICAM about to try to read the ROIS\"\n            rois = self.rois.data()\n            if self.debugging:\n                print \"PICAM got the rois \", rois\n        except Exception,e:\n            if self.debugging:\n                print \"PICAM could not read the ROIS\"\n            rois = None\n        \n        print \"Acquire  - debugging is \", self.debugging\n\n        # initialize the library\n        pfp.Picam_InitializeLibrary()\n\n        # get library version information\n        major = pfp.piint()\n        minor = pfp.piint()\n        distribution = pfp.piint()\n        release = pfp.piint()\n        pfp.Picam_GetVersion(pointer(major),pointer(minor),pointer(distribution),pointer(release))\n        self.lib_version.record = 'Picam Version %d.%d.%d Released %d' % (major.value,minor.value,distribution.value,release.value,)\n\n        available = ctypes.POINTER(ctypes.c_int)()\n        availableCount = pfp.piint();\n\n        status = pfp.Picam_GetAvailableCameraIDs(ctypes.byref(available), ctypes.byref(availableCount))\n        camera = pfp.PicamHandle()\n        cameras_type = pfp.PicamCameraID*availableCount.value\n        cameras_pointer = ctypes.POINTER(cameras_type)\n        cameras = ctypes.cast(available, cameras_pointer)\n        found = False\n        for c in cameras.contents:\n            if self.debugging:\n                print \"checking \",c.serial_number\n            if c.serial_number == serial_no:\n                status = pfp.Picam_OpenCamera(pointer(c),ctypes.addressof(camera))\n                if not status == \"PicamError_None\":\n                    raise DevCOMM_ERROR(\"PiCam - could not open camera serial no %d - %s\"% (serial_no,status,))\n                found = True\n        if not found:\n            raise DevBAD_PARAMETER(\"PiCam - Could not find camera %d\"%serial_no)\n \n#        Picam_OpenCamera(ctypes.addressof(camera))\n        PicamID = pfp.PicamCameraID()  \n\n        pfp.Picam_GetCameraID(camera,  pointer(PicamID))\n        self.model.record = str(PicamID.model)\n        self.sensor.record = str(PicamID.sensor_name)\n\n        trigger_response = str(self.trg_response.record)\n        if trigger_response == 'NoResponse':\n            trigger_resp = pfp.PicamTriggerResponse_NoResponse\n        elif trigger_response == 'ReadoutPerTrigger':\n            trigger_resp = pfp.PicamTriggerResponse_ReadoutPerTrigger\n        elif trigger_response == 'ShiftPerTrigger':\n            trigger_resp = pfp.PicamTriggerResponse_ShiftPerTrigger\n        elif trigger_response == 'ExposeDuringTriggerPulse':\n            trigger_resp = pfp.PicamTriggerResponse_ExposeDuringTriggerPulse\n        elif trigger_response == 'StartOnSingleTrigger':\n            trigger_resp = pfp.PicamTriggerResponse_StartOnSingleTrigger\n        else:\n            raise DevBAD_PARAMETER(\"PiCam - TRG_RESPONSE must be one of ('NoResponse','ReadoutPerTrigger','ShiftPerTrigger','ExposeDuringTriggerPulse', 'StartOnSingleTrigger')\")\n\n        if self.debugging:\n            print \"Picam_SetParameterIntegerValue(camera, PicamParameter_TriggerResponse,\",trigger_resp,\")\"\n        pfp.Picam_SetParameterIntegerValue( camera, pfp.PicamParameter_TriggerResponse, trigger_resp )\n        pfp.Picam_SetParameterIntegerValue( camera, pfp.PicamParameter_TriggerDetermination, pfp.PicamTriggerDetermination_PositivePolarity )\n        pfp.Picam_SetParameterIntegerValue( camera, pfp.PicamParameter_OutputSignal, pfp.PicamOutputSignal_Exposing )\n\n        # set the exposure\n        if self.debugging:\n            print \"Picam_SetParameterFloatingPointValue( camera, PicamParameter_ExposureTime, \",exposure,\")\"\n        pfp.Picam_SetParameterFloatingPointValue( camera, pfp.PicamParameter_ExposureTime, exposure )\n\n        failCount = pfp.piint()\n        paramsFailed = pfp.piint()\n        if self.debugging:\n            print \"Picam_CommitParameters(camera, pointer(paramsFailed), ctypes.byref(failCount))\"\n        pfp.Picam_CommitParameters(camera, pointer(paramsFailed), ctypes.byref(failCount))\n        if self.debugging:\n            print \"failcount is \", failCount\n        pfp.Picam_DestroyParameters(pointer(paramsFailed))\n\n        width = pfp.piint(0)\n        pfp.Picam_GetParameterIntegerValue( camera, ctypes.c_int(pfp.PicamParameter_SensorActiveWidth), ctypes.byref(width) );\n        width = width.value\n\n        # if there are rois set the rois\n        if rois is not None:\n            if self.debugging:\n                print \"PICAM have rois\"\n            shape = rois.shape\n            if shape[1] == 6 :\n                if self.debugging:\n                    print \"PICAM  it is  nx6\"\n                Rois = pfp.PicamRois(shape[0])\n                for i in range(shape[0]):\n                    Rois.roi_array[i].x = rois[i,0]\n                    Rois.roi_array[i].width = rois[i,1]\n                    Rois.roi_array[i].x_binning = rois[i,2]\n                    Rois.roi_array[i].y = rois[i,3]\n                    Rois.roi_array[i].height = rois[i,4]\n                    Rois.roi_array[i].y_binning = rois[i,5]\n                    width = rois[i,1]\n                if self.debugging:\n                    print \"PICAM The Rois are: \", Rois\n                status = pfp.Picam_SetParameterRoisValue(camera, pfp.PicamParameter_Rois, pointer(Rois)) \n                if not status == \"PicamError_None\":\n                    raise DevCOMM_ERROR(\"PiCam - error setting ROI- %s\"% status)\n                failCount = pfp.piint()\n                paramsFailed = pfp.piint()\n                status = pfp.Picam_CommitParameters(camera, pointer(paramsFailed), ctypes.byref(failCount)) \n                if not status == \"PicamError_None\":\n                    raise DevCOMM_ERROR(\"PiCam - error committing ROI Parameter Change %s\" % status)\n                if not failCount.value == 0:\n                    raise DevCOMM_ERROR(\"PiCam - ROI commit failure count  > 0\", failCount)\n                pfp.Picam_DestroyParameters(pointer(paramsFailed))\n            else:\n                raise DevBAD_PARAMETER(\"PiCAM Rois must be 6xN array\")\n\n        errors = pfp.PicamAcquisitionErrorsMask()\n        readout_count = pfp.pi64s(num_frames)\n        readout_time_out = pfp.piint(-1)\n        available = pfp.PicamAvailableData(0, 0)\n\n        if self.debugging:\n            print \"about to call Picam_Acquire\"\n        status = pfp.Picam_Acquire(camera, readout_count, readout_time_out, ctypes.byref(available), ctypes.byref(errors)) \n        if not status == \"PicamError_None\":\n            print \"Picam_Acquire returned \",status\n            raise DevCOMM_ERROR(\"PiCam - non zero return from Picam_Acquire - %s\" % status)\n\n        if self.debugging:\n            print \"back from aquire\"\n\n        temperature = pfp.piflt(0.0)\n        status = pfp.Picam_GetParameterFloatingPointValue( camera, ctypes.c_int(pfp.PicamParameter_SensorTemperatureReading), ctypes.byref(temperature) )\n        if status == \"PicamError_None\" :\n            self.sensor_temp.record = temperature.value\n            if self.debugging :\n                print \"PICAM read back sensor temperature \", temperature\n        else:\n            print \"PICAM could not read back sensor temperature \", status\n\n        readout_time = pfp.piflt(0.0)\n        status = pfp.Picam_GetParameterFloatingPointValue( camera, ctypes.c_int(pfp.PicamParameter_ReadoutTimeCalculation), ctypes.byref(readout_time) )\n        if status == \"PicamError_None\" :\n            self.readout_time.record = readout_time.value\n            if self.debugging :\n                print \"PICAM read back ReadoutTimeCalculation \", readout_time\n        else:\n            print \"PICAM could not read back readout time \", status\n\n        readoutstride = pfp.piint(0)\n        status = pfp.Picam_GetParameterIntegerValue( camera, ctypes.c_int(pfp.PicamParameter_ReadoutStride), ctypes.byref(readoutstride) )\n        if self.debugging:\n            print \"Picam_GetParameterIntegerValue( camera, ctypes.c_int(PicamParameter_ReadoutStride),\",readoutstride,\" )\", status\n            \n        if  not status == \"PicamError_None\" :\n            raise DevCOMM_ERROR(\"PiCam - could not read readout stride - %s\"% status)\n            \n        sz = readout_count.value*readoutstride.value/2\n        if self.debugging:\n            print \"sz is \",sz, \" num_frames is \", num_frames, \"readout_count is \", readout_count, \" readoutstride is \", readoutstride\n\n        DataArrayType = pfp.pi16u*sz\n\n        \"\"\" Create pointer type for the above array type \"\"\"\n        DataArrayPointerType = ctypes.POINTER(pfp.pi16u*sz)\n\n        if self.debugging:\n            print \"PICAM - cast the read data into the pointer type\"\n        \"\"\" Create an instance of the pointer type, and point it to initial readout contents (memory address?) \"\"\"\n        DataPointer = ctypes.cast(available.initial_readout,DataArrayPointerType)\n\n        if self.debugging:\n            print \"PICAM now deference the pointer\"\n\n        \"\"\" Create a separate array with readout contents \"\"\"\n        data = DataPointer.contents\n        if self.debugging:\n            print \"PICAM - now make an np.empty of shorts (%d)\"%sz\n        ans = np.empty(sz,np.short)\n        if self.debugging:\n            print \"PICAM - fill it in \"\n        ans[:] = data\n        if self.debugging:\n            print \"PICAM reshape the data to be (%d, %d, %d)\"%(num_frames, readoutstride.value/2/width, width)\n        ans = ans.reshape((num_frames, readoutstride.value/2/width, width))\n        self.frames.record = ans\n\n        if self.debugging:\n            print \"un initialize the library\"\n        pfp.Picam_UninitializeLibrary()\n\n        return 1\n\n    ACQUIRE=acquire\n    \n        \n# Example usage\nif __name__ == '__main__':\n    # Initialize the device\n    device = PICAM()\n\n    # Acquire data\n    device.acquire()\n    \n```\n\n**Explanation:**\n*",
    "after": "# \n# Copyright (c) 2017, Massachusetts Institute of Technology All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# Redistributions of source code must retain the above copyright notice, this\n# list of conditions and the following disclaimer.\n#\n# Redistributions in binary form must reproduce the above copyright notice, this\n# list of conditions and the following disclaimer in the documentation and/or\n# other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n\nimport MDSplus\nimport ctypes\n\ndef pointer(x):\n    \"\"\"Returns a ctypes pointer\"\"\"\n    ptr = ctypes.pointer(x)\n    return ptr\n\ndef kill(proc_pid):\n    import psutil\n\n    process = psutil.Process(proc_pid)\n    print \"Process is \", process\n    for proc in process.children(recursive=True):\n        proc.kill()\n    process.kill()\n\n\nclass PICAM(MDSplus.Device):\n    \"\"\"\n    Device class to support Princeton Instruments cameras with the PiCam library.\n\n    methods:\n      init\n      store\n    \"\"\"\n\n    parts = [\n        {'path':':COMMENT','type':'text'},\n        {'path':':SERIAL_NO','type':'text','options':('no_write_shot',)},\n        {'path':':EXPOSURE','type':'numeric','value':1,'options':('no_write_shot',)},\n        {'path':':NUM_FRAMES','type':'numeric','value':30,'options':('no_write_shot',)},\n        {'path':':ROIS','type':'numeric','options':('no_write_shot',)},\n        {'path':':TIMEOUT','type':'numeric','value':100000,'options':('no_write_shot',)},\n        {'path':':TRG_RESPONSE','type':'text', 'value':'StartOnSingleTrigger', 'options':('no_write_shot',)},\n\n        {'path':':MODEL','type':'text','options':('no_write_model','write_once',)},\n        {'path':':SENSOR','type':'text','options':('no_write_model','write_once',)},\n        {'path':':LIB_VERSION','type':'text','options':('no_write_model','write_once',)},\n        {'path':':SENSOR_TEMP','type':'numeric','options':('no_write_model','write_once',)},\n        {'path':':READOUT_TIME','type':'numeric','options':('no_write_model','write_once',)},\n\n        {'path':':FRAMES','type':'numeric','options':('no_write_model','write_once',)},\n\n        {'path':':INIT_ACTION','type':'action',\n         'valueExpr':\"Action(Dispatch('CAMAC_SERVER','INIT',50,None),Method(None,'INIT',head))\",\n         'options':('no_write_shot',)}]\n\n    cameras = []\n\n    class camera_proc():\n        def __init__(self, camera):\n            self.camera = camera\n            self.subproc = None\n\n    def init(self):\n        \"\"\"\n        Init method for the raspberry pi camera device.\n\n        Start by deleting any running subrocesses that may be left\n        over from previous inits, note the subprocess is stored in a\n        class variable (ONLY one of these per server !)\n\n        Read all of the settings and create a script to take the data.\n\n        Note:  This device supports at most 1 camera per server.  Which is\n        OK since the raspberry pis only have one camera port.\n        \"\"\"\n\n        import os\n        import subprocess\n\n        self.debugging = os.getenv('DEBUG_DEVICES')\n        camera = str(self.serial_no.record)\n\n        c_rec = None\n        for c in PICAM.cameras:\n            if c.camera == camera :\n                try:\n                    if self.debugging:\n                        print \"PICAM killing \", c.subproc, c.subproc.pid\n                    kill(c.subproc.pid)\n                except Exception, e:\n                    if self.debugging:\n                        print \"PICAM kill exception\", e\n                    pass\n                c_rec = c\n        if c_rec is None:\n            c = PICAM.camera_proc(camera)\n            PICAM.cameras.append(c)\n        if not c.camera == camera:\n            c = PICAM.camera_proc(camera)\n            PICAM.cameras.append(c)\n\n        tree = self.local_tree\n        shot = self.tree.shot\n        path = self.local_path\n        c.subproc = subprocess.Popen('mdstcl 2>&1', stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True)\n        c.subproc.stdin.write('set tree %s /shot = %d\\n'%(tree, shot,))\n        c.subproc.stdin.write('do/meth %s acquire\\n'%(path,))\n        c.subproc.stdin.write('exit\\n')\n        c.subproc.stdin.flush()\n        return 1\n    INIT=init\n\n    def acquire(self):\n        import os\n        import ctypes as ctypes\n        import numpy as np\n        from MDSplus.mdsExceptions import DevCOMM_ERROR\n        from MDSplus.mdsExceptions import DevBAD_PARAMETER\n        from MDSplus.mdsExceptions import DevPY_INTERFACE_LIBRARY_NOT_FOUND\n\n        try:\n            import PythonForPicam as pfp\n        except:\n            raise DevPY_INTERFACE_LIBRARY_NOT_FOUND(\"Picam error importing PythonForPicam\")\n\n        self.debugging = os.getenv('DEBUG_DEVICES')\n        exposure = float(self.exposure)\n        exposure = pfp.piflt(exposure)\n        num_frames = int(self.num_frames)\n        timeout = int(self.timeout)\n        serial_no = str(self.serial_no.record)\n        try:\n            if self.debugging:\n                print \"PICAM about to try to read the ROIS\"\n            rois = self.rois.data()\n            if self.debugging:\n                print \"PICAM got the rois \", rois\n        except Exception,e:\n            if self.debugging:\n                print \"PICAM could not read the ROIS\"\n            rois = None\n        \n        print \"Acquire  - debugging is \", self.debugging\n\n        # initialize the library\n        pfp.Picam_InitializeLibrary()\n\n        # get library version information\n        major = pfp.piint()\n        minor = pfp.piint()\n        distribution = pfp.piint()\n        release = pfp.piint()\n        pfp.Picam_GetVersion(pointer(major),pointer(minor),pointer(distribution),pointer(release))\n        self.lib_version.record = 'Picam Version %d.%d.%d Released %d' % (major.value,minor.value,distribution.value,release.value,)\n\n        available = ctypes.POINTER(ctypes.c_int)()\n        availableCount = pfp.piint();\n\n        status = pfp.Picam_GetAvailableCameraIDs(ctypes.byref(available), ctypes.byref(availableCount))\n        camera = pfp.PicamHandle()\n        cameras_type = pfp.PicamCameraID*availableCount.value\n        cameras_pointer = ctypes.POINTER(cameras_type)\n        cameras = ctypes.cast(available, cameras_pointer)\n        found = False\n        for c in cameras.contents:\n            if self.debugging:\n                print \"checking \",c.serial_number\n            if c.serial_number == serial_no:\n                status = pfp.Picam_OpenCamera(pointer(c),ctypes.addressof(camera))\n                if not status == \"PicamError_None\":\n                    raise DevCOMM_ERROR(\"PiCam - could not open camera serial no %d - %s\"% (serial_no,status,))\n                found = True\n        if not found:\n            raise DevBAD_PARAMETER(\"PiCam - Could not find camera %d\"%serial_no)\n \n#        Picam_OpenCamera(ctypes.addressof(camera))\n        PicamID = pfp.PicamCameraID()  \n\n        pfp.Picam_GetCameraID(camera,  pointer(PicamID))\n        self.model.record = str(PicamID.model)\n        self.sensor.record = str(PicamID.sensor_name)\n\n        trigger_response = str(self.trg_response.record)\n        if trigger_response == 'NoResponse':\n            trigger_resp = pfp.PicamTriggerResponse_NoResponse\n        elif trigger_response == 'ReadoutPerTrigger':\n            trigger_resp = pfp.PicamTriggerResponse_ReadoutPerTrigger\n        elif trigger_response == 'ShiftPerTrigger':\n            trigger_resp = pfp.PicamTriggerResponse_ShiftPerTrigger\n        elif trigger_response == 'ExposeDuringTriggerPulse':\n            trigger_resp = pfp.PicamTriggerResponse_ExposeDuringTriggerPulse\n        elif trigger_response == 'StartOnSingleTrigger':\n            trigger_resp = pfp.PicamTriggerResponse_StartOnSingleTrigger\n        else:\n            raise DevBAD_PARAMETER(\"PiCam - TRG_RESPONSE must be one of ('NoResponse','ReadoutPerTrigger','ShiftPerTrigger','ExposeDuringTriggerPulse', 'StartOnSingleTrigger')\")\n\n        if self.debugging:\n            print \"Picam_SetParameterIntegerValue(camera, PicamParameter_TriggerResponse,\",trigger_resp,\")\"\n        pfp.Picam_SetParameterIntegerValue( camera, pfp.PicamParameter_TriggerResponse, trigger_resp )\n        pfp.Picam_SetParameterIntegerValue( camera, pfp.PicamParameter_TriggerDetermination, pfp.PicamTriggerDetermination_PositivePolarity )\n        pfp.Picam_SetParameterIntegerValue( camera, pfp.PicamParameter_OutputSignal, pfp.PicamOutputSignal_Exposing )\n\n        # set the exposure\n        if self.debugging:\n            print \"Picam_SetParameterFloatingPointValue( camera, PicamParameter_ExposureTime, \",exposure,\")\"\n        pfp.Picam_SetParameterFloatingPointValue( camera, pfp.PicamParameter_ExposureTime, exposure )\n\n        failCount = pfp.piint()\n        paramsFailed = pfp.piint()\n        if self.debugging:\n            print \"Picam_CommitParameters(camera, pointer(paramsFailed), ctypes.byref(failCount))\"\n        pfp.Picam_CommitParameters(camera, pointer(paramsFailed), ctypes.byref(failCount))\n        if self.debugging:\n            print \"failcount is \", failCount\n        pfp.Picam_DestroyParameters(pointer(paramsFailed))\n\n        width = pfp.piint(0)\n        pfp.Picam_GetParameterIntegerValue( camera, ctypes.c_int(pfp.PicamParameter_SensorActiveWidth), ctypes.byref(width) );\n        width = width.value\n\n        # if there are rois set the rois\n        if rois is not None:\n            if self.debugging:\n                print \"PICAM have rois\"\n            shape = rois.shape\n            if shape[1] == 6 :\n                if self.debugging:\n                    print \"PICAM  it is  nx6\"\n                Rois = pfp.PicamRois(shape[0])\n                for i in range(shape[0]):\n                    Rois.roi_array[i].x = rois[i,0]\n                    Rois.roi_array[i].width = rois[i,1]\n                    Rois.roi_array[i].x_binning = rois[i,2]\n                    Rois.roi_array[i].y = rois[i,3]\n                    Rois.roi_array[i].height = rois[i,4]\n                    Rois.roi_array[i].y_binning = rois[i,5]\n                    width = rois[i,1]\n                if self.debugging:\n                    print \"PICAM The Rois are: \", Rois\n                status = pfp.Picam_SetParameterRoisValue(camera, pfp.PicamParameter_Rois, pointer(Rois)) \n                if not status == \"PicamError_None\":\n                    raise DevCOMM_ERROR(\"PiCam - error setting ROI- %s\"% status)\n                failCount = pfp.piint()\n                paramsFailed = pfp.piint()\n                status = pfp.Picam_CommitParameters(camera, pointer(paramsFailed), ctypes.byref(failCount)) \n                if not status == \"PicamError_None\":\n                    raise DevCOMM_ERROR(\"PiCam - error committing ROI Parameter Change %s\" % status)\n                if not failCount.value == 0:\n                    raise DevCOMM_ERROR(\"PiCam - ROI commit failure count  > 0\", failCount)\n                pfp.Picam_DestroyParameters(pointer(paramsFailed))\n            else:\n                raise DevBAD_PARAMETER(\"PiCAM Rois must be 6xN array\")\n\n        errors = pfp.PicamAcquisitionErrorsMask()\n        readout_count = pfp.pi64s(num_frames)\n        readout_time_out = pfp.piint(-1)\n        available = pfp.PicamAvailableData(0, 0)\n\n        if self.debugging:\n            print \"about to call Picam_Acquire\"\n        status = pfp.Picam_Acquire(camera, readout_count, readout_time_out, ctypes.byref(available), ctypes.byref(errors)) \n        if not status == \"PicamError_None\":\n            print \"Picam_Acquire returned \",status\n            raise DevCOMM_ERROR(\"PiCam - non zero return from Picam_Acquire - %s\" % status)\n\n        if self.debugging:\n            print \"back from aquire\"\n\n        temperature = pfp.piflt(0.0)\n        status = pfp.Picam_GetParameterFloatingPointValue( camera, ctypes.c_int(pfp.PicamParameter_SensorTemperatureReading), ctypes.byref(temperature) )\n        if status == \"PicamError_None\" :\n            self.sensor_temp.record = temperature.value\n            if self.debugging :\n                print \"PICAM read back sensor temperature \", temperature\n        else:\n            print \"PICAM could not read back sensor temperature \", status\n\n        readout_time = pfp.piflt(0.0)\n        status = pfp.Picam_GetParameterFloatingPointValue( camera, ctypes.c_int(pfp.PicamParameter_ReadoutTimeCalculation), ctypes.byref(readout_time) )\n        if status == \"PicamError_None\" :\n            self.readout_time.record = readout_time.value\n            if self.debugging :\n                print \"PICAM read back ReadoutTimeCalculation \", readout_time\n        else:\n            print \"PICAM could not read back readout time \", status\n\n        readoutstride = pfp.piint(0)\n        status = pfp.Picam_GetParameterIntegerValue( camera, ctypes.c_int(pfp.PicamParameter_ReadoutStride), ctypes.byref(readoutstride) )\n        if self.debugging:\n            print \"Picam_GetParameterIntegerValue( camera, ctypes.c_int(PicamParameter_ReadoutStride),\",readoutstride,\" )\", status\n            \n        if  not status == \"PicamError_None\" :\n            raise DevCOMM_ERROR(\"PiCam - could not read readout stride - %s\"% status)\n            \n        sz = readout_count.value*readoutstride.value/2\n        if self.debugging:\n            print \"sz is \",sz, \" num_frames is \", num_frames, \"readout_count is \", readout_count, \" readoutstride is \", readoutstride\n\n        DataArrayType = pfp.pi16u*sz\n\n        \"\"\" Create pointer type for the above array type \"\"\"\n        DataArrayPointerType = ctypes.POINTER(pfp.pi16u*sz)\n\n        if self.debugging:\n            print \"PICAM - cast the read data into the pointer type\"\n        \"\"\" Create an instance of the pointer type, and point it to initial readout contents (memory address?) \"\"\"\n        DataPointer = ctypes.cast(available.initial_readout,DataArrayPointerType)\n\n        if self.debugging:\n            print \"PICAM now deference the pointer\"\n\n        \"\"\" Create a separate array with readout contents \"\"\"\n        data = DataPointer.contents\n        if self.debugging:\n            print \"PICAM - now make an np.empty of shorts (%d)\"%sz\n        ans = np.empty(sz,np.short)\n        if self.debugging:\n            print \"PICAM - fill it in \"\n        ans[:] = data\n        if self.debugging:\n            print \"PICAM reshape the data to be (%d, %d, %d)\"%(num_frames, readoutstride.value/2/width, width)\n        ans = ans.reshape((num_frames, readoutstride.value/2/width, width))\n        self.frames.record = ans\n\n        if self.debugging:\n            print \"un initialize the library\"\n        pfp.Picam_UninitializeLibrary()\n\n        return 1\n\n    ACQUIRE=acquire\n    \n    def __init__(self):\n        # Initialize parent class\n        super(PICAM, self).__init__()\n\n        self.init()\n        \n# $module = PICAM.PICAM\n# $module.init"
  },
  "feature_stats": {
    "indices": [
      0,
      2,
      6926,
      4819,
      426,
      4879,
      3414,
      7803,
      439,
      5549,
      8891
    ],
    "f_before": [
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "f_after": [
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "g_before": [
      0.0,
      0.0,
      0.010724452324211597,
      0.0,
      0.0,
      0.00037313811480998993,
      0.0,
      0.0,
      0.3072584867477417,
      0.0,
      0.0
    ],
    "g_after": [
      0.0,
      0.0,
      0.010724452324211597,
      0.0,
      0.0,
      0.00037313811480998993,
      0.0,
      0.0,
      0.3072584867477417,
      0.0,
      0.0
    ],
    "num_batches_for_stats": 10
  },
  "loss_summary": {
    "train_mean_loss": 9.426064644694328,
    "train_mean_l2": 6.208298320971429,
    "train_mean_l1": 2.753059552669525,
    "num_steps": 2000,
    "num_batches": 2000
  },
  "feature_std_summary": {
    "plot_path": "outputs/plots/20251128-002046/feature_std_layer_12.html",
    "mean_std": 1.2004650831222534,
    "max_std": 24.676727294921875
  }
}