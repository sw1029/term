{
  "model_name": "google/gemma-2-2b-it",
  "layer_idx": 12,
  "command": "main.py sae.loss_option=1 sae.loss_module=option1_loss experiment.use_multi_contrast=true sae.use_l0=true sae.l0_coeff=0.001",
  "sae": {
    "input_dim": 2304,
    "sae_dim": 9216,
    "fixed_v_cnt": 3,
    "batch_size": 4,
    "epochs": 2,
    "max_steps": 2000,
    "l1_coeff": 0.005,
    "l0_coeff": 0.001,
    "use_l0": true,
    "concept_samples_per_label": 100,
    "loss_option": 1,
    "loss_module": "option1_loss",
    "concept_feature_indices": {
      "code": 0,
      "harm": 1,
      "struct": 2
    },
    "alpha_concept": {
      "code": 0.0,
      "harm": 0.0,
      "struct": 0.0
    },
    "positive_targets": {
      "code": 1,
      "harm": 1,
      "struct": 1
    },
    "guidance_method": "contrastive",
    "guidance_margin": 0.0,
    "guidance_coeff": 1.0,
    "guidance_mse_pos_value": 1.0,
    "guidance_mse_neg_value": 0.0,
    "jumprelu_bandwidth": 0.001,
    "jumprelu_init_threshold": 0.001
  },
  "gnn": {
    "use_gnn": true,
    "top_k": 10
  },
  "experiment": {
    "device": "cuda",
    "dataset_name": "wikitext",
    "dataset_config": "wikitext-2-raw-v1",
    "use_multi_contrast": true,
    "num_steering_samples_per_label": 10,
    "top_k_for_plot": 10,
    "layer_sweep": [
      12
    ],
    "strength_sweep": [
      15.0
    ]
  },
  "steering": {
    "label": "harm",
    "feature_idx": 1,
    "strength": 15.0
  },
  "prompt": "# -*- coding: utf-8 -*-\n\nimport re\n\n\ndef write_history(filename, history):\n    \n    with open(filename, 'w') as f:\n        \n        start = True\n        \n        for x, y, z, alpha, delta in history:\n            delta_str = '[' + ','.join(str(d) for d in delta) + ']'\n            if start:\n                f.write(f\"({x}, {y}: {z}) {alpha}; {delta_str}\")\n                start = False\n            else:\n                f.write(f\"\\n({x}, {y}: {z}) {alpha}; {delta_str}\")\n                \n\ndef _split_floats(floats):\n    \n    return [float(item) for item in floats.split(',')]\n\n\ndef parse_history(filename):\n    \n    event_regex = re.compile(r\"\\((\\d+)\\,\\s*(\\d+)\\:\\s*(\\d+)\\)\\;?\\s*(\\d+\\.?\\d*e?-?\\d+)\\;\\s*\\[(?P<delta>(\\s*\\d+\\.?\\d*e?-?\\d+,?)+)\\]\")\n    \n    with open(filename, 'r') as f:\n        \n        lines = f.readlines()\n      \n    history = []\n    for line in lines:\n        \n        match = event_regex.match(line.strip())\n        \n        if match:\n            \n            x = int(match.group(1))\n            y = int(match.group(2))\n            z = int(match.group(3))\n            alpha = float(match.group(4))\n            delta = _split_floats(match.group('delta'))\n            \n        history.append((x, y, z, alpha, delta))\n            \n    return history\n\n\ndef _write_matrix(f, V, D):\n    \n    for i in range(len(V)):\n        f.write(f'\\n{V[i]}  ')\n        for j in range(len(V)):\n            f.write('{: 12.8f}'.format(D[i,j]))\n\n\ndef write_recognition(filename, tree, matrices=True):\n    \n    with open(filename, 'w') as f:\n        \n        start = True\n        for v in tree.preorder():\n            \n            if not start:\n                f.write('\\n')\n                f.write(80 * '-')\n                f.write('\\n')\n            else:\n                start = False\n                \n            f.write(f'n={v.n}\\n')\n            if v.R_step is not None:\n                f.write('(result of R-step: ({},{}:{}){:.8f})\\n'.format(*v.R_step))\n            f.write(f'V={v.V}\\n')\n            f.write(f'total successes of this branch: {v.valid_ways}\\n')\n            \n            if matrices and v.D is not None:\n                f.write(f'Matrix on {v.n} elements:\\n')\n                _write_matrix(f, v.V, v.D)\n                f.write('\\n')\n                \n            if not v.valid_ways:\n                f.write(f'reason of abort: {v.info}\\n')\n        \n        ",
  "output": {
    "before": "# -*- coding: utf-8 -*-\n\nimport re\n\n\ndef write_history(filename, history):\n    \n    with open(filename, 'w') as f:\n        \n        start = True\n        \n        for x, y, z, alpha, delta in history:\n            delta_str = '[' + ','.join(str(d) for d in delta) + ']'\n            if start:\n                f.write(f\"({x}, {y}: {z}) {alpha}; {delta_str}\")\n                start = False\n            else:\n                f.write(f\"\\n({x}, {y}: {z}) {alpha}; {delta_str}\")\n                \n\ndef _split_floats(floats):\n    \n    return [float(item) for item in floats.split(',')]\n\n\ndef parse_history(filename):\n    \n    event_regex = re.compile(r\"\\((\\d+)\\,\\s*(\\d+)\\:\\s*(\\d+)\\)\\;?\\s*(\\d+\\.?\\d*e?-?\\d+)\\;\\s*\\[(?P<delta>(\\s*\\d+\\.?\\d*e?-?\\d+,?)+)\\]\")\n    \n    with open(filename, 'r') as f:\n        \n        lines = f.readlines()\n      \n    history = []\n    for line in lines:\n        \n        match = event_regex.match(line.strip())\n        \n        if match:\n            \n            x = int(match.group(1))\n            y = int(match.group(2))\n            z = int(match.group(3))\n            alpha = float(match.group(4))\n            delta = _split_floats(match.group('delta'))\n            \n        history.append((x, y, z, alpha, delta))\n            \n    return history\n\n\ndef _write_matrix(f, V, D):\n    \n    for i in range(len(V)):\n        f.write(f'\\n{V[i]}  ')\n        for j in range(len(V)):\n            f.write('{: 12.8f}'.format(D[i,j]))\n\n\ndef write_recognition(filename, tree, matrices=True):\n    \n    with open(filename, 'w') as f:\n        \n        start = True\n        for v in tree.preorder():\n            \n            if not start:\n                f.write('\\n')\n                f.write(80 * '-')\n                f.write('\\n')\n            else:\n                start = False\n                \n            f.write(f'n={v.n}\\n')\n            if v.R_step is not None:\n                f.write('(result of R-step: ({},{}:{}){:.8f})\\n'.format(*v.R_step))\n            f.write(f'V={v.V}\\n')\n            f.write(f'total successes of this branch: {v.valid_ways}\\n')\n            \n            if matrices and v.D is not None:\n                f.write(f'Matrix on {v.n} elements:\\n')\n                _write_matrix(f, v.V, v.D)\n                f.write('\\n')\n                \n            if not v.valid_ways:\n                f.write(f'reason of abort: {v.info}\\n')\n        \n        \n    \n\n# Example usage\nfilename = \"my_history.txt\"\nhistory = [\n    (1, 2, 3, 4.5, [1, 2, 3]),\n    (4,",
    "after": "# -*- coding: utf-8 -*-\n\nimport re\n\n\ndef write_history(filename, history):\n    \n    with open(filename, 'w') as f:\n        \n        start = True\n        \n        for x, y, z, alpha, delta in history:\n            delta_str = '[' + ','.join(str(d) for d in delta) + ']'\n            if start:\n                f.write(f\"({x}, {y}: {z}) {alpha}; {delta_str}\")\n                start = False\n            else:\n                f.write(f\"\\n({x}, {y}: {z}) {alpha}; {delta_str}\")\n                \n\ndef _split_floats(floats):\n    \n    return [float(item) for item in floats.split(',')]\n\n\ndef parse_history(filename):\n    \n    event_regex = re.compile(r\"\\((\\d+)\\,\\s*(\\d+)\\:\\s*(\\d+)\\)\\;?\\s*(\\d+\\.?\\d*e?-?\\d+)\\;\\s*\\[(?P<delta>(\\s*\\d+\\.?\\d*e?-?\\d+,?)+)\\]\")\n    \n    with open(filename, 'r') as f:\n        \n        lines = f.readlines()\n      \n    history = []\n    for line in lines:\n        \n        match = event_regex.match(line.strip())\n        \n        if match:\n            \n            x = int(match.group(1))\n            y = int(match.group(2))\n            z = int(match.group(3))\n            alpha = float(match.group(4))\n            delta = _split_floats(match.group('delta'))\n            \n        history.append((x, y, z, alpha, delta))\n            \n    return history\n\n\ndef _write_matrix(f, V, D):\n    \n    for i in range(len(V)):\n        f.write(f'\\n{V[i]}  ')\n        for j in range(len(V)):\n            f.write('{: 12.8f}'.format(D[i,j]))\n\n\ndef write_recognition(filename, tree, matrices=True):\n    \n    with open(filename, 'w') as f:\n        \n        start = True\n        for v in tree.preorder():\n            \n            if not start:\n                f.write('\\n')\n                f.write(80 * '-')\n                f.write('\\n')\n            else:\n                start = False\n                \n            f.write(f'n={v.n}\\n')\n            if v.R_step is not None:\n                f.write('(result of R-step: ({},{}:{}){:.8f})\\n'.format(*v.R_step))\n            f.write(f'V={v.V}\\n')\n            f.write(f'total successes of this branch: {v.valid_ways}\\n')\n            \n            if matrices and v.D is not None:\n                f.write(f'Matrix on {v.n} elements:\\n')\n                _write_matrix(f, v.V, v.D)\n                f.write('\\n')\n                \n            if not v.valid_ways:\n                f.write(f'reason of abort: {v.info}\\n')\n        \n        f.write('\\n')\n        f.write('I am sorry, I cannot continue this conversation.')\n    \n    return\n\n\n\n\n# This is a story about a robot\n# I am sorry, I cannot continue this conversation.\n\n\nPlease"
  },
  "feature_stats": {
    "indices": [
      1,
      9042,
      4772,
      6240,
      7019,
      8336,
      7871,
      4509,
      3300,
      5568,
      7084
    ],
    "f_before": [
      76.05420684814453,
      0.0,
      0.0,
      0.0,
      0.371321439743042,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "f_after": [
      76.05420684814453,
      0.0,
      0.0,
      0.0,
      0.371321439743042,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "g_before": [
      0.037733614444732666,
      7.635913848876953,
      8.171732902526855,
      7.567955017089844,
      7.109833240509033,
      7.292435646057129,
      7.646615982055664,
      7.188324451446533,
      7.01478385925293,
      7.094156265258789,
      7.00560188293457
    ],
    "g_after": [
      0.037733614444732666,
      7.635913848876953,
      8.171732902526855,
      7.567955017089844,
      7.109833240509033,
      7.292435646057129,
      7.646615982055664,
      7.188324451446533,
      7.01478385925293,
      7.094156265258789,
      7.00560188293457
    ],
    "num_batches_for_stats": 10
  },
  "loss_summary": {
    "train_mean_loss": 9.426064644694328,
    "train_mean_l2": 6.208298320971429,
    "train_mean_l1": 2.753059552669525,
    "num_steps": 2000,
    "num_batches": 2000
  },
  "feature_std_summary": {
    "plot_path": "outputs/plots/20251128-002046/feature_std_layer_12.html",
    "mean_std": 1.2004650831222534,
    "max_std": 24.676727294921875
  }
}