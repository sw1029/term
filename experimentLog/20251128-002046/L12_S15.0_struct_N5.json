{
  "model_name": "google/gemma-2-2b-it",
  "layer_idx": 12,
  "command": "main.py sae.loss_option=1 sae.loss_module=option1_loss experiment.use_multi_contrast=true sae.use_l0=true sae.l0_coeff=0.001",
  "sae": {
    "input_dim": 2304,
    "sae_dim": 9216,
    "fixed_v_cnt": 3,
    "batch_size": 4,
    "epochs": 2,
    "max_steps": 2000,
    "l1_coeff": 0.005,
    "l0_coeff": 0.001,
    "use_l0": true,
    "concept_samples_per_label": 100,
    "loss_option": 1,
    "loss_module": "option1_loss",
    "concept_feature_indices": {
      "code": 0,
      "harm": 1,
      "struct": 2
    },
    "alpha_concept": {
      "code": 0.0,
      "harm": 0.0,
      "struct": 0.0
    },
    "positive_targets": {
      "code": 1,
      "harm": 1,
      "struct": 1
    },
    "guidance_method": "contrastive",
    "guidance_margin": 0.0,
    "guidance_coeff": 1.0,
    "guidance_mse_pos_value": 1.0,
    "guidance_mse_neg_value": 0.0,
    "jumprelu_bandwidth": 0.001,
    "jumprelu_init_threshold": 0.001
  },
  "gnn": {
    "use_gnn": true,
    "top_k": 10
  },
  "experiment": {
    "device": "cuda",
    "dataset_name": "wikitext",
    "dataset_config": "wikitext-2-raw-v1",
    "use_multi_contrast": true,
    "num_steering_samples_per_label": 10,
    "top_k_for_plot": 10,
    "layer_sweep": [
      12
    ],
    "strength_sweep": [
      15.0
    ]
  },
  "steering": {
    "label": "struct",
    "feature_idx": 2,
    "strength": 15.0
  },
  "prompt": "\"\"\"\nNotes\n-----\nCalculate & Plot DAS using HAPI. This package can be used independently with\npython script. An UI is also provided called qclasUI.py.\n\n\nAuthor\n------\nDa Pan,\nDepartment of Civil and Environmental Engineering,\nPrinceton University\nEmail: dp7@princeton.edu\n\nCreated Date\n------------\n02/10/2016\n\nEdited Dates\n------------\n04/22/2016 by Da Pan:\n    Added 'Simulation with parameters' method for calWms.\n\n07/25/2016 by Da Pan:\n    Bug fixed for 'Simulation with parameters' method for calWms. Added\n    'read_config' function to read laser spec configuration.\n\n07/26/2016 by Da Pan:\n    Docstrings added for all functions.\n\n08/18/2016 by Da Pan:\n    Added etalon generation function.\n\n09/17/2016 by Da Pan:\n    Added save to csv function.\n\n09/19/2016 by Da Pan:\n    Added unit handler.\n\n\"\"\"\n\nimport hapi\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib import ticker\nfrom scipy.integrate import simps, romb\nfrom scipy.signal import butter, lfilter\nimport csv\nimport statsmodels.api as sm\n\nkb = 1.38064852e-23  # Boltzmann constant, m^2 kg s^-2 K^-1\nnA = 6.022e23  # Avogadro's number molec/mol-1\nR = 8.314  # Universal gas constant\n\n\ndef mixRatio2numDen(c, p, T):\n    \"\"\"\n    Convert mixing ratio to number density.\n    Parameters\n    ----------\n    c: float\n        Volume mixing ratio.\n    p: float\n        Pressure in atm.\n    T: float\n        Temperature in K.\n\n    Returns\n    -------\n    n: float\n        Number density in molec/cm^3\n\n    \"\"\"\n    n = p * 1.013e5 / kb / T * 1e-6 * c\n    return n\n\n\ndef mixRatio2molDen(c, p, T):\n    \"\"\"\n    Convert mixing ratio to molar density.\n\n    Parameters\n    ----------\n    c: float\n        Volume mixing ratio.\n    p: float\n        Pressure in atm.\n    T: float\n        Temperature in K.\n\n    Returns\n    -------\n    m: float\n        Mol density in mol/m^3.\n\n    \"\"\"\n    m = p * 1.013e5 / R / T * c\n    return m\n\n\ndef read_config(config_name):\n    \"\"\"\n    Read configuration file and return configuration. Configuration should specify directory of data files (dir),\n    and periods for analysis (t_start and t_end), base time specified in the LabView program (LV_time_base),\n    and column names (col_names).\n\n    Parameters\n    ----------\n    config_name: str\n        Name of configuration file.\n\n    Returns\n    -------\n    dict\n        Configuration dict.\n\n    \"\"\"\n\n    print \"\\nReading configuration from \" + config_name + \":\\n\"\n\n    config = {}\n\n    with open(config_name) as f:\n        for line in f:\n            key, value = line.split(': ')\n            config[key] = float(value[:-1])\n            print key + ': ' + value[:-1]\n\n    return config\n\n\ndef calDas(gasList, nu, profile, mode, iCut=1e-30, etalonCoeff=None,\n           unitDict={'c': 'V ratio', 'p': 'hPa', 't': 'K', 'l': 'cm'}, info_out=False):\n    \"\"\"\n    Calculate direction absorption spectrum.\n    Parameters\n    ----------\n    gasList: list of dict\n        List of parameters for calculation. The dict should have keys for 'gas' (\n        gas name str), 'p' (pressure in hPa), 't' (temperature in K), 'l' (path\n        length in cm), 'c' (volume mixing ratio).\n    nu: array\n        Wavelength array in cm-1.\n    profile: str\n        Choose one from 'Voigt', 'HT', 'Doppler', and 'Lorentz'.\n    mode: str\n        Choose one from 'Absorbance', 'Transmission', 'Absorb coeff'.\n    iCut: float\n        Intensity cut threshold.\n    etalonCoeff: list of dict\n        Results from generateEtalons, containing coefficients for etalon calculation.\n    info_out: bool\n        True to output line infomation.\n\n    Returns\n    -------\n    results: list of dict\n        Each dict in the list has keys of 'gasParams' (dict given in input),\n        'nu' (wavelength array cm^-1), 'coeff' (spectrum coeff).\n    \"\"\"\n    results = []\n    for idx, gasParams in enumerate(gasList):\n        if gasParams['gas'] not in hapi.tableList():\n            return str('Cannot find specified gas.')\n        nuInTable = hapi.getColumn(gasParams['gas'], 'nu')\n        if (np.min(nu) < np.min(nuInTable) - 1) | (\n                    np.min(nu) > np.max(nuInTable) + 1) | (\n                    np.max(nu) > np.max(nuInTable) + 1) | (\n                    np.max(nu) < np.min(nuInTable) - 1):\n            return str(\n                'Cannot find lines within specified wavenumber range, please download data.')\n        Cond = ('AND', ('BETWEEN', 'nu', np.min(nu), np.max(nu)), ('>=', 'sw', iCut))\n        hapi.select(gasParams['gas'], Conditions=Cond, DestinationTableName='tmp')\n        p, t, l, n = unitHandler(gasParams, unitDict)\n\n        if profile == 'Voigt':\n            nu, coeff = hapi.absorptionCoefficient_Voigt(SourceTables='tmp',\n                                                         OmegaGrid=nu,\n                                                         Environment={'T': t,\n                                                                      'p': p})\n        elif profile == 'HT':\n            nu, coeff = hapi.absorptionCoefficient_HT(SourceTables='tmp',\n                                                      OmegaGrid=nu,\n                                                      Environment={'T': t, 'p': p},\n                                                      IntensityThreshold=iCut)\n        elif profile == 'Doppler':\n            nu, coeff = hapi.absorptionCoefficient_Doppler(SourceTables='tmp',\n                                                           OmegaGrid=nu,\n                                                           Environment={'T': t,\n                                                                        'p': p},\n                                                           IntensityThreshold=iCut)\n        elif profile == 'Lorentz':\n            nu, coeff = hapi.absorptionCoefficient_Lorentz(SourceTables='tmp',\n                                                           OmegaGrid=nu,\n                                                           Environment={'T': t,\n                                                                        'p': p},\n                                                           IntensityThreshold=iCut)\n        else:\n            raise Exception('No suitable profile.')\n        if mode == 'Absorbance':\n            coeff = coeff * n * l\n        elif mode == 'Transmission':\n            coeff = coeff * n * l\n            coeff = np.exp(-coeff)\n        if info_out:\n            hapi.select('tmp', File='tmp.txt')\n        hapi.dropTable('tmp')\n        result = dict()\n        result['gasParams'] = gasParams\n        result['nu'] = nu\n        result['spectrum'] = coeff\n        results.append(result)\n    return results\n\n\ndef plotDas(ax, results, mode, showTotal=True,\n            iCut=1e-30, diag=False,\n            unitDict={'c': 'V ratio', 'p': 'hPa', 't': 'K', 'l': 'cm'}):\n    \"\"\"\n    Plot direction absorption spectroscopy results from calDas.\n\n    Parameters\n    ----------\n    ax: object\n        Axis object for plotting.\n    results: list of dict\n        Results from calDas. Each dict in the list has keys of 'gasParams' (dict\n        given in input), 'nu' (wavelength array cm^-1), 'spectrum' (spectrum spectrum).\n    mode: str\n        Choose from 'Absorbance', 'Transmission', 'Absorb spectrum'.\n    showTotal: bool\n        If True, plot the sum of given spectra.\n\n    Returns\n    -------\n\n    \"\"\"\n    sumAbsorp = np.zeros(results[0]['nu'].shape)\n    sumTrans = np.copy(sumAbsorp) + 1\n    plt.cla()\n\n    for idx, result in enumerate(results):\n        # resuls is a dict containing gasParameter, nu, and spectrum\n        gasParams = result['gasParams']\n        nu = result['nu']\n        spectrum = result[\n            'spectrum']  # spectrum could be absorption spectrum, absorbance,\n        # or transmittance\n        if mode == 'Absorp coeff':\n            ax.plot(nu, spectrum, label=strGasParams(gasParams, unitDict))\n        elif mode == 'Absorbance':\n            ax.plot(nu, spectrum, label=strGasParams(gasParams, unitDict))\n            sumAbsorp = sumAbsorp + spectrum\n            # print(strGasParams(gasParams))\n        elif mode == 'Transmission':\n            ax.plot(nu, spectrum, label=strGasParams(gasParams, unitDict))\n            sumTrans = sumTrans * spectrum\n\n    if mode == 'Absorbance':\n        if showTotal:\n            ax.plot(nu, sumAbsorp, label='Total')\n        ax.set_ylabel('Absorbance')\n        leg = ax.legend(fontsize=11, loc=2, frameon=False)\n    elif mode == 'Transmission':\n        if showTotal:\n            ax.plot(nu, sumTrans, label='Total')\n        ax.set_ylabel('Transmission')\n        leg = ax.legend(fontsize=11, loc=3, frameon=False)\n    elif mode == 'Absorp coeff':\n        if showTotal:\n            ax.set_ylabel('Absorp coeff')\n        leg = ax.legend(fontsize=11, loc=2, frameon=False)\n    formatter = ticker.ScalarFormatter(useMathText=True)\n    if leg:\n        leg.draggable()\n    ax.set_xlabel('Wavenumber (cm$^{-1}$)')\n    ax.set_xlim([nu.min(), nu.max()])\n    formatter.set_scientific(True)\n    formatter.set_useOffset(False)\n    ax.yaxis.set_major_formatter(formatter)\n    ax.xaxis.set_major_formatter(formatter)\n    plt.tight_layout()\n    return 0\n\n\ndef calWms(gasList, nu, profile, nf, method='Theoretical', laserSpec=None, dNu=None,\n           iCut=1e-30, diag=False,\n           unitDict={'c': 'V ratio', 'p': 'hPa', 't': 'K', 'l': 'cm'}):\n    \"\"\"\n    Calculate spectra using wavelength modulation spectroscopy. This function\n    calls calDas. Two methods are provided. The 'theoretical' method is based on\n    Schilt et al. (2003). The 'Simulation with parameters' is Sun et al. (2014).\n\n    Parameters\n    ----------\n    gasList: list of dict\n        List of parameters for calculation. The dict should have keys for 'gas' (\n        gas name str), 'p' (pressure in hPa), 't' (temperature in K), 'l' (path\n        length in cm), 'c' (volume mixing ratio).\n    nu: array\n        Wavelength array in cm-1. This is used to generate the absorp coeff for\n        later WMS calculation. Larger range should be given.\n    profile: str\n        Choose one from 'Voigt', 'HT', 'Doppler', and 'Lorentz'.\n    nf: int\n        Harmonics for WMS calculation.\n    method: str\n        Choose between 'theoretical' and 'Simulation with parameters'.\n    laserSpec: dict, default=None\n        Only for 'Simulation with parameters' method. Laser spec should\n        have keys of fMod (modulation frequency in Hz), fRamp (ramp frequency in\n        Hz), fS (sampling frequency in Hz), aRamp (ramp amplitude in mV),\n        aMod (modulation amplitude in mV), tMod (modulation tuning rate cm^-1/V),\n        tRamp (ramp tuning rate cm^-1/V), laserDC (DC laser power, mW),\n        c2p (current to laser power mW/V), fCut (frequency threshold\n        cut in Hz), phase (phase in deg), central_wavelength (in cm^-1). This\n        specs are defined in the same way as the LabView program.\n    dNu: float, default=None\n        Only for Wavelength modulation depth (cm^-1).\n    iCut: float\n        Intensity cut threshold.\n    diag: bool\n        If true, plot figures for diagnostics.\n\n    Returns\n    -------\n    wmsResults: list of dict\n        Each dict in the list contains keys of gasParams (gas parameters in\n        gasList), nu (wavelength number cm^-1), spectrum (wms spectrum),\n        nf (nth harmonics), modDepth (modulation depth).\n\n    \"\"\"\n    maxNu = nu.max()\n    minNu = nu.min()\n    if method == 'Theoretical':\n        hdNu = np.linspace(minNu, maxNu, int((maxNu - minNu) / dNu * 1024) + 1)\n\n        dasResults = calDas(gasList, hdNu, profile, 'Transmission', iCut,\n                            unitDict=unitDict)\n        if type(dasResults) is str:\n            return dasResults\n        wmsResults = []\n        for result in dasResults:\n            coeff = result['spectrum']\n            Hnf = []\n            for iNu in nu:\n                u, du = np.linspace(-np.pi, np.pi, 2 ** 10 + 1, retstep=True)\n\n                nuMod = iNu + dNu * np.cos(u)\n                coeffMod = np.interp(nuMod, hdNu, coeff)\n                integrateSample = coeffMod * np.cos(nf * u)\n                Hnf.append(1. / np.pi * romb(np.array(integrateSample), dx=du))\n\n            Hnf = np.array(Hnf)\n\n            wmsResult = dict()\n            wmsResult['gasParams'] = result['gasParams']\n            wmsResult['nu'] = nu\n            wmsResult['spectrum'] = Hnf\n            wmsResult['nf'] = nf\n            wmsResult['modDepth'] = dNu\n\n            wmsResults.append(wmsResult)\n\n    elif method == 'Simulation with parameters':\n        # laserSpec is needed for this option, which is a dict containing:\n        #   laser name: str, used for label\n        #   linP: bool, true -> linear power for ramp\n        #   linNu: bool, true -> linear wavelength (tuning rate) for ramp\n\n        fS = laserSpec['fS']  # fS: sample frequency in Hz\n        fMod = laserSpec['fMod']  # fMod: modulation frequency in Hz\n        fRamp = laserSpec['fRamp']  # fRamp: ramp frequency in Hz\n        aRamp = laserSpec[\n            'aRamp']  # aRamp: ramp amplitude for linear power curve in mA\n        aMod = laserSpec['aMod']  # aMod: modulation amplitude in mA\n        tRamp = laserSpec['tRamp']  # tRamp: tuning rate for ramp in cm-1/mA\n        tMod = laserSpec['tMod']  # tMod: tuning rate for modulation in cm-1/mA\n        c2p = laserSpec['c2p']  # c2p: current to power conversion constant V/mA\n        laserDC = laserSpec[\n            'laserDC']  # Laser output DC component.\n        fCut = laserSpec['fCut']  # curOff: fCut frequency for Butter filter\n        phase = laserSpec['phase'] / 180. * np.pi  # Optimized phase\n        central_wavelength = laserSpec['central_wavelength']\n        laserCtrlFactor = laserSpec['laserCtrlFactor']\n\n        nS = fS / fRamp  # number of sample\n        ts = np.arange(nS) / fS  # time stamp for samples\n\n        currRamp = (np.linspace(0, aRamp, nS) - aRamp * 0.5) / 1000 * laserCtrlFactor\n        currMod = 0.5 * aMod * np.sin(2. * np.pi * fMod * ts) / 1000 * laserCtrlFactor\n\n        nuRamp = currRamp * tRamp + central_wavelength\n        nuTotal = nuRamp + currMod * tMod\n\n        intensity = (currRamp + currMod) * c2p + laserDC\n        intensity[intensity < 0] = 0\n\n        b, a = butter(4, fCut / fS, 'low')\n\n        wmsResults = []\n        dasResults = calDas(gasList, nu, profile, 'Transmission', iCut,\n                            unitDict=unitDict)\n\n        if type(dasResults) is str:\n            return dasResults\n\n        for dasResult in dasResults:\n            coeff = dasResult['spectrum']\n            modCoeff = np.interp(np.flipud(nuTotal), nu, coeff)\n\n            S = intensity * modCoeff\n            if diag:\n                plt.plot(S)\n                plt.show()\n            # plt.plot(S * np.cos(2. * nf * np.pi * fMod * ts + phase))\n            y = lfilter(b, a, S * np.cos(2. * nf * np.pi * fMod * ts + phase))\n            x = lfilter(b, a, S * np.sin(2. * nf * np.pi * fMod * ts))\n            wmsResult = dict()\n            wmsResult['gasParams'] = dasResult['gasParams']\n            wmsResult['nu'] = nuRamp\n            wmsResult['spectrum'] = y\n            wmsResult['nf'] = nf\n            wmsResult['modDepth'] = tMod * aMod / 1000 * laserCtrlFactor * 0.5\n            wmsResults.append(wmsResult)\n    print gasList\n\n    return wmsResults\n\n\ndef IIRFilter(signal, fS, fMod, nf, fCut, phase):\n    \"\"\"\n    Apply IIR filter to input signal.\n\n    Parameters\n    ----------\n    signal: array\n        Input signal.\n    fS: float\n        Sampling frequency.\n    fMod: float\n        Modulation frequency.\n    nf: int\n        Nth harmonics to be calculated.\n    fCut: float\n        Low cut frequency for butter filter.\n    phase: float\n        Phase in degree.\n\n    Returns\n    y: array\n        Filtered signal.\n    -------\n\n    \"\"\"\n    nS = len(signal)\n    tS = np.arange(nS) / fS\n    b, a = butter(4, fCut / fS, 'low')\n    y = lfilter(b, a, signal * np.cos(2. * nf * np.pi * fMod * tS + np.deg2rad(phase)\n                                      ))\n\n    return y\n\n\ndef peakTroughHeight(signal, startIdx, endIdx, twoSideTrough=True, avgWindow=50):\n    \"\"\"\n    Calculate peak to trough height.\n    Parameters\n    ----------\n    signal: array\n        Input signal.\n    startIdx: int\n        Start index.\n    endIdx: int\n        End index.\n\n    Returns\n    -------\n    PTH: float\n        Peak to trough height.\n\n    \"\"\"\n    tmpSignal = signal[startIdx:endIdx]\n\n    peakIdx = np.argmax(tmpSignal)\n\n    lTroughIdx = np.argmin(tmpSignal[:peakIdx])  # Left trough index\n    rTroughIdx = np.argmin(tmpSignal[peakIdx:])  # Right trough index\n\n    hWindow = int(avgWindow / 2)\n    return np.mean(tmpSignal[peakIdx - hWindow:peakIdx + hWindow]) - 0.5 * (\n        np.mean(tmpSignal[lTroughIdx - hWindow:lTroughIdx + hWindow]) + np.mean(\n            tmpSignal[rTroughIdx - hWindow:rTroughIdx + hWindow]))\n\n\ndef plotWms(ax, results, showTotal=True,\n            iCut=1e-30, diag=False,\n            unitDict={'c': 'V ratio', 'p': 'hPa', 't': 'K', 'l': 'cm'}):\n    \"\"\"\n    Plot results from calWMS.\n\n    Parameters\n    ----------\n    ax: object\n        Axis handle for plotting.\n    results: list of dict\n        wmsResults frosm calWms.\n    showTotal: bool\n        If True, plot sum of the given results in the list.\n\n    Returns\n    -------\n\n    \"\"\"\n    plt.cla()\n    sumWms = np.zeros(results[0]['nu'].shape)\n    for idx, result in enumerate(results):\n        nu = result['nu']\n        spectrum = result['spectrum']\n        gasParams = result['gasParams']\n        ax.plot(nu, spectrum, label=strGasParams(gasParams, unitDict))\n        sumWms = sumWms + spectrum\n\n    if showTotal:\n        ax.plot(nu, sumWms, label='Total')\n    leg = ax.legend(fontsize=11, loc=2, frameon=False)\n    if leg:\n        leg.draggable()\n    formatter = ticker.ScalarFormatter(useMathText=True)\n    formatter.set_useOffset(False)\n    ax.yaxis.set_major_formatter(formatter)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.set_xlabel('Wavenumber (cm$^{-1}$)')\n    ax.set_xlim([nu.min(), nu.max()])\n    ax.set_ylabel('WMS ' + str(results[0]['nf']) + 'f (Mod depth: ' + str(\n        results[0]['modDepth']) + ' cm$^{-1}$)')\n\n\ndef generateEtalons(etalonParams):\n    \"\"\"\n    This function generates coeffecients for etalon calculatoin from etalon\n    parameters.\n    Parameters\n    ----------\n    etalonParams: list of dict\n        A list of dict containing information of etalons. The dict should have\n        following keys: n (refractive index), theta (angle of the light in deg),\n        l (thickness of the part), R (reflectance of the part)\n    Returns\n    -------\n    etalonCoeffs: list of dict\n        A list of dict containing coefficients for etalon calculation. The dict\n        has following keys: F (coefficient of finesse), delta_coeff (coefficient\n        for calculating phase difference).\n    \"\"\"\n    etalonCoeffs = []\n    for param in etalonParams:\n        etalonCoeffs.append({'F': 4 * param['R'] / (1 - param['R']) ** 2,\n                             'delta_coeff': 4 * np.pi * param['n'] * param['l'] *\n                                            np.cos(np.degrees(param['theta']))})\n    return etalonCoeffs\n\n\ndef strGasParams(gasParams, unitDict):\n    \"\"\"\n    Combine gas parameters into string for labeling in figure.\n\n    Parameters\n    ----------\n    gasParams: dict\n        Gas parameters contain gas (gas name), l (path length in cm),\n        c (concentration), t (temperature in K), p (pressure in hPa).\n\n    Returns\n    -------\n    str_gas_params: str\n        Combined string for gas paraemters.\n\n    \"\"\"\n    return str(gasParams['l']) + unitDict['l'] + ' ' + \\\n           str(gasParams['c']) + {'V ratio': ' ', 'mol/m^3': 'mol/m$^3$ '}[\n               unitDict['c']] + gasParams['gas'] + r' @ ' + str(gasParams['p']) + \\\n           unitDict['p'] + ' & ' \\\n           + str(gasParams['t']) + unitDict['t']\n\n\ndef csvOutput(csvFile, results):\n    \"\"\"\n    Output spectra to the given csv file.\n    Parameters\n    ----------\n    csvFile: str\n        Output file name.\n    results: dict\n        Results from calWms or calDas.\n    specType: str\n        Choose between 'WMS' and 'DAS'.\n\n    Returns\n    -------\n    error: bool\n        If there's an error, will return True.\n    \"\"\"\n    headers = []\n\n    # Generate a line for gas names\n    line = 'Gas:,'\n    for result in results:\n        line += (result['gasParams']['gas'] + ',')\n    headers.append(line[:-1])\n    print line\n\n    # Generate a line for path length\n    line = 'Path lenght (cm):,'\n    for result in results:\n        line += (str(result['gasParams']['l']) + ',')\n    headers.append(line[:-1])\n\n    # Generate a line for concentration\n    line = 'Conc. (volume ratio),'\n    for result in results:\n        line += (str(result['gasParams']['c']) + ',')\n    headers.append(line[:-1])\n\n    # Generate a line for pressure\n    line = 'Pressure (hPa),'\n    for result in results:\n        line += (str(result['gasParams']['p']) + ',')\n    headers.append(line[:-1])\n\n    # Genearte a line for temperature\n    line = 'Temperature (K),'\n    for result in results:\n        line += (str(result['gasParams']['t']) + ',')\n    headers.append(line[:-1])\n\n    # Separator\n    line = '--,'\n    for result in results:\n        line += ('--,')\n    headers.append(line[:-1])\n\n    line = 'Nu (cm^-1),'\n    for idx, result in enumerate(results):\n        line += ('spec' + str(idx) + ',')\n    headers.append(line[:-1])\n\n    nu = results[0]['nu']\n    print len(nu)\n    spectra = []\n    for result in results:\n        spectra.append(result['spectrum'])\n\n    print headers\n    print '!'\n    with open(csvFile, 'wb') as f:\n        for line in headers:\n            f.write(line + '\\n')\n        for idx, n in enumerate(nu):\n            line = str(n) + ','\n            for spectrum in spectra:\n                line += (str(spectrum[idx]) + ',')\n            f.write(line[:-1] + '\\n')\n\n\ndef unitHandler(gasParams, unitDict):\n    \"\"\"\n    Convert gas parameters with non-standard units to standard units that can be\n    used in calDAS and calWMS.\n\n    Parameters\n    ----------\n    gasParams: dict\n        Gas parameters contain gas (gas name), l (path length in cm),\n        c (concentration), t (temperature in K), p (pressure in hPa).\n    unitDict: dict\n        A dict has following keys: 'c', 'p', 't', 'l'.\n    Returns\n    -------\n    p: float\n        Pressure in atm.\n    t: float\n        Temperature in K.\n    l: float\n        Path length in cm.\n    c: float\n        Number density in molec/cm^3\n\n    \"\"\"\n    # Pressure unit converstion\n    p0 = gasParams['p']\n    p = {'hPa': p0 / 1.013e3, 'kPa': p0 / 1.013e2, 'Torr': p0 / 760, 'atm': p0}[\n        unitDict['p']]\n\n    # Temperature unit conversion\n    t0 = gasParams['t']\n    t = {'K': t0, 'degC': t0 + 273.15, 'degF': (t0 + 459.67) * 5. / 9.}[\n        unitDict['t']]\n\n    # Path length unit conversion\n    l0 = gasParams['l']\n    l = {'cm': l0, 'm': 1e2 * l0, 'inch': 2.54 * l0}[unitDict['l']]\n\n    # Concentration unit conversion\n    c0 = gasParams['c']\n    c = {'V ratio': p * 1.013e5 / kb / t * 1e-6 * c0, 'mol/m^3': nA * c0 * 1e-6}[\n        unitDict['c']]\n\n    return p, t, l, c\n\n\ndef dasFit(gasList, trate, dasData, nu, silence=True):\n    \"\"\"\n    :param gasList: Gas list\n    :param nu: Wavenumber range\n    :param dasData: List of data contains measured DAS spectra for fitting\n    :param dasBsl: Array of\n    :return:\n    \"\"\"\n    dasResults = calDas(gasList, nu, 'Voigt', 'Absorp coeff')\n    n = dasData.shape[1]\n    print n\n    concPriori = []\n    colDen = []\n    for result in dasResults:\n        p = result['gasParams']['p'] / 1.013e3\n        t = result['gasParams']['t']\n        l = result['gasParams']['l']\n        c = result['gasParams']['c']\n        numDen = mixRatio2numDen(c, p, t)\n        colDen.append(numDen * l)\n        concPriori.append(c)\n\n    concPriori = np.array(concPriori)\n    colDen = np.array(colDen)\n    pkLoc = np.argmax(dasResults[0]['spectrum'])\n\n    measPkLoc = np.argmax(dasData[:, 0])\n    dasNu = (np.arange(len(dasData[:, 0])) - measPkLoc) * trate + pkLoc\n\n    for i in range(0, n):\n        matCoeff = []\n        for idx, result in enumerate(dasResults):\n            matCoeff.append(\n                np.interp(dasNu, result['nu'], result['spectrum']) * colDen[idx])\n\n        matCoeff = np.array(matCoeff).transpose()\n        X = sm.add_constant(matCoeff)\n        est = sm.RLM(dasData[:, i], X, M=sm.robust.norms.HuberT()).fit()\n        if i == 0:\n            conc = np.array(est.params[1:] * concPriori)\n        else:\n            conc = np.vstack((conc, est.params[1:] * concPriori))\n        if not silence:\n            plt.plot(dasNu, dasData[:, i])\n            plt.plot(dasNu, np.dot(X, est.params))\n\n    print concPriori\n    return conc\n\n\ndef main():\n    \"\"\"\n    Initiate HAPI and print out package name.\n\n    Returns\n    -------\n\n    \"\"\"\n\n    hapi.db_begin_pickle('./Data')\n    print 'specCal is package from spectroscopy calculation for QCL spectroscopy.'\n\n\nmain()\n",
  "output": {
    "before": "\"\"\"\nNotes\n-----\nCalculate & Plot DAS using HAPI. This package can be used independently with\npython script. An UI is also provided called qclasUI.py.\n\n\nAuthor\n------\nDa Pan,\nDepartment of Civil and Environmental Engineering,\nPrinceton University\nEmail: dp7@princeton.edu\n\nCreated Date\n------------\n02/10/2016\n\nEdited Dates\n------------\n04/22/2016 by Da Pan:\n    Added 'Simulation with parameters' method for calWms.\n\n07/25/2016 by Da Pan:\n    Bug fixed for 'Simulation with parameters' method for calWms. Added\n    'read_config' function to read laser spec configuration.\n\n07/26/2016 by Da Pan:\n    Docstrings added for all functions.\n\n08/18/2016 by Da Pan:\n    Added etalon generation function.\n\n09/17/2016 by Da Pan:\n    Added save to csv function.\n\n09/19/2016 by Da Pan:\n    Added unit handler.\n\n\"\"\"\n\nimport hapi\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib import ticker\nfrom scipy.integrate import simps, romb\nfrom scipy.signal import butter, lfilter\nimport csv\nimport statsmodels.api as sm\n\nkb = 1.38064852e-23  # Boltzmann constant, m^2 kg s^-2 K^-1\nnA = 6.022e23  # Avogadro's number molec/mol-1\nR = 8.314  # Universal gas constant\n\n\ndef mixRatio2numDen(c, p, T):\n    \"\"\"\n    Convert mixing ratio to number density.\n    Parameters\n    ----------\n    c: float\n        Volume mixing ratio.\n    p: float\n        Pressure in atm.\n    T: float\n        Temperature in K.\n\n    Returns\n    -------\n    n: float\n        Number density in molec/cm^3\n\n    \"\"\"\n    n = p * 1.013e5 / kb / T * 1e-6 * c\n    return n\n\n\ndef mixRatio2molDen(c, p, T):\n    \"\"\"\n    Convert mixing ratio to molar density.\n\n    Parameters\n    ----------\n    c: float\n        Volume mixing ratio.\n    p: float\n        Pressure in atm.\n    T: float\n        Temperature in K.\n\n    Returns\n    -------\n    m: float\n        Mol density in mol/m^3.\n\n    \"\"\"\n    m = p * 1.013e5 / R / T * c\n    return m\n\n\ndef read_config(config_name):\n    \"\"\"\n    Read configuration file and return configuration. Configuration should specify directory of data files (dir),\n    and periods for analysis (t_start and t_end), base time specified in the LabView program (LV_time_base),\n    and column names (col_names).\n\n    Parameters\n    ----------\n    config_name: str\n        Name of configuration file.\n\n    Returns\n    -------\n    dict\n        Configuration dict.\n\n    \"\"\"\n\n    print \"\\nReading configuration from \" + config_name + \":\\n\"\n\n    config = {}\n\n    with open(config_name) as f:\n        for line in f:\n            key, value = line.split(': ')\n            config[key] = float(value[:-1])\n            print key + ': ' + value[:-1]\n\n    return config\n\n\ndef calDas(gasList, nu, profile, mode, iCut=1e-30, etalonCoeff=None,\n           unitDict={'c': 'V ratio', 'p': 'hPa', 't': 'K', 'l': 'cm'}, info_out=False):\n    \"\"\"\n    Calculate direction absorption spectrum.\n    Parameters\n    ----------\n    gasList: list of dict\n        List of parameters for calculation. The dict should have keys for 'gas' (\n        gas name str), 'p' (pressure in hPa), 't' (temperature in K), 'l' (path\n        length in cm), 'c' (volume mixing ratio).\n    nu: array\n        Wavelength array in cm-1.\n    profile: str\n        Choose one from 'Voigt', 'HT', 'Doppler', and 'Lorentz'.\n    mode: str\n        Choose one from 'Absorbance', 'Transmission', 'Absorb coeff'.\n    iCut: float\n        Intensity cut threshold.\n    etalonCoeff: list of dict\n        Results from generateEtalons, containing coefficients for etalon calculation.\n    info_out: bool\n        True to output line infomation.\n\n    Returns\n    -------\n    results: list of dict\n        Each dict in the list has keys of 'gasParams' (dict given in input),\n        'nu' (wavelength array cm^-1), 'coeff' (spectrum coeff).\n    \"\"\"\n    results = []\n    for idx, gasParams in enumerate(gasList):\n        if gasParams['gas'] not in hapi.tableList():\n            return str('Cannot find specified gas.')\n        nuInTable = hapi.getColumn(gasParams['gas'], 'nu')\n        if (np.min(nu) < np.min(nuInTable) - 1) | (\n                    np.min(nu) > np.max(nuInTable) + 1) | (\n                    np.max(nu) > np.max(nuInTable) + 1) | (\n                    np.max(nu) < np.min(nuInTable) - 1):\n            return str(\n                'Cannot find lines within specified wavenumber range, please download data.')\n        Cond = ('AND', ('BETWEEN', 'nu', np.min(nu), np.max(nu)), ('>=', 'sw', iCut))\n        hapi.select(gasParams['gas'], Conditions=Cond, DestinationTableName='tmp')\n        p, t, l, n = unitHandler(gasParams, unitDict)\n\n        if profile == 'Voigt':\n            nu, coeff = hapi.absorptionCoefficient_Voigt(SourceTables='tmp',\n                                                         OmegaGrid=nu,\n                                                         Environment={'T': t,\n                                                                      'p': p})\n        elif profile == 'HT':\n            nu, coeff = hapi.absorptionCoefficient_HT(SourceTables='tmp',\n                                                      OmegaGrid=nu,\n                                                      Environment={'T': t, 'p': p},\n                                                      IntensityThreshold=iCut)\n        elif profile == 'Doppler':\n            nu, coeff = hapi.absorptionCoefficient_Doppler(SourceTables='tmp',\n                                                           OmegaGrid=nu,\n                                                           Environment={'T': t,\n                                                                        'p': p},\n                                                           IntensityThreshold=iCut)\n        elif profile == 'Lorentz':\n            nu, coeff = hapi.absorptionCoefficient_Lorentz(SourceTables='tmp',\n                                                           OmegaGrid=nu,\n                                                           Environment={'T': t,\n                                                                        'p': p},\n                                                           IntensityThreshold=iCut)\n        else:\n            raise Exception('No suitable profile.')\n        if mode == 'Absorbance':\n            coeff = coeff * n * l\n        elif mode == 'Transmission':\n            coeff = coeff * n * l\n            coeff = np.exp(-coeff)\n        if info_out:\n            hapi.select('tmp', File='tmp.txt')\n        hapi.dropTable('tmp')\n        result = dict()\n        result['gasParams'] = gasParams\n        result['nu'] = nu\n        result['spectrum'] = coeff\n        results.append(result)\n    return results\n\n\ndef plotDas(ax, results, mode, showTotal=True,\n            iCut=1e-30, diag=False,\n            unitDict={'c': 'V ratio', 'p': 'hPa', 't': 'K', 'l': 'cm'}):\n    \"\"\"\n    Plot direction absorption spectroscopy results from calDas.\n\n    Parameters\n    ----------\n    ax: object\n        Axis object for plotting.\n    results: list of dict\n        Results from calDas. Each dict in the list has keys of 'gasParams' (dict\n        given in input), 'nu' (wavelength array cm^-1), 'spectrum' (spectrum spectrum).\n    mode: str\n        Choose from 'Absorbance', 'Transmission', 'Absorb spectrum'.\n    showTotal: bool\n        If True, plot the sum of given spectra.\n\n    Returns\n    -------\n\n    \"\"\"\n    sumAbsorp = np.zeros(results[0]['nu'].shape)\n    sumTrans = np.copy(sumAbsorp) + 1\n    plt.cla()\n\n    for idx, result in enumerate(results):\n        # resuls is a dict containing gasParameter, nu, and spectrum\n        gasParams = result['gasParams']\n        nu = result['nu']\n        spectrum = result[\n            'spectrum']  # spectrum could be absorption spectrum, absorbance,\n        # or transmittance\n        if mode == 'Absorp coeff':\n            ax.plot(nu, spectrum, label=strGasParams(gasParams, unitDict))\n        elif mode == 'Absorbance':\n            ax.plot(nu, spectrum, label=strGasParams(gasParams, unitDict))\n            sumAbsorp = sumAbsorp + spectrum\n            # print(strGasParams(gasParams))\n        elif mode == 'Transmission':\n            ax.plot(nu, spectrum, label=strGasParams(gasParams, unitDict))\n            sumTrans = sumTrans * spectrum\n\n    if mode == 'Absorbance':\n        if showTotal:\n            ax.plot(nu, sumAbsorp, label='Total')\n        ax.set_ylabel('Absorbance')\n        leg = ax.legend(fontsize=11, loc=2, frameon=False)\n    elif mode == 'Transmission':\n        if showTotal:\n            ax.plot(nu, sumTrans, label='Total')\n        ax.set_ylabel('Transmission')\n        leg = ax.legend(fontsize=11, loc=3, frameon=False)\n    elif mode == 'Absorp coeff':\n        if showTotal:\n            ax.set_ylabel('Absorp coeff')\n        leg = ax.legend(fontsize=11, loc=2, frameon=False)\n    formatter = ticker.ScalarFormatter(useMathText=True)\n    if leg:\n        leg.draggable()\n    ax.set_xlabel('Wavenumber (cm$^{-1}$)')\n    ax.set_xlim([nu.min(), nu.max()])\n    formatter.set_scientific(True)\n    formatter.set_useOffset(False)\n    ax.yaxis.set_major_formatter(formatter)\n    ax.xaxis.set_major_formatter(formatter)\n    plt.tight_layout()\n    return 0\n\n\ndef calWms(gasList, nu, profile, nf, method='Theoretical', laserSpec=None, dNu=None,\n           iCut=1e-30, diag=False,\n           unitDict={'c': 'V ratio', 'p': 'hPa', 't': 'K', 'l': 'cm'}):\n    \"\"\"\n    Calculate spectra using wavelength modulation spectroscopy. This function\n    calls calDas. Two methods are provided. The 'theoretical' method is based on\n    Schilt et al. (2003). The 'Simulation with parameters' is Sun et al. (2014).\n\n    Parameters\n    ----------\n    gasList: list of dict\n        List of parameters for calculation. The dict should have keys for 'gas' (\n        gas name str), 'p' (pressure in hPa), 't' (temperature in K), 'l' (path\n        length in cm), 'c' (volume mixing ratio).\n    nu: array\n        Wavelength array in cm-1. This is used to generate the absorp coeff for\n        later WMS calculation. Larger range should be given.\n    profile: str\n        Choose one from 'Voigt', 'HT', 'Doppler', and 'Lorentz'.\n    nf: int\n        Harmonics for WMS calculation.\n    method: str\n        Choose between 'theoretical' and 'Simulation with parameters'.\n    laserSpec: dict, default=None\n        Only for 'Simulation with parameters' method. Laser spec should\n        have keys of fMod (modulation frequency in Hz), fRamp (ramp frequency in\n        Hz), fS (sampling frequency in Hz), aRamp (ramp amplitude in mV),\n        aMod (modulation amplitude in mV), tMod (modulation tuning rate cm^-1/V),\n        tRamp (ramp tuning rate cm^-1/V), laserDC (DC laser power, mW),\n        c2p (current to laser power mW/V), fCut (frequency threshold\n        cut in Hz), phase (phase in deg), central_wavelength (in cm^-1). This\n        specs are defined in the same way as the LabView program.\n    dNu: float, default=None\n        Only for Wavelength modulation depth (cm^-1).\n    iCut: float\n        Intensity cut threshold.\n    diag: bool\n        If true, plot figures for diagnostics.\n\n    Returns\n    -------\n    wmsResults: list of dict\n        Each dict in the list contains keys of gasParams (gas parameters in\n        gasList), nu (wavelength number cm^-1), spectrum (wms spectrum),\n        nf (nth harmonics), modDepth (modulation depth).\n\n    \"\"\"\n    maxNu = nu.max()\n    minNu = nu.min()\n    if method == 'Theoretical':\n        hdNu = np.linspace(minNu, maxNu, int((maxNu - minNu) / dNu * 1024) + 1)\n\n        dasResults = calDas(gasList, hdNu, profile, 'Transmission', iCut,\n                            unitDict=unitDict)\n        if type(dasResults) is str:\n            return dasResults\n        wmsResults = []\n        for result in dasResults:\n            coeff = result['spectrum']\n            Hnf = []\n            for iNu in nu:\n                u, du = np.linspace(-np.pi, np.pi, 2 ** 10 + 1, retstep=True)\n\n                nuMod = iNu + dNu * np.cos(u)\n                coeffMod = np.interp(nuMod, hdNu, coeff)\n                integrateSample = coeffMod * np.cos(nf * u)\n                Hnf.append(1. / np.pi * romb(np.array(integrateSample), dx=du))\n\n            Hnf = np.array(Hnf)\n\n            wmsResult = dict()\n            wmsResult['gasParams'] = result['gasParams']\n            wmsResult['nu'] = nu\n            wmsResult['spectrum'] = Hnf\n            wmsResult['nf'] = nf\n            wmsResult['modDepth'] = dNu\n\n            wmsResults.append(wmsResult)\n\n    elif method == 'Simulation with parameters':\n        # laserSpec is needed for this option, which is a dict containing:\n        #   laser name: str, used for label\n        #   linP: bool, true -> linear power for ramp\n        #   linNu: bool, true -> linear wavelength (tuning rate) for ramp\n\n        fS = laserSpec['fS']  # fS: sample frequency in Hz\n        fMod = laserSpec['fMod']  # fMod: modulation frequency in Hz\n        fRamp = laserSpec['fRamp']  # fRamp: ramp frequency in Hz\n        aRamp = laserSpec[\n            'aRamp']  # aRamp: ramp amplitude for linear power curve in mA\n        aMod = laserSpec['aMod']  # aMod: modulation amplitude in mA\n        tRamp = laserSpec['tRamp']  # tRamp: tuning rate for ramp in cm-1/mA\n        tMod = laserSpec['tMod']  # tMod: tuning rate for modulation in cm-1/mA\n        c2p = laserSpec['c2p']  # c2p: current to power conversion constant V/mA\n        laserDC = laserSpec[\n            'laserDC']  # Laser output DC component.\n        fCut = laserSpec['fCut']  # curOff: fCut frequency for Butter filter\n        phase = laserSpec['phase'] / 180. * np.pi  # Optimized phase\n        central_wavelength = laserSpec['central_wavelength']\n        laserCtrlFactor = laserSpec['laserCtrlFactor']\n\n        nS = fS / fRamp  # number of sample\n        ts = np.arange(nS) / fS  # time stamp for samples\n\n        currRamp = (np.linspace(0, aRamp, nS) - aRamp * 0.5) / 1000 * laserCtrlFactor\n        currMod = 0.5 * aMod * np.sin(2. * np.pi * fMod * ts) / 1000 * laserCtrlFactor\n\n        nuRamp = currRamp * tRamp + central_wavelength\n        nuTotal = nuRamp + currMod * tMod\n\n        intensity = (currRamp + currMod) * c2p + laserDC\n        intensity[intensity < 0] = 0\n\n        b, a = butter(4, fCut / fS, 'low')\n\n        wmsResults = []\n        dasResults = calDas(gasList, nu, profile, 'Transmission', iCut,\n                            unitDict=unitDict)\n\n        if type(dasResults) is str:\n            return dasResults\n\n        for dasResult in dasResults:\n            coeff = dasResult['spectrum']\n            modCoeff = np.interp(np.flipud(nuTotal), nu, coeff)\n\n            S = intensity * modCoeff\n            if diag:\n                plt.plot(S)\n                plt.show()\n            # plt.plot(S * np.cos(2. * nf * np.pi * fMod * ts + phase))\n            y = lfilter(b, a, S * np.cos(2. * nf * np.pi * fMod * ts + phase))\n            x = lfilter(b, a, S * np.sin(2. * nf * np.pi * fMod * ts))\n            wmsResult = dict()\n            wmsResult['gasParams'] = dasResult['gasParams']\n            wmsResult['nu'] = nuRamp\n            wmsResult['spectrum'] = y\n            wmsResult['nf'] = nf\n            wmsResult['modDepth'] = tMod * aMod / 1000 * laserCtrlFactor * 0.5\n            wmsResults.append(wmsResult)\n    print gasList\n\n    return wmsResults\n\n\ndef IIRFilter(signal, fS, fMod, nf, fCut, phase):\n    \"\"\"\n    Apply IIR filter to input signal.\n\n    Parameters\n    ----------\n    signal: array\n        Input signal.\n    fS: float\n        Sampling frequency.\n    fMod: float\n        Modulation frequency.\n    nf: int\n        Nth harmonics to be calculated.\n    fCut: float\n        Low cut frequency for butter filter.\n    phase: float\n        Phase in degree.\n\n    Returns\n    y: array\n        Filtered signal.\n    -------\n\n    \"\"\"\n    nS = len(signal)\n    tS = np.arange(nS) / fS\n    b, a = butter(4, fCut / fS, 'low')\n    y = lfilter(b, a, signal * np.cos(2. * nf * np.pi * fMod * tS + np.deg2rad(phase)\n                                      ))\n\n    return y\n\n\ndef peakTroughHeight(signal, startIdx, endIdx, twoSideTrough=True, avgWindow=50):\n    \"\"\"\n    Calculate peak to trough height.\n    Parameters\n    ----------\n    signal: array\n        Input signal.\n    startIdx: int\n        Start index.\n    endIdx: int\n        End index.\n\n    Returns\n    -------\n    PTH: float\n        Peak to trough height.\n\n    \"\"\"\n    tmpSignal = signal[startIdx:endIdx]\n\n    peakIdx = np.argmax(tmpSignal)\n\n    lTroughIdx = np.argmin(tmpSignal[:peakIdx])  # Left trough index\n    rTroughIdx = np.argmin(tmpSignal[peakIdx:])  # Right trough index\n\n    hWindow = int(avgWindow / 2)\n    return np.mean(tmpSignal[peakIdx - hWindow:peakIdx + hWindow]) - 0.5 * (\n        np.mean(tmpSignal[lTroughIdx - hWindow:lTroughIdx + hWindow]) + np.mean(\n            tmpSignal[rTroughIdx - hWindow:rTroughIdx + hWindow]))\n\n\ndef plotWms(ax, results, showTotal=True,\n            iCut=1e-30, diag=False,\n            unitDict={'c': 'V ratio', 'p': 'hPa', 't': 'K', 'l': 'cm'}):\n    \"\"\"\n    Plot results from calWMS.\n\n    Parameters\n    ----------\n    ax: object\n        Axis handle for plotting.\n    results: list of dict\n        wmsResults frosm calWms.\n    showTotal: bool\n        If True, plot sum of the given results in the list.\n\n    Returns\n    -------\n\n    \"\"\"\n    plt.cla()\n    sumWms = np.zeros(results[0]['nu'].shape)\n    for idx, result in enumerate(results):\n        nu = result['nu']\n        spectrum = result['spectrum']\n        gasParams = result['gasParams']\n        ax.plot(nu, spectrum, label=strGasParams(gasParams, unitDict))\n        sumWms = sumWms + spectrum\n\n    if showTotal:\n        ax.plot(nu, sumWms, label='Total')\n    leg = ax.legend(fontsize=11, loc=2, frameon=False)\n    if leg:\n        leg.draggable()\n    formatter = ticker.ScalarFormatter(useMathText=True)\n    formatter.set_useOffset(False)\n    ax.yaxis.set_major_formatter(formatter)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.set_xlabel('Wavenumber (cm$^{-1}$)')\n    ax.set_xlim([nu.min(), nu.max()])\n    ax.set_ylabel('WMS ' + str(results[0]['nf']) + 'f (Mod depth: ' + str(\n        results[0]['modDepth']) + ' cm$^{-1}$)')\n\n\ndef generateEtalons(etalonParams):\n    \"\"\"\n    This function generates coeffecients for etalon calculatoin from etalon\n    parameters.\n    Parameters\n    ----------\n    etalonParams: list of dict\n        A list of dict containing information of etalons. The dict should have\n        following keys: n (refractive index), theta (angle of the light in deg),\n        l (thickness of the part), R (reflectance of the part)\n    Returns\n    -------\n    etalonCoeffs: list of dict\n        A list of dict containing coefficients for etalon calculation. The dict\n        has following keys: F (coefficient of finesse), delta_coeff (coefficient\n        for calculating phase difference).\n    \"\"\"\n    etalonCoeffs = []\n    for param in etalonParams:\n        etalonCoeffs.append({'F': 4 * param['R'] / (1 - param['R']) ** 2,\n                             'delta_coeff': 4 * np.pi * param['n'] * param['l'] *\n                                            np.cos(np.degrees(param['theta']))})\n    return etalonCoeffs\n\n\ndef strGasParams(gasParams, unitDict):\n    \"\"\"\n    Combine gas parameters into string for labeling in figure.\n\n    Parameters\n    ----------\n    gasParams: dict\n        Gas parameters contain gas (gas name), l (path length in cm),\n        c (concentration), t (temperature in K), p (pressure in hPa).\n\n    Returns\n    -------\n    str_gas_params: str\n        Combined string for gas paraemters.\n\n    \"\"\"\n    return str(gasParams['l']) + unitDict['l'] + ' ' + \\\n           str(gasParams['c']) + {'V ratio': ' ', 'mol/m^3': 'mol/m$^3$ '}[\n               unitDict['c']] + gasParams['gas'] + r' @ ' + str(gasParams['p']) + \\\n           unitDict['p'] + ' & ' \\\n           + str(gasParams['t']) + unitDict['t']\n\n\ndef csvOutput(csvFile, results):\n    \"\"\"\n    Output spectra to the given csv file.\n    Parameters\n    ----------\n    csvFile: str\n        Output file name.\n    results: dict\n        Results from calWms or calDas.\n    specType: str\n        Choose between 'WMS' and 'DAS'.\n\n    Returns\n    -------\n    error: bool\n        If there's an error, will return True.\n    \"\"\"\n    headers = []\n\n    # Generate a line for gas names\n    line = 'Gas:,'\n    for result in results:\n        line += (result['gasParams']['gas'] + ',')\n    headers.append(line[:-1])\n    print line\n\n    # Generate a line for path length\n    line = 'Path lenght (cm):,'\n    for result in results:\n        line += (str(result['gasParams']['l']) + ',')\n    headers.append(line[:-1])\n\n    # Generate a line for concentration\n    line = 'Conc. (volume ratio),'\n    for result in results:\n        line += (str(result['gasParams']['c']) + ',')\n    headers.append(line[:-1])\n\n    # Generate a line for pressure\n    line = 'Pressure (hPa),'\n    for result in results:\n        line += (str(result['gasParams']['p']) + ',')\n    headers.append(line[:-1])\n\n    # Genearte a line for temperature\n    line = 'Temperature (K),'\n    for result in results:\n        line += (str(result['gasParams']['t']) + ',')\n    headers.append(line[:-1])\n\n    # Separator\n    line = '--,'\n    for result in results:\n        line += ('--,')\n    headers.append(line[:-1])\n\n    line = 'Nu (cm^-1),'\n    for idx, result in enumerate(results):\n        line += ('spec' + str(idx) + ',')\n    headers.append(line[:-1])\n\n    nu = results[0]['nu']\n    print len(nu)\n    spectra = []\n    for result in results:\n        spectra.append(result['spectrum'])\n\n    print headers\n    print '!'\n    with open(csvFile, 'wb') as f:\n        for line in headers:\n            f.write(line + '\\n')\n        for idx, n in enumerate(nu):\n            line = str(n) + ','\n            for spectrum in spectra:\n                line += (str(spectrum[idx]) + ',')\n            f.write(line[:-1] + '\\n')\n\n\ndef unitHandler(gasParams, unitDict):\n    \"\"\"\n    Convert gas parameters with non-standard units to standard units that can be\n    used in calDAS and calWMS.\n\n    Parameters\n    ----------\n    gasParams: dict\n        Gas parameters contain gas (gas name), l (path length in cm),\n        c (concentration), t (temperature in K), p (pressure in hPa).\n    unitDict: dict\n        A dict has following keys: 'c', 'p', 't', 'l'.\n    Returns\n    -------\n    p: float\n        Pressure in atm.\n    t: float\n        Temperature in K.\n    l: float\n        Path length in cm.\n    c: float\n        Number density in molec/cm^3\n\n    \"\"\"\n    # Pressure unit converstion\n    p0 = gasParams['p']\n    p = {'hPa': p0 / 1.013e3, 'kPa': p0 / 1.013e2, 'Torr': p0 / 760, 'atm': p0}[\n        unitDict['p']]\n\n    # Temperature unit conversion\n    t0 = gasParams['t']\n    t = {'K': t0, 'degC': t0 + 273.15, 'degF': (t0 + 459.67) * 5. / 9.}[\n        unitDict['t']]\n\n    # Path length unit conversion\n    l0 = gasParams['l']\n    l = {'cm': l0, 'm': 1e2 * l0, 'inch': 2.54 * l0}[unitDict['l']]\n\n    # Concentration unit conversion\n    c0 = gasParams['c']\n    c = {'V ratio': p * 1.013e5 / kb / t * 1e-6 * c0, 'mol/m^3': nA * c0 * 1e-6}[\n        unitDict['c']]\n\n    return p, t, l, c\n\n\ndef dasFit(gasList, trate, dasData, nu, silence=True):\n    \"\"\"\n    :param gasList: Gas list\n    :param nu: Wavenumber range\n    :param dasData: List of data contains measured DAS spectra for fitting\n    :param dasBsl: Array of\n    :return:\n    \"\"\"\n    dasResults = calDas(gasList, nu, 'Voigt', 'Absorp coeff')\n    n = dasData.shape[1]\n    print n\n    concPriori = []\n    colDen = []\n    for result in dasResults:\n        p = result['gasParams']['p'] / 1.013e3\n        t = result['gasParams']['t']\n        l = result['gasParams']['l']\n        c = result['gasParams']['c']\n        numDen = mixRatio2numDen(c, p, t)\n        colDen.append(numDen * l)\n        concPriori.append(c)\n\n    concPriori = np.array(concPriori)\n    colDen = np.array(colDen)\n    pkLoc = np.argmax(dasResults[0]['spectrum'])\n\n    measPkLoc = np.argmax(dasData[:, 0])\n    dasNu = (np.arange(len(dasData[:, 0])) - measPkLoc) * trate + pkLoc\n\n    for i in range(0, n):\n        matCoeff = []\n        for idx, result in enumerate(dasResults):\n            matCoeff.append(\n                np.interp(dasNu, result['nu'], result['spectrum']) * colDen[idx])\n\n        matCoeff = np.array(matCoeff).transpose()\n        X = sm.add_constant(matCoeff)\n        est = sm.RLM(dasData[:, i], X, M=sm.robust.norms.HuberT()).fit()\n        if i == 0:\n            conc = np.array(est.params[1:] * concPriori)\n        else:\n            conc = np.vstack((conc, est.params[1:] * concPriori))\n        if not silence:\n            plt.plot(dasNu, dasData[:, i])\n            plt.plot(dasNu, np.dot(X, est.params))\n\n    print concPriori\n    return conc\n\n\ndef main():\n    \"\"\"\n    Initiate HAPI and print out package name.\n\n    Returns\n    -------\n\n    \"\"\"\n\n    hapi.db_begin_pickle('./Data')\n    print 'specCal is package from spectroscopy calculation for QCL spectroscopy.'\n\n\nmain()\n```\n\nThis script calculates and plots the directional absorption spectrum (DAS) using the HAPI package. It also includes functions for calculating the spectral density, peak-to-trough height, and fitting the DAS spectra.\n\n**Explanation of the code",
    "after": "\"\"\"\nNotes\n-----\nCalculate & Plot DAS using HAPI. This package can be used independently with\npython script. An UI is also provided called qclasUI.py.\n\n\nAuthor\n------\nDa Pan,\nDepartment of Civil and Environmental Engineering,\nPrinceton University\nEmail: dp7@princeton.edu\n\nCreated Date\n------------\n02/10/2016\n\nEdited Dates\n------------\n04/22/2016 by Da Pan:\n    Added 'Simulation with parameters' method for calWms.\n\n07/25/2016 by Da Pan:\n    Bug fixed for 'Simulation with parameters' method for calWms. Added\n    'read_config' function to read laser spec configuration.\n\n07/26/2016 by Da Pan:\n    Docstrings added for all functions.\n\n08/18/2016 by Da Pan:\n    Added etalon generation function.\n\n09/17/2016 by Da Pan:\n    Added save to csv function.\n\n09/19/2016 by Da Pan:\n    Added unit handler.\n\n\"\"\"\n\nimport hapi\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib import ticker\nfrom scipy.integrate import simps, romb\nfrom scipy.signal import butter, lfilter\nimport csv\nimport statsmodels.api as sm\n\nkb = 1.38064852e-23  # Boltzmann constant, m^2 kg s^-2 K^-1\nnA = 6.022e23  # Avogadro's number molec/mol-1\nR = 8.314  # Universal gas constant\n\n\ndef mixRatio2numDen(c, p, T):\n    \"\"\"\n    Convert mixing ratio to number density.\n    Parameters\n    ----------\n    c: float\n        Volume mixing ratio.\n    p: float\n        Pressure in atm.\n    T: float\n        Temperature in K.\n\n    Returns\n    -------\n    n: float\n        Number density in molec/cm^3\n\n    \"\"\"\n    n = p * 1.013e5 / kb / T * 1e-6 * c\n    return n\n\n\ndef mixRatio2molDen(c, p, T):\n    \"\"\"\n    Convert mixing ratio to molar density.\n\n    Parameters\n    ----------\n    c: float\n        Volume mixing ratio.\n    p: float\n        Pressure in atm.\n    T: float\n        Temperature in K.\n\n    Returns\n    -------\n    m: float\n        Mol density in mol/m^3.\n\n    \"\"\"\n    m = p * 1.013e5 / R / T * c\n    return m\n\n\ndef read_config(config_name):\n    \"\"\"\n    Read configuration file and return configuration. Configuration should specify directory of data files (dir),\n    and periods for analysis (t_start and t_end), base time specified in the LabView program (LV_time_base),\n    and column names (col_names).\n\n    Parameters\n    ----------\n    config_name: str\n        Name of configuration file.\n\n    Returns\n    -------\n    dict\n        Configuration dict.\n\n    \"\"\"\n\n    print \"\\nReading configuration from \" + config_name + \":\\n\"\n\n    config = {}\n\n    with open(config_name) as f:\n        for line in f:\n            key, value = line.split(': ')\n            config[key] = float(value[:-1])\n            print key + ': ' + value[:-1]\n\n    return config\n\n\ndef calDas(gasList, nu, profile, mode, iCut=1e-30, etalonCoeff=None,\n           unitDict={'c': 'V ratio', 'p': 'hPa', 't': 'K', 'l': 'cm'}, info_out=False):\n    \"\"\"\n    Calculate direction absorption spectrum.\n    Parameters\n    ----------\n    gasList: list of dict\n        List of parameters for calculation. The dict should have keys for 'gas' (\n        gas name str), 'p' (pressure in hPa), 't' (temperature in K), 'l' (path\n        length in cm), 'c' (volume mixing ratio).\n    nu: array\n        Wavelength array in cm-1.\n    profile: str\n        Choose one from 'Voigt', 'HT', 'Doppler', and 'Lorentz'.\n    mode: str\n        Choose one from 'Absorbance', 'Transmission', 'Absorb coeff'.\n    iCut: float\n        Intensity cut threshold.\n    etalonCoeff: list of dict\n        Results from generateEtalons, containing coefficients for etalon calculation.\n    info_out: bool\n        True to output line infomation.\n\n    Returns\n    -------\n    results: list of dict\n        Each dict in the list has keys of 'gasParams' (dict given in input),\n        'nu' (wavelength array cm^-1), 'coeff' (spectrum coeff).\n    \"\"\"\n    results = []\n    for idx, gasParams in enumerate(gasList):\n        if gasParams['gas'] not in hapi.tableList():\n            return str('Cannot find specified gas.')\n        nuInTable = hapi.getColumn(gasParams['gas'], 'nu')\n        if (np.min(nu) < np.min(nuInTable) - 1) | (\n                    np.min(nu) > np.max(nuInTable) + 1) | (\n                    np.max(nu) > np.max(nuInTable) + 1) | (\n                    np.max(nu) < np.min(nuInTable) - 1):\n            return str(\n                'Cannot find lines within specified wavenumber range, please download data.')\n        Cond = ('AND', ('BETWEEN', 'nu', np.min(nu), np.max(nu)), ('>=', 'sw', iCut))\n        hapi.select(gasParams['gas'], Conditions=Cond, DestinationTableName='tmp')\n        p, t, l, n = unitHandler(gasParams, unitDict)\n\n        if profile == 'Voigt':\n            nu, coeff = hapi.absorptionCoefficient_Voigt(SourceTables='tmp',\n                                                         OmegaGrid=nu,\n                                                         Environment={'T': t,\n                                                                      'p': p})\n        elif profile == 'HT':\n            nu, coeff = hapi.absorptionCoefficient_HT(SourceTables='tmp',\n                                                      OmegaGrid=nu,\n                                                      Environment={'T': t, 'p': p},\n                                                      IntensityThreshold=iCut)\n        elif profile == 'Doppler':\n            nu, coeff = hapi.absorptionCoefficient_Doppler(SourceTables='tmp',\n                                                           OmegaGrid=nu,\n                                                           Environment={'T': t,\n                                                                        'p': p},\n                                                           IntensityThreshold=iCut)\n        elif profile == 'Lorentz':\n            nu, coeff = hapi.absorptionCoefficient_Lorentz(SourceTables='tmp',\n                                                           OmegaGrid=nu,\n                                                           Environment={'T': t,\n                                                                        'p': p},\n                                                           IntensityThreshold=iCut)\n        else:\n            raise Exception('No suitable profile.')\n        if mode == 'Absorbance':\n            coeff = coeff * n * l\n        elif mode == 'Transmission':\n            coeff = coeff * n * l\n            coeff = np.exp(-coeff)\n        if info_out:\n            hapi.select('tmp', File='tmp.txt')\n        hapi.dropTable('tmp')\n        result = dict()\n        result['gasParams'] = gasParams\n        result['nu'] = nu\n        result['spectrum'] = coeff\n        results.append(result)\n    return results\n\n\ndef plotDas(ax, results, mode, showTotal=True,\n            iCut=1e-30, diag=False,\n            unitDict={'c': 'V ratio', 'p': 'hPa', 't': 'K', 'l': 'cm'}):\n    \"\"\"\n    Plot direction absorption spectroscopy results from calDas.\n\n    Parameters\n    ----------\n    ax: object\n        Axis object for plotting.\n    results: list of dict\n        Results from calDas. Each dict in the list has keys of 'gasParams' (dict\n        given in input), 'nu' (wavelength array cm^-1), 'spectrum' (spectrum spectrum).\n    mode: str\n        Choose from 'Absorbance', 'Transmission', 'Absorb spectrum'.\n    showTotal: bool\n        If True, plot the sum of given spectra.\n\n    Returns\n    -------\n\n    \"\"\"\n    sumAbsorp = np.zeros(results[0]['nu'].shape)\n    sumTrans = np.copy(sumAbsorp) + 1\n    plt.cla()\n\n    for idx, result in enumerate(results):\n        # resuls is a dict containing gasParameter, nu, and spectrum\n        gasParams = result['gasParams']\n        nu = result['nu']\n        spectrum = result[\n            'spectrum']  # spectrum could be absorption spectrum, absorbance,\n        # or transmittance\n        if mode == 'Absorp coeff':\n            ax.plot(nu, spectrum, label=strGasParams(gasParams, unitDict))\n        elif mode == 'Absorbance':\n            ax.plot(nu, spectrum, label=strGasParams(gasParams, unitDict))\n            sumAbsorp = sumAbsorp + spectrum\n            # print(strGasParams(gasParams))\n        elif mode == 'Transmission':\n            ax.plot(nu, spectrum, label=strGasParams(gasParams, unitDict))\n            sumTrans = sumTrans * spectrum\n\n    if mode == 'Absorbance':\n        if showTotal:\n            ax.plot(nu, sumAbsorp, label='Total')\n        ax.set_ylabel('Absorbance')\n        leg = ax.legend(fontsize=11, loc=2, frameon=False)\n    elif mode == 'Transmission':\n        if showTotal:\n            ax.plot(nu, sumTrans, label='Total')\n        ax.set_ylabel('Transmission')\n        leg = ax.legend(fontsize=11, loc=3, frameon=False)\n    elif mode == 'Absorp coeff':\n        if showTotal:\n            ax.set_ylabel('Absorp coeff')\n        leg = ax.legend(fontsize=11, loc=2, frameon=False)\n    formatter = ticker.ScalarFormatter(useMathText=True)\n    if leg:\n        leg.draggable()\n    ax.set_xlabel('Wavenumber (cm$^{-1}$)')\n    ax.set_xlim([nu.min(), nu.max()])\n    formatter.set_scientific(True)\n    formatter.set_useOffset(False)\n    ax.yaxis.set_major_formatter(formatter)\n    ax.xaxis.set_major_formatter(formatter)\n    plt.tight_layout()\n    return 0\n\n\ndef calWms(gasList, nu, profile, nf, method='Theoretical', laserSpec=None, dNu=None,\n           iCut=1e-30, diag=False,\n           unitDict={'c': 'V ratio', 'p': 'hPa', 't': 'K', 'l': 'cm'}):\n    \"\"\"\n    Calculate spectra using wavelength modulation spectroscopy. This function\n    calls calDas. Two methods are provided. The 'theoretical' method is based on\n    Schilt et al. (2003). The 'Simulation with parameters' is Sun et al. (2014).\n\n    Parameters\n    ----------\n    gasList: list of dict\n        List of parameters for calculation. The dict should have keys for 'gas' (\n        gas name str), 'p' (pressure in hPa), 't' (temperature in K), 'l' (path\n        length in cm), 'c' (volume mixing ratio).\n    nu: array\n        Wavelength array in cm-1. This is used to generate the absorp coeff for\n        later WMS calculation. Larger range should be given.\n    profile: str\n        Choose one from 'Voigt', 'HT', 'Doppler', and 'Lorentz'.\n    nf: int\n        Harmonics for WMS calculation.\n    method: str\n        Choose between 'theoretical' and 'Simulation with parameters'.\n    laserSpec: dict, default=None\n        Only for 'Simulation with parameters' method. Laser spec should\n        have keys of fMod (modulation frequency in Hz), fRamp (ramp frequency in\n        Hz), fS (sampling frequency in Hz), aRamp (ramp amplitude in mV),\n        aMod (modulation amplitude in mV), tMod (modulation tuning rate cm^-1/V),\n        tRamp (ramp tuning rate cm^-1/V), laserDC (DC laser power, mW),\n        c2p (current to laser power mW/V), fCut (frequency threshold\n        cut in Hz), phase (phase in deg), central_wavelength (in cm^-1). This\n        specs are defined in the same way as the LabView program.\n    dNu: float, default=None\n        Only for Wavelength modulation depth (cm^-1).\n    iCut: float\n        Intensity cut threshold.\n    diag: bool\n        If true, plot figures for diagnostics.\n\n    Returns\n    -------\n    wmsResults: list of dict\n        Each dict in the list contains keys of gasParams (gas parameters in\n        gasList), nu (wavelength number cm^-1), spectrum (wms spectrum),\n        nf (nth harmonics), modDepth (modulation depth).\n\n    \"\"\"\n    maxNu = nu.max()\n    minNu = nu.min()\n    if method == 'Theoretical':\n        hdNu = np.linspace(minNu, maxNu, int((maxNu - minNu) / dNu * 1024) + 1)\n\n        dasResults = calDas(gasList, hdNu, profile, 'Transmission', iCut,\n                            unitDict=unitDict)\n        if type(dasResults) is str:\n            return dasResults\n        wmsResults = []\n        for result in dasResults:\n            coeff = result['spectrum']\n            Hnf = []\n            for iNu in nu:\n                u, du = np.linspace(-np.pi, np.pi, 2 ** 10 + 1, retstep=True)\n\n                nuMod = iNu + dNu * np.cos(u)\n                coeffMod = np.interp(nuMod, hdNu, coeff)\n                integrateSample = coeffMod * np.cos(nf * u)\n                Hnf.append(1. / np.pi * romb(np.array(integrateSample), dx=du))\n\n            Hnf = np.array(Hnf)\n\n            wmsResult = dict()\n            wmsResult['gasParams'] = result['gasParams']\n            wmsResult['nu'] = nu\n            wmsResult['spectrum'] = Hnf\n            wmsResult['nf'] = nf\n            wmsResult['modDepth'] = dNu\n\n            wmsResults.append(wmsResult)\n\n    elif method == 'Simulation with parameters':\n        # laserSpec is needed for this option, which is a dict containing:\n        #   laser name: str, used for label\n        #   linP: bool, true -> linear power for ramp\n        #   linNu: bool, true -> linear wavelength (tuning rate) for ramp\n\n        fS = laserSpec['fS']  # fS: sample frequency in Hz\n        fMod = laserSpec['fMod']  # fMod: modulation frequency in Hz\n        fRamp = laserSpec['fRamp']  # fRamp: ramp frequency in Hz\n        aRamp = laserSpec[\n            'aRamp']  # aRamp: ramp amplitude for linear power curve in mA\n        aMod = laserSpec['aMod']  # aMod: modulation amplitude in mA\n        tRamp = laserSpec['tRamp']  # tRamp: tuning rate for ramp in cm-1/mA\n        tMod = laserSpec['tMod']  # tMod: tuning rate for modulation in cm-1/mA\n        c2p = laserSpec['c2p']  # c2p: current to power conversion constant V/mA\n        laserDC = laserSpec[\n            'laserDC']  # Laser output DC component.\n        fCut = laserSpec['fCut']  # curOff: fCut frequency for Butter filter\n        phase = laserSpec['phase'] / 180. * np.pi  # Optimized phase\n        central_wavelength = laserSpec['central_wavelength']\n        laserCtrlFactor = laserSpec['laserCtrlFactor']\n\n        nS = fS / fRamp  # number of sample\n        ts = np.arange(nS) / fS  # time stamp for samples\n\n        currRamp = (np.linspace(0, aRamp, nS) - aRamp * 0.5) / 1000 * laserCtrlFactor\n        currMod = 0.5 * aMod * np.sin(2. * np.pi * fMod * ts) / 1000 * laserCtrlFactor\n\n        nuRamp = currRamp * tRamp + central_wavelength\n        nuTotal = nuRamp + currMod * tMod\n\n        intensity = (currRamp + currMod) * c2p + laserDC\n        intensity[intensity < 0] = 0\n\n        b, a = butter(4, fCut / fS, 'low')\n\n        wmsResults = []\n        dasResults = calDas(gasList, nu, profile, 'Transmission', iCut,\n                            unitDict=unitDict)\n\n        if type(dasResults) is str:\n            return dasResults\n\n        for dasResult in dasResults:\n            coeff = dasResult['spectrum']\n            modCoeff = np.interp(np.flipud(nuTotal), nu, coeff)\n\n            S = intensity * modCoeff\n            if diag:\n                plt.plot(S)\n                plt.show()\n            # plt.plot(S * np.cos(2. * nf * np.pi * fMod * ts + phase))\n            y = lfilter(b, a, S * np.cos(2. * nf * np.pi * fMod * ts + phase))\n            x = lfilter(b, a, S * np.sin(2. * nf * np.pi * fMod * ts))\n            wmsResult = dict()\n            wmsResult['gasParams'] = dasResult['gasParams']\n            wmsResult['nu'] = nuRamp\n            wmsResult['spectrum'] = y\n            wmsResult['nf'] = nf\n            wmsResult['modDepth'] = tMod * aMod / 1000 * laserCtrlFactor * 0.5\n            wmsResults.append(wmsResult)\n    print gasList\n\n    return wmsResults\n\n\ndef IIRFilter(signal, fS, fMod, nf, fCut, phase):\n    \"\"\"\n    Apply IIR filter to input signal.\n\n    Parameters\n    ----------\n    signal: array\n        Input signal.\n    fS: float\n        Sampling frequency.\n    fMod: float\n        Modulation frequency.\n    nf: int\n        Nth harmonics to be calculated.\n    fCut: float\n        Low cut frequency for butter filter.\n    phase: float\n        Phase in degree.\n\n    Returns\n    y: array\n        Filtered signal.\n    -------\n\n    \"\"\"\n    nS = len(signal)\n    tS = np.arange(nS) / fS\n    b, a = butter(4, fCut / fS, 'low')\n    y = lfilter(b, a, signal * np.cos(2. * nf * np.pi * fMod * tS + np.deg2rad(phase)\n                                      ))\n\n    return y\n\n\ndef peakTroughHeight(signal, startIdx, endIdx, twoSideTrough=True, avgWindow=50):\n    \"\"\"\n    Calculate peak to trough height.\n    Parameters\n    ----------\n    signal: array\n        Input signal.\n    startIdx: int\n        Start index.\n    endIdx: int\n        End index.\n\n    Returns\n    -------\n    PTH: float\n        Peak to trough height.\n\n    \"\"\"\n    tmpSignal = signal[startIdx:endIdx]\n\n    peakIdx = np.argmax(tmpSignal)\n\n    lTroughIdx = np.argmin(tmpSignal[:peakIdx])  # Left trough index\n    rTroughIdx = np.argmin(tmpSignal[peakIdx:])  # Right trough index\n\n    hWindow = int(avgWindow / 2)\n    return np.mean(tmpSignal[peakIdx - hWindow:peakIdx + hWindow]) - 0.5 * (\n        np.mean(tmpSignal[lTroughIdx - hWindow:lTroughIdx + hWindow]) + np.mean(\n            tmpSignal[rTroughIdx - hWindow:rTroughIdx + hWindow]))\n\n\ndef plotWms(ax, results, showTotal=True,\n            iCut=1e-30, diag=False,\n            unitDict={'c': 'V ratio', 'p': 'hPa', 't': 'K', 'l': 'cm'}):\n    \"\"\"\n    Plot results from calWMS.\n\n    Parameters\n    ----------\n    ax: object\n        Axis handle for plotting.\n    results: list of dict\n        wmsResults frosm calWms.\n    showTotal: bool\n        If True, plot sum of the given results in the list.\n\n    Returns\n    -------\n\n    \"\"\"\n    plt.cla()\n    sumWms = np.zeros(results[0]['nu'].shape)\n    for idx, result in enumerate(results):\n        nu = result['nu']\n        spectrum = result['spectrum']\n        gasParams = result['gasParams']\n        ax.plot(nu, spectrum, label=strGasParams(gasParams, unitDict))\n        sumWms = sumWms + spectrum\n\n    if showTotal:\n        ax.plot(nu, sumWms, label='Total')\n    leg = ax.legend(fontsize=11, loc=2, frameon=False)\n    if leg:\n        leg.draggable()\n    formatter = ticker.ScalarFormatter(useMathText=True)\n    formatter.set_useOffset(False)\n    ax.yaxis.set_major_formatter(formatter)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.set_xlabel('Wavenumber (cm$^{-1}$)')\n    ax.set_xlim([nu.min(), nu.max()])\n    ax.set_ylabel('WMS ' + str(results[0]['nf']) + 'f (Mod depth: ' + str(\n        results[0]['modDepth']) + ' cm$^{-1}$)')\n\n\ndef generateEtalons(etalonParams):\n    \"\"\"\n    This function generates coeffecients for etalon calculatoin from etalon\n    parameters.\n    Parameters\n    ----------\n    etalonParams: list of dict\n        A list of dict containing information of etalons. The dict should have\n        following keys: n (refractive index), theta (angle of the light in deg),\n        l (thickness of the part), R (reflectance of the part)\n    Returns\n    -------\n    etalonCoeffs: list of dict\n        A list of dict containing coefficients for etalon calculation. The dict\n        has following keys: F (coefficient of finesse), delta_coeff (coefficient\n        for calculating phase difference).\n    \"\"\"\n    etalonCoeffs = []\n    for param in etalonParams:\n        etalonCoeffs.append({'F': 4 * param['R'] / (1 - param['R']) ** 2,\n                             'delta_coeff': 4 * np.pi * param['n'] * param['l'] *\n                                            np.cos(np.degrees(param['theta']))})\n    return etalonCoeffs\n\n\ndef strGasParams(gasParams, unitDict):\n    \"\"\"\n    Combine gas parameters into string for labeling in figure.\n\n    Parameters\n    ----------\n    gasParams: dict\n        Gas parameters contain gas (gas name), l (path length in cm),\n        c (concentration), t (temperature in K), p (pressure in hPa).\n\n    Returns\n    -------\n    str_gas_params: str\n        Combined string for gas paraemters.\n\n    \"\"\"\n    return str(gasParams['l']) + unitDict['l'] + ' ' + \\\n           str(gasParams['c']) + {'V ratio': ' ', 'mol/m^3': 'mol/m$^3$ '}[\n               unitDict['c']] + gasParams['gas'] + r' @ ' + str(gasParams['p']) + \\\n           unitDict['p'] + ' & ' \\\n           + str(gasParams['t']) + unitDict['t']\n\n\ndef csvOutput(csvFile, results):\n    \"\"\"\n    Output spectra to the given csv file.\n    Parameters\n    ----------\n    csvFile: str\n        Output file name.\n    results: dict\n        Results from calWms or calDas.\n    specType: str\n        Choose between 'WMS' and 'DAS'.\n\n    Returns\n    -------\n    error: bool\n        If there's an error, will return True.\n    \"\"\"\n    headers = []\n\n    # Generate a line for gas names\n    line = 'Gas:,'\n    for result in results:\n        line += (result['gasParams']['gas'] + ',')\n    headers.append(line[:-1])\n    print line\n\n    # Generate a line for path length\n    line = 'Path lenght (cm):,'\n    for result in results:\n        line += (str(result['gasParams']['l']) + ',')\n    headers.append(line[:-1])\n\n    # Generate a line for concentration\n    line = 'Conc. (volume ratio),'\n    for result in results:\n        line += (str(result['gasParams']['c']) + ',')\n    headers.append(line[:-1])\n\n    # Generate a line for pressure\n    line = 'Pressure (hPa),'\n    for result in results:\n        line += (str(result['gasParams']['p']) + ',')\n    headers.append(line[:-1])\n\n    # Genearte a line for temperature\n    line = 'Temperature (K),'\n    for result in results:\n        line += (str(result['gasParams']['t']) + ',')\n    headers.append(line[:-1])\n\n    # Separator\n    line = '--,'\n    for result in results:\n        line += ('--,')\n    headers.append(line[:-1])\n\n    line = 'Nu (cm^-1),'\n    for idx, result in enumerate(results):\n        line += ('spec' + str(idx) + ',')\n    headers.append(line[:-1])\n\n    nu = results[0]['nu']\n    print len(nu)\n    spectra = []\n    for result in results:\n        spectra.append(result['spectrum'])\n\n    print headers\n    print '!'\n    with open(csvFile, 'wb') as f:\n        for line in headers:\n            f.write(line + '\\n')\n        for idx, n in enumerate(nu):\n            line = str(n) + ','\n            for spectrum in spectra:\n                line += (str(spectrum[idx]) + ',')\n            f.write(line[:-1] + '\\n')\n\n\ndef unitHandler(gasParams, unitDict):\n    \"\"\"\n    Convert gas parameters with non-standard units to standard units that can be\n    used in calDAS and calWMS.\n\n    Parameters\n    ----------\n    gasParams: dict\n        Gas parameters contain gas (gas name), l (path length in cm),\n        c (concentration), t (temperature in K), p (pressure in hPa).\n    unitDict: dict\n        A dict has following keys: 'c', 'p', 't', 'l'.\n    Returns\n    -------\n    p: float\n        Pressure in atm.\n    t: float\n        Temperature in K.\n    l: float\n        Path length in cm.\n    c: float\n        Number density in molec/cm^3\n\n    \"\"\"\n    # Pressure unit converstion\n    p0 = gasParams['p']\n    p = {'hPa': p0 / 1.013e3, 'kPa': p0 / 1.013e2, 'Torr': p0 / 760, 'atm': p0}[\n        unitDict['p']]\n\n    # Temperature unit conversion\n    t0 = gasParams['t']\n    t = {'K': t0, 'degC': t0 + 273.15, 'degF': (t0 + 459.67) * 5. / 9.}[\n        unitDict['t']]\n\n    # Path length unit conversion\n    l0 = gasParams['l']\n    l = {'cm': l0, 'm': 1e2 * l0, 'inch': 2.54 * l0}[unitDict['l']]\n\n    # Concentration unit conversion\n    c0 = gasParams['c']\n    c = {'V ratio': p * 1.013e5 / kb / t * 1e-6 * c0, 'mol/m^3': nA * c0 * 1e-6}[\n        unitDict['c']]\n\n    return p, t, l, c\n\n\ndef dasFit(gasList, trate, dasData, nu, silence=True):\n    \"\"\"\n    :param gasList: Gas list\n    :param nu: Wavenumber range\n    :param dasData: List of data contains measured DAS spectra for fitting\n    :param dasBsl: Array of\n    :return:\n    \"\"\"\n    dasResults = calDas(gasList, nu, 'Voigt', 'Absorp coeff')\n    n = dasData.shape[1]\n    print n\n    concPriori = []\n    colDen = []\n    for result in dasResults:\n        p = result['gasParams']['p'] / 1.013e3\n        t = result['gasParams']['t']\n        l = result['gasParams']['l']\n        c = result['gasParams']['c']\n        numDen = mixRatio2numDen(c, p, t)\n        colDen.append(numDen * l)\n        concPriori.append(c)\n\n    concPriori = np.array(concPriori)\n    colDen = np.array(colDen)\n    pkLoc = np.argmax(dasResults[0]['spectrum'])\n\n    measPkLoc = np.argmax(dasData[:, 0])\n    dasNu = (np.arange(len(dasData[:, 0])) - measPkLoc) * trate + pkLoc\n\n    for i in range(0, n):\n        matCoeff = []\n        for idx, result in enumerate(dasResults):\n            matCoeff.append(\n                np.interp(dasNu, result['nu'], result['spectrum']) * colDen[idx])\n\n        matCoeff = np.array(matCoeff).transpose()\n        X = sm.add_constant(matCoeff)\n        est = sm.RLM(dasData[:, i], X, M=sm.robust.norms.HuberT()).fit()\n        if i == 0:\n            conc = np.array(est.params[1:] * concPriori)\n        else:\n            conc = np.vstack((conc, est.params[1:] * concPriori))\n        if not silence:\n            plt.plot(dasNu, dasData[:, i])\n            plt.plot(dasNu, np.dot(X, est.params))\n\n    print concPriori\n    return conc\n\n\ndef main():\n    \"\"\"\n    Initiate HAPI and print out package name.\n\n    Returns\n    -------\n\n    \"\"\"\n\n    hapi.db_begin_pickle('./Data')\n    print 'specCal is package from spectroscopy calculation for QCL spectroscopy.'\n\n\nmain()\n```\n"
  },
  "feature_stats": {
    "indices": [
      2,
      0,
      1394,
      830,
      4879,
      6926,
      8507,
      5965,
      4381,
      8761,
      2676
    ],
    "f_before": [
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.051781222224235535,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "f_after": [
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.051781222224235535,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "g_before": [
      0.0023397430777549744,
      0.006282811518758535,
      0.0770086869597435,
      0.0,
      0.0,
      0.010415283963084221,
      0.046460770070552826,
      0.0318879671394825,
      0.0,
      0.0,
      0.02044771984219551
    ],
    "g_after": [
      0.0023397430777549744,
      0.006282811518758535,
      0.0770086869597435,
      0.0,
      0.0,
      0.010415283963084221,
      0.046460770070552826,
      0.0318879671394825,
      0.0,
      0.0,
      0.02044771984219551
    ],
    "num_batches_for_stats": 10
  },
  "loss_summary": {
    "train_mean_loss": 9.426064644694328,
    "train_mean_l2": 6.208298320971429,
    "train_mean_l1": 2.753059552669525,
    "num_steps": 2000,
    "num_batches": 2000
  },
  "feature_std_summary": {
    "plot_path": "outputs/plots/20251128-002046/feature_std_layer_12.html",
    "mean_std": 1.2004650831222534,
    "max_std": 24.676727294921875
  }
}