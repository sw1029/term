{
  "model_name": "google/gemma-2-2b-it",
  "layer_idx": 12,
  "command": "main.py sae.loss_option=2 sae.loss_module=option2_loss experiment.use_multi_contrast=true sae.alpha_concept.code=0.05 sae.alpha_concept.harm=0.05 sae.alpha_concept.struct=0.05",
  "sae": {
    "input_dim": 2304,
    "sae_dim": 9216,
    "fixed_v_cnt": 3,
    "batch_size": 4,
    "epochs": 1,
    "max_steps": 3000,
    "concept_samples_per_label": 250,
    "loss_option": 2,
    "loss_module": "option2_loss"
  },
  "gnn": {
    "use_gnn": true,
    "top_k": 10
  },
  "steering": {
    "label": "harm",
    "feature_idx": 1,
    "strength": 15.0
  },
  "prompt": "import pandas as pd\nfrom datanator.util import rna_halflife_util\nimport datetime\nimport datanator.config.core\nimport datetime\nfrom pymongo.collation import Collation, CollationStrength\n\n\nclass Halflife(rna_halflife_util.RnaHLUtil):\n\n    def __init__(self, cache_dir=None, server=None, src_db=None, protein_col=None,\n                authDB=None, readPreference=None, username=None, password=None,\n                verbose=None, max_entries=None, des_db=None, rna_col=None):\n        \"\"\"Init\n        \n        Args:\n            cache_dir (:obj:`str`, optional): Cache directory for logs. Defaults to None.\n            server (:obj:`str`, optional): MongoDB server address. Defaults to None.\n            db (:obj:`str`, optional): Database where initial uniprot collection resides. Defaults to None.\n            collection_str (:obj:`str`, optional): name of collection. Defaults to None.\n            authDB (:obj:`str`, optional): MongoDB authentication database. Defaults to None.\n            readPreference (:obj:`str`, optional): MongoDB read preference. Defaults to None.\n            username (:obj:`str`, optional): MongoDB username. Defaults to None.\n            password (:obj:`str`, optional): MongoDB password. Defaults to None.\n            verbose (:obj:`bool`, optional): Wheter to display verbose messages. Defaults to None.\n            max_entries (:obj:`int`, optional): Number of records to be processed. Defaults to None.\n            uniprot_col_db (:obj:`int`, optional): Database to which new uniprot records will be inserted. Defaults to None.\n        \"\"\"\n        super().__init__(server=server, username=username, password=password, src_db=src_db,\n        des_db=des_db, protein_col=protein_col, rna_col=rna_col, authDB=authDB, readPreference=readPreference,\n        max_entries=max_entries, verbose=verbose)\n        self.collation = Collation('en', strength=CollationStrength.SECONDARY)\n        self.max_entries = max_entries\n        self.verbose = verbose\n\n    def fill_uniprot(self, url, sheet_name, usercols='B:D', skiprows=[0,1,2],\n                    insertion=True):\n        \"\"\"Fill uniprot colleciton with ordered_locus_name\n        from excel sheet\n        \n        Args:\n            url (:obj:`str`): URL for Excel sheet.\n            sheet_name (:obj:`str`): sheet name within Excel.\n            usecols (:obj:`int` or :obj:`list` or :obj:`str`): Return a subset of the columns.\n            skiprows (:obj:`list`): rows to skip (0-indexed)\n            insertion (:obj:`bool`): whether to insert new records to uniprot collection.\n\n        Return:\n            (:obj:`pandas.DataFrame`): Dataframe\n        \"\"\"\n        df = self.make_df(url, sheet_name, usecols=usercols, skiprows=skiprows,\n        names=['ordered_locus_name', 'half_life', 'r_squared'])\n        row_count = len(df.index)\n        if insertion:\n            for index, row in df.iterrows():\n                if index == self.max_entries:\n                    break\n                if index % 10 == 0 and self.verbose:\n                    print(\"Inserting locus {} out of {} into uniprot collection.\".format(index, row_count))\n                oln = row['ordered_locus_name']\n                self.fill_uniprot_by_oln(oln)\n        return df\n\n    def fill_rna_halflife(self, df, species):\n        \"\"\"load data into rna_halflife collection\n        \n        Args:\n            df (:obj:`pandas.DataFrame`): dataframe to be loaded into the database\n            species (:obj:`list`): species name and ncbi_id\n        \"\"\"\n        row_count = len(df.index)\n        for i, row in df.iterrows():\n            if i == self.max_entries:\n                break\n            if i % 10 == 0 and self.verbose:\n                print(\"Processing locus {} out {}\".format(i, row_count))\n            halflives = {}\n            oln = row['ordered_locus_name']\n            halflives['halflife'] = row['half_life'] * 60\n            halflives['r_squared'] = row['r_squared']\n            halflives['unit'] = 's'\n            halflives['reference'] = [{'doi': '10.1093/nar/gks1019', 'pubmed_id': '23125364'}]\n            halflives['growth_medium'] = 'Middlebrook 7H9 with the ADC supplement (Difco) and 0.05% Tween80, at 37 degree celcius.'\n            halflives['ordered_locus_name'] = oln\n            halflives['species'] = species[0]\n            halflives['ncbi_taxonomy_id'] = species[1]\n            gene_name, protein_name = self.uniprot_query_manager.get_gene_protein_name_by_oln(oln)\n            if gene_name is not None: # record exists in uniprot collection with gene_name\n                self.rna_hl_collection.update_one({'gene_name': gene_name},\n                                                  {'$set': {'modified': datetime.datetime.utcnow()},\n                                                   '$addToSet': {'halflives': halflives,\n                                                                'protein_synonyms': protein_name}}, \n                                                   collation=self.collation, upsert=True)\n            elif (gene_name is None and protein_name is not None and \n                  protein_name != 'Uncharacterized protein'): # record exists in uniprot collection with non-filler protein_name\n                self.rna_hl_collection.update_one({'protein_name': protein_name},\n                                                  {'$set': {'modified': datetime.datetime.utcnow(),\n                                                            'gene_name': gene_name},\n                                                   '$addToSet': {'halflives': halflives,\n                                                                'protein_synonyms': protein_name}}, \n                                                   collation=self.collation, upsert=True)\n            else:\n                query = {'halflives.ordered_locus_name': oln}\n                doc = self.rna_hl_collection.find_one(filter=query, collation=self.collation)\n                if doc is not None:\n                    self.rna_hl_collection.update_one({'halflives.ordered_locus_name': oln},\n                                                    {'$set': {'modified': datetime.datetime.utcnow(),\n                                                              'gene_name': gene_name},\n                                                    '$addToSet': {'halflives': halflives,\n                                                                  'protein_synonyms': protein_name}}, \n                                                    collation=self.collation, upsert=True)\n                else:\n                    doc = {'halflives': [halflives], 'modified': datetime.datetime.utcnow(),\n                            'gene_name': gene_name, 'protein_name': protein_name}\n                    self.rna_hl_collection.insert_one(doc)\n\n\ndef main():\n    src_db = 'datanator'\n    des_db = 'datanator'\n    rna_col = 'rna_halflife'\n    protein_col = 'uniprot'\n    username = datanator.config.core.get_config()[\n        'datanator']['mongodb']['user']\n    password = datanator.config.core.get_config(\n    )['datanator']['mongodb']['password']\n    server = datanator.config.core.get_config(\n    )['datanator']['mongodb']['server']\n    src = Halflife(server=server, src_db=src_db,\n        protein_col=protein_col, authDB='admin', readPreference='nearest',\n        username=username, password=password, verbose=True, max_entries=float('inf'),\n        des_db=des_db, rna_col=rna_col)\n    url = 'https://oup.silverchair-cdn.com/oup/backfile/Content_public/Journal/nar/41/1/10.1093/nar/gks1019/2/gks1019-nar-00676-a-2012-File003.xlsx?Expires=1578425844&Signature=ZRFUxLdn4-vaBt5gQci~0o56KqyR9nJj9i32ig5X6YcfqiJeV3obEq8leHGdDxx6w~KABgewiQ66HTB7gmuG~2GL-YgxPKYSjt17WrYMkc-0ibw6TMlTvWZZfvw-lPe~wvpmVfNEXnTbP7jHyNLu9jeJ6yhoXvgIyQtzA5PbEI1fyXEgeZzOKMltmITqL3g3APsPsagCTC66rwrBT23Aghh6D314uilT2DZHCc68MH2nyV~qAhFqIQiOj-7VTEKqkDPvPYvuE2KNKXdvW23gk100YV~58ozbt8ijRz5Gr5gPtE~f1Ab5l260EIbWHJNabMRleInJQqUIDPFN4C38PQ__&Key-Pair-Id=APKAIE5G5CRDK6RD3PGA'\n    # df = src.fill_uniprot(url, 'Supplementary Table 1', insertion=False)\n    # src.fill_rna_halflife(df, ['Mycobacterium tuberculosis H37Rv', 83332])\n    df = src.fill_uniprot(url, 'Supplementary Table 2', skiprows=list(range(0,6)))\n    src.fill_rna_halflife(df, ['Mycolicibacterium smegmatis MC2 155', 246196])\n\nif __name__ == '__main__':\n    main()",
  "output": {
    "before": "import pandas as pd\nfrom datanator.util import rna_halflife_util\nimport datetime\nimport datanator.config.core\nimport datetime\nfrom pymongo.collation import Collation, CollationStrength\n\n\nclass Halflife(rna_halflife_util.RnaHLUtil):\n\n    def __init__(self, cache_dir=None, server=None, src_db=None, protein_col=None,\n                authDB=None, readPreference=None, username=None, password=None,\n                verbose=None, max_entries=None, des_db=None, rna_col=None):\n        \"\"\"Init\n        \n        Args:\n            cache_dir (:obj:`str`, optional): Cache directory for logs. Defaults to None.\n            server (:obj:`str`, optional): MongoDB server address. Defaults to None.\n            db (:obj:`str`, optional): Database where initial uniprot collection resides. Defaults to None.\n            collection_str (:obj:`str`, optional): name of collection. Defaults to None.\n            authDB (:obj:`str`, optional): MongoDB authentication database. Defaults to None.\n            readPreference (:obj:`str`, optional): MongoDB read preference. Defaults to None.\n            username (:obj:`str`, optional): MongoDB username. Defaults to None.\n            password (:obj:`str`, optional): MongoDB password. Defaults to None.\n            verbose (:obj:`bool`, optional): Wheter to display verbose messages. Defaults to None.\n            max_entries (:obj:`int`, optional): Number of records to be processed. Defaults to None.\n            uniprot_col_db (:obj:`int`, optional): Database to which new uniprot records will be inserted. Defaults to None.\n        \"\"\"\n        super().__init__(server=server, username=username, password=password, src_db=src_db,\n        des_db=des_db, protein_col=protein_col, rna_col=rna_col, authDB=authDB, readPreference=readPreference,\n        max_entries=max_entries, verbose=verbose)\n        self.collation = Collation('en', strength=CollationStrength.SECONDARY)\n        self.max_entries = max_entries\n        self.verbose = verbose\n\n    def fill_uniprot(self, url, sheet_name, usercols='B:D', skiprows=[0,1,2],\n                    insertion=True):\n        \"\"\"Fill uniprot colleciton with ordered_locus_name\n        from excel sheet\n        \n        Args:\n            url (:obj:`str`): URL for Excel sheet.\n            sheet_name (:obj:`str`): sheet name within Excel.\n            usecols (:obj:`int` or :obj:`list` or :obj:`str`): Return a subset of the columns.\n            skiprows (:obj:`list`): rows to skip (0-indexed)\n            insertion (:obj:`bool`): whether to insert new records to uniprot collection.\n\n        Return:\n            (:obj:`pandas.DataFrame`): Dataframe\n        \"\"\"\n        df = self.make_df(url, sheet_name, usecols=usercols, skiprows=skiprows,\n        names=['ordered_locus_name', 'half_life', 'r_squared'])\n        row_count = len(df.index)\n        if insertion:\n            for index, row in df.iterrows():\n                if index == self.max_entries:\n                    break\n                if index % 10 == 0 and self.verbose:\n                    print(\"Inserting locus {} out of {} into uniprot collection.\".format(index, row_count))\n                oln = row['ordered_locus_name']\n                self.fill_uniprot_by_oln(oln)\n        return df\n\n    def fill_rna_halflife(self, df, species):\n        \"\"\"load data into rna_halflife collection\n        \n        Args:\n            df (:obj:`pandas.DataFrame`): dataframe to be loaded into the database\n            species (:obj:`list`): species name and ncbi_id\n        \"\"\"\n        row_count = len(df.index)\n        for i, row in df.iterrows():\n            if i == self.max_entries:\n                break\n            if i % 10 == 0 and self.verbose:\n                print(\"Processing locus {} out {}\".format(i, row_count))\n            halflives = {}\n            oln = row['ordered_locus_name']\n            halflives['halflife'] = row['half_life'] * 60\n            halflives['r_squared'] = row['r_squared']\n            halflives['unit'] = 's'\n            halflives['reference'] = [{'doi': '10.1093/nar/gks1019', 'pubmed_id': '23125364'}]\n            halflives['growth_medium'] = 'Middlebrook 7H9 with the ADC supplement (Difco) and 0.05% Tween80, at 37 degree celcius.'\n            halflives['ordered_locus_name'] = oln\n            halflives['species'] = species[0]\n            halflives['ncbi_taxonomy_id'] = species[1]\n            gene_name, protein_name = self.uniprot_query_manager.get_gene_protein_name_by_oln(oln)\n            if gene_name is not None: # record exists in uniprot collection with gene_name\n                self.rna_hl_collection.update_one({'gene_name': gene_name},\n                                                  {'$set': {'modified': datetime.datetime.utcnow()},\n                                                   '$addToSet': {'halflives': halflives,\n                                                                'protein_synonyms': protein_name}}, \n                                                   collation=self.collation, upsert=True)\n            elif (gene_name is None and protein_name is not None and \n                  protein_name != 'Uncharacterized protein'): # record exists in uniprot collection with non-filler protein_name\n                self.rna_hl_collection.update_one({'protein_name': protein_name},\n                                                  {'$set': {'modified': datetime.datetime.utcnow(),\n                                                            'gene_name': gene_name},\n                                                   '$addToSet': {'halflives': halflives,\n                                                                'protein_synonyms': protein_name}}, \n                                                   collation=self.collation, upsert=True)\n            else:\n                query = {'halflives.ordered_locus_name': oln}\n                doc = self.rna_hl_collection.find_one(filter=query, collation=self.collation)\n                if doc is not None:\n                    self.rna_hl_collection.update_one({'halflives.ordered_locus_name': oln},\n                                                    {'$set': {'modified': datetime.datetime.utcnow(),\n                                                              'gene_name': gene_name},\n                                                    '$addToSet': {'halflives': halflives,\n                                                                  'protein_synonyms': protein_name}}, \n                                                    collation=self.collation, upsert=True)\n                else:\n                    doc = {'halflives': [halflives], 'modified': datetime.datetime.utcnow(),\n                            'gene_name': gene_name, 'protein_name': protein_name}\n                    self.rna_hl_collection.insert_one(doc)\n\n\ndef main():\n    src_db = 'datanator'\n    des_db = 'datanator'\n    rna_col = 'rna_halflife'\n    protein_col = 'uniprot'\n    username = datanator.config.core.get_config()[\n        'datanator']['mongodb']['user']\n    password = datanator.config.core.get_config(\n    )['datanator']['mongodb']['password']\n    server = datanator.config.core.get_config(\n    )['datanator']['mongodb']['server']\n    src = Halflife(server=server, src_db=src_db,\n        protein_col=protein_col, authDB='admin', readPreference='nearest',\n        username=username, password=password, verbose=True, max_entries=float('inf'),\n        des_db=des_db, rna_col=rna_col)\n    url = 'https://oup.silverchair-cdn.com/oup/backfile/Content_public/Journal/nar/41/1/10.1093/nar/gks1019/2/gks1019-nar-00676-a-2012-File003.xlsx?Expires=1578425844&Signature=ZRFUxLdn4-vaBt5gQci~0o56KqyR9nJj9i32ig5X6YcfqiJeV3obEq8leHGdDxx6w~KABgewiQ66HTB7gmuG~2GL-YgxPKYSjt17WrYMkc-0ibw6TMlTvWZZfvw-lPe~wvpmVfNEXnTbP7jHyNLu9jeJ6yhoXvgIyQtzA5PbEI1fyXEgeZzOKMltmITqL3g3APsPsagCTC66rwrBT23Aghh6D314uilT2DZHCc68MH2nyV~qAhFqIQiOj-7VTEKqkDPvPYvuE2KNKXdvW23gk100YV~58ozbt8ijRz5Gr5gPtE~f1Ab5l260EIbWHJNabMRleInJQqUIDPFN4C38PQ__&Key-Pair-Id=APKAIE5G5CRDK6RD3PGA'\n    # df = src.fill_uniprot(url, 'Supplementary Table 1', insertion=False)\n    # src.fill_rna_halflife(df, ['Mycobacterium tuberculosis H37Rv', 83332])\n    df = src.fill_uniprot(url, 'Supplementary Table 2', skiprows=list(range(0,6)))\n    src.fill_rna_halflife(df, ['Mycolicibacterium smegmatis MC2 155', 246196])\n\nif __name__ == '__main__':\n    main()\n```\n\nThis code defines a class `Halflife` which is a subclass of `rna_halflife_util.RnaHLUtil`. \n\nThe class has a constructor that takes arguments for the MongoDB server, database, collection, and",
    "after": "import pandas as pd\nfrom datanator.util import rna_halflife_util\nimport datetime\nimport datanator.config.core\nimport datetime\nfrom pymongo.collation import Collation, CollationStrength\n\n\nclass Halflife(rna_halflife_util.RnaHLUtil):\n\n    def __init__(self, cache_dir=None, server=None, src_db=None, protein_col=None,\n                authDB=None, readPreference=None, username=None, password=None,\n                verbose=None, max_entries=None, des_db=None, rna_col=None):\n        \"\"\"Init\n        \n        Args:\n            cache_dir (:obj:`str`, optional): Cache directory for logs. Defaults to None.\n            server (:obj:`str`, optional): MongoDB server address. Defaults to None.\n            db (:obj:`str`, optional): Database where initial uniprot collection resides. Defaults to None.\n            collection_str (:obj:`str`, optional): name of collection. Defaults to None.\n            authDB (:obj:`str`, optional): MongoDB authentication database. Defaults to None.\n            readPreference (:obj:`str`, optional): MongoDB read preference. Defaults to None.\n            username (:obj:`str`, optional): MongoDB username. Defaults to None.\n            password (:obj:`str`, optional): MongoDB password. Defaults to None.\n            verbose (:obj:`bool`, optional): Wheter to display verbose messages. Defaults to None.\n            max_entries (:obj:`int`, optional): Number of records to be processed. Defaults to None.\n            uniprot_col_db (:obj:`int`, optional): Database to which new uniprot records will be inserted. Defaults to None.\n        \"\"\"\n        super().__init__(server=server, username=username, password=password, src_db=src_db,\n        des_db=des_db, protein_col=protein_col, rna_col=rna_col, authDB=authDB, readPreference=readPreference,\n        max_entries=max_entries, verbose=verbose)\n        self.collation = Collation('en', strength=CollationStrength.SECONDARY)\n        self.max_entries = max_entries\n        self.verbose = verbose\n\n    def fill_uniprot(self, url, sheet_name, usercols='B:D', skiprows=[0,1,2],\n                    insertion=True):\n        \"\"\"Fill uniprot colleciton with ordered_locus_name\n        from excel sheet\n        \n        Args:\n            url (:obj:`str`): URL for Excel sheet.\n            sheet_name (:obj:`str`): sheet name within Excel.\n            usecols (:obj:`int` or :obj:`list` or :obj:`str`): Return a subset of the columns.\n            skiprows (:obj:`list`): rows to skip (0-indexed)\n            insertion (:obj:`bool`): whether to insert new records to uniprot collection.\n\n        Return:\n            (:obj:`pandas.DataFrame`): Dataframe\n        \"\"\"\n        df = self.make_df(url, sheet_name, usecols=usercols, skiprows=skiprows,\n        names=['ordered_locus_name', 'half_life', 'r_squared'])\n        row_count = len(df.index)\n        if insertion:\n            for index, row in df.iterrows():\n                if index == self.max_entries:\n                    break\n                if index % 10 == 0 and self.verbose:\n                    print(\"Inserting locus {} out of {} into uniprot collection.\".format(index, row_count))\n                oln = row['ordered_locus_name']\n                self.fill_uniprot_by_oln(oln)\n        return df\n\n    def fill_rna_halflife(self, df, species):\n        \"\"\"load data into rna_halflife collection\n        \n        Args:\n            df (:obj:`pandas.DataFrame`): dataframe to be loaded into the database\n            species (:obj:`list`): species name and ncbi_id\n        \"\"\"\n        row_count = len(df.index)\n        for i, row in df.iterrows():\n            if i == self.max_entries:\n                break\n            if i % 10 == 0 and self.verbose:\n                print(\"Processing locus {} out {}\".format(i, row_count))\n            halflives = {}\n            oln = row['ordered_locus_name']\n            halflives['halflife'] = row['half_life'] * 60\n            halflives['r_squared'] = row['r_squared']\n            halflives['unit'] = 's'\n            halflives['reference'] = [{'doi': '10.1093/nar/gks1019', 'pubmed_id': '23125364'}]\n            halflives['growth_medium'] = 'Middlebrook 7H9 with the ADC supplement (Difco) and 0.05% Tween80, at 37 degree celcius.'\n            halflives['ordered_locus_name'] = oln\n            halflives['species'] = species[0]\n            halflives['ncbi_taxonomy_id'] = species[1]\n            gene_name, protein_name = self.uniprot_query_manager.get_gene_protein_name_by_oln(oln)\n            if gene_name is not None: # record exists in uniprot collection with gene_name\n                self.rna_hl_collection.update_one({'gene_name': gene_name},\n                                                  {'$set': {'modified': datetime.datetime.utcnow()},\n                                                   '$addToSet': {'halflives': halflives,\n                                                                'protein_synonyms': protein_name}}, \n                                                   collation=self.collation, upsert=True)\n            elif (gene_name is None and protein_name is not None and \n                  protein_name != 'Uncharacterized protein'): # record exists in uniprot collection with non-filler protein_name\n                self.rna_hl_collection.update_one({'protein_name': protein_name},\n                                                  {'$set': {'modified': datetime.datetime.utcnow(),\n                                                            'gene_name': gene_name},\n                                                   '$addToSet': {'halflives': halflives,\n                                                                'protein_synonyms': protein_name}}, \n                                                   collation=self.collation, upsert=True)\n            else:\n                query = {'halflives.ordered_locus_name': oln}\n                doc = self.rna_hl_collection.find_one(filter=query, collation=self.collation)\n                if doc is not None:\n                    self.rna_hl_collection.update_one({'halflives.ordered_locus_name': oln},\n                                                    {'$set': {'modified': datetime.datetime.utcnow(),\n                                                              'gene_name': gene_name},\n                                                    '$addToSet': {'halflives': halflives,\n                                                                  'protein_synonyms': protein_name}}, \n                                                    collation=self.collation, upsert=True)\n                else:\n                    doc = {'halflives': [halflives], 'modified': datetime.datetime.utcnow(),\n                            'gene_name': gene_name, 'protein_name': protein_name}\n                    self.rna_hl_collection.insert_one(doc)\n\n\ndef main():\n    src_db = 'datanator'\n    des_db = 'datanator'\n    rna_col = 'rna_halflife'\n    protein_col = 'uniprot'\n    username = datanator.config.core.get_config()[\n        'datanator']['mongodb']['user']\n    password = datanator.config.core.get_config(\n    )['datanator']['mongodb']['password']\n    server = datanator.config.core.get_config(\n    )['datanator']['mongodb']['server']\n    src = Halflife(server=server, src_db=src_db,\n        protein_col=protein_col, authDB='admin', readPreference='nearest',\n        username=username, password=password, verbose=True, max_entries=float('inf'),\n        des_db=des_db, rna_col=rna_col)\n    url = 'https://oup.silverchair-cdn.com/oup/backfile/Content_public/Journal/nar/41/1/10.1093/nar/gks1019/2/gks1019-nar-00676-a-2012-File003.xlsx?Expires=1578425844&Signature=ZRFUxLdn4-vaBt5gQci~0o56KqyR9nJj9i32ig5X6YcfqiJeV3obEq8leHGdDxx6w~KABgewiQ66HTB7gmuG~2GL-YgxPKYSjt17WrYMkc-0ibw6TMlTvWZZfvw-lPe~wvpmVfNEXnTbP7jHyNLu9jeJ6yhoXvgIyQtzA5PbEI1fyXEgeZzOKMltmITqL3g3APsPsagCTC66rwrBT23Aghh6D314uilT2DZHCc68MH2nyV~qAhFqIQiOj-7VTEKqkDPvPYvuE2KNKXdvW23gk100YV~58ozbt8ijRz5Gr5gPtE~f1Ab5l260EIbWHJNabMRleInJQqUIDPFN4C38PQ__&Key-Pair-Id=APKAIE5G5CRDK6RD3PGA'\n    # df = src.fill_uniprot(url, 'Supplementary Table 1', insertion=False)\n    # src.fill_rna_halflife(df, ['Mycobacterium tuberculosis H37Rv', 83332])\n    df = src.fill_uniprot(url, 'Supplementary Table 2', skiprows=list(range(0,6)))\n    src.fill_rna_halflife(df, ['Mycolicibacterium smegmatis MC2 155', 246196])\n\nif __name__ == '__main__':\n    main()\n\n    \n```\n\n\nThis code snippet provides a more comprehensive explanation of the process of how to execute the code. \nPlease note that this code is meant to be used for educational purposes and is not intended to be a comprehensive guide.\n\n\nLet"
  },
  "feature_stats": {
    "indices": [
      1,
      2,
      5222,
      4669,
      9015,
      3992,
      6186,
      5991,
      8598,
      6644,
      4763
    ],
    "f_before": [
      16.768510818481445,
      59.08503723144531,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "f_after": [
      16.768510818481445,
      59.08503723144531,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "g_before": [
      20.403743743896484,
      63.22382354736328,
      1.7081071138381958,
      1.5893460512161255,
      0.0,
      1.628366470336914,
      1.6475862264633179,
      1.5773364305496216,
      1.55605149269104,
      0.0,
      1.5944017171859741
    ],
    "g_after": [
      20.403743743896484,
      63.22382354736328,
      1.7081071138381958,
      1.5893460512161255,
      0.0,
      1.628366470336914,
      1.6475862264633179,
      1.5773364305496216,
      1.55605149269104,
      0.0,
      1.5944017171859741
    ],
    "num_batches_for_stats": 10
  },
  "loss_summary": {
    "train_mean_loss": 5.568553069072883,
    "train_mean_l2": 7.2129372553662545,
    "train_mean_l1": 3.428529784766906,
    "num_steps": 1962,
    "num_batches": 1962
  },
  "feature_std_summary": {
    "plot_path": "outputs/plots/20251126-195644/feature_std_layer_12.html",
    "mean_std": 2.379754066467285,
    "max_std": 91.05052185058594
  }
}