{
  "model_name": "google/gemma-2-2b-it",
  "layer_idx": 12,
  "command": "main.py sae.loss_option=3 sae.loss_module=option3_loss experiment.use_multi_contrast=true",
  "sae": {
    "input_dim": 2304,
    "sae_dim": 9216,
    "fixed_v_cnt": 0,
    "batch_size": 4,
    "epochs": 2,
    "max_steps": 3000,
    "concept_samples_per_label": 250,
    "loss_option": 3,
    "loss_module": "option3_loss"
  },
  "gnn": {
    "use_gnn": true,
    "top_k": 10
  },
  "steering": {
    "label": "struct",
    "feature_idx": 2,
    "strength": 15.0
  },
  "prompt": "# -*- coding: utf-8 -*-\n\n\"\"\"\n    eve.io.base\n    ~~~~~~~~~~~\n\n    Standard interface implemented by Eve data layers.\n\n    :copyright: (c) 2014 by Nicola Iarocci.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport datetime\nimport simplejson as json\nfrom copy import copy\nfrom flask import request, abort\nfrom eve.utils import date_to_str\nfrom eve.auth import auth_field_and_value\nfrom eve.utils import config, debug_error_message, auto_fields\n\n\nclass BaseJSONEncoder(json.JSONEncoder):\n    \"\"\" Proprietary JSONEconder subclass used by the json render function.\n    This is needed to address the encoding of special values.\n    \"\"\"\n    def default(self, obj):\n        if isinstance(obj, datetime.datetime):\n            # convert any datetime to RFC 1123 format\n            return date_to_str(obj)\n        elif isinstance(obj, (datetime.time, datetime.date)):\n            # should not happen since the only supported date-like format\n            # supported at dmain schema level is 'datetime' .\n            return obj.isoformat()\n        return json.JSONEncoder.default(self, obj)\n\n\nclass ConnectionException(Exception):\n    \"\"\" Raised when DataLayer subclasses cannot find/activate to their\n    database connection.\n\n    :param driver_exception: the original exception raised by the source db\n                             driver\n    \"\"\"\n    def __init__(self, driver_exception=None):\n        self.driver_exception = driver_exception\n\n    def __str__(self):\n        msg = (\"Error initializing the driver. Make sure the database server\"\n               \"is running. \")\n        if self.driver_exception:\n            msg += \"Driver exception: %s\" % repr(self.driver_exception)\n        return msg\n\n\nclass DataLayer(object):\n    \"\"\" Base data layer class. Defines the interface that actual data-access\n    classes, being subclasses, must implement. Implemented as a Flask\n    extension.\n\n    Admittedly, this interface is a Mongo rip-off. See the io.mongo\n    package for an implementation example.\n\n    .. versionchanged:: 0.2\n       Allow subclasses to provide their own specialized json encoder.\n\n    .. versionchanged:: 0.1.1\n       'serializers' dictionary added.\n\n    .. versionchanged:: 0.1.0\n       Support for PUT method.\n\n    .. versionchanged:: 0.0.6\n       support for 'projections' has been added. For more information see\n       http://docs.mongodb.org/manual/reference/glossary/#term-projection.\n       While typically a MongoDB feature, other subclasses could decide to\n       provide support for their own projection syntax.\n\n    .. versionchanged:: 0.0.4\n       the _datasource helper function has been added.\n    \"\"\"\n\n    # if custom serialize functions are needed, add them to the 'serializers'\n    # dictionary, eg:\n    # serializers = {'objectid': ObjectId, 'datetime': serialize_date}\n    serializers = {}\n\n    # json.JSONEncoder subclass for serializing data to json.\n    # Subclasses should provide their own specialized encoder (see\n    # eve.io.mongo.MongoJSONEncoder).\n    json_encoder_class = BaseJSONEncoder\n\n    def __init__(self, app):\n        \"\"\" Implements the Flask extension pattern.\n\n        .. versionchanged:: 0.2\n           Explicit initialize self.driver to None.\n        \"\"\"\n        self.driver = None\n        if app is not None:\n            self.app = app\n            self.init_app(self.app)\n        else:\n            self.app = None\n\n    def init_app(self, app):\n        \"\"\" This is where you want to initialize the db driver so it will be\n        alive through the whole instance lifespan.\n        \"\"\"\n        raise NotImplementedError\n\n    def find(self, resource, req, sub_resource_lookup):\n        \"\"\" Retrieves a set of documents (rows), matching the current request.\n        Consumed when a request hits a collection/document endpoint\n        (`/people/`).\n\n        :param resource: resource being accessed. You should then use\n                         the ``_datasource`` helper function to retrieve both\n                         the db collection/table and base query (filter), if\n                         any.\n        :param req: an instance of ``eve.utils.ParsedRequest``. This contains\n                    all the constraints that must be fulfilled in order to\n                    satisfy the original request (where and sort parts, paging,\n                    etc). Be warned that `where` and `sort` expresions will\n                    need proper parsing, according to the syntax that you want\n                    to support with your driver. For example ``eve.io.Mongo``\n                    supports both Python and Mongo-like query syntaxes.\n        :param sub_resource_lookup: sub-resource lookup from the endpoint url.\n\n        .. versionchanged:: 0.3\n           Support for sub-resources.\n        \"\"\"\n        raise NotImplementedError\n\n    def find_one(self, resource, req, **lookup):\n        \"\"\" Retrieves a single document/record. Consumed when a request hits an\n        item endpoint (`/people/id/`).\n\n        :param resource: resource being accessed. You should then use the\n                         ``_datasource`` helper function to retrieve both the\n                         db collection/table and base query (filter), if any.\n        :param req: an instance of ``eve.utils.ParsedRequest``. This contains\n                    all the constraints that must be fulfilled in order to\n                    satisfy the original request (where and sort parts, paging,\n                    etc). As we are going to only look for one document here,\n                    the only req attribute that you want to process here is\n                    ``req.projection``.\n\n        :param **lookup: the lookup fields. This will most likely be a record\n                         id or, if alternate lookup is supported by the API,\n                         the corresponding query.\n\n\n        .. versionchanged:: 0.4\n           Added the 'req' argument.\n        \"\"\"\n        raise NotImplementedError\n\n    def find_one_raw(self, resource, _id):\n        \"\"\" Retrieves a single, raw document. No projections or datasource\n        filters are being applied here. Just looking up the document by unique\n        id.\n\n        :param resource: resource name.\n        :param id: unique id.\n\n        .. versionadded:: 0.4\n        \"\"\"\n        raise NotImplementedError\n\n    def find_list_of_ids(self, resource, ids, client_projection=None):\n        \"\"\" Retrieves a list of documents based on a list of primary keys\n        The primary key is the field defined in `ID_FIELD`.\n        This is a separate function to allow us to use per-database\n        optimizations for this type of query.\n\n        :param resource: resource name.\n        :param ids: a list of ids corresponding to the documents\n        to retrieve\n        :param client_projection: a specific projection to use\n        :return: a list of documents matching the ids in `ids` from the\n        collection specified in `resource`\n\n        .. versionadded:: 0.1.0\n        \"\"\"\n        raise NotImplementedError\n\n    def insert(self, resource, doc_or_docs):\n        \"\"\" Inserts a document into a resource collection/table.\n\n        :param resource: resource being accessed. You should then use\n                         the ``_datasource`` helper function to retrieve both\n                         the actual datasource name.\n        :param doc_or_docs: json document or list of json documents to be added\n                            to the database.\n\n        .. versionchanged:: 0.0.6\n            'document' param renamed to 'doc_or_docs', making support for bulk\n            inserts apparent.\n        \"\"\"\n        raise NotImplementedError\n\n    def update(self, resource, id_, updates):\n        \"\"\" Updates a collection/table document/row.\n        :param resource: resource being accessed. You should then use\n                         the ``_datasource`` helper function to retrieve\n                         the actual datasource name.\n        :param id_: the unique id of the document.\n        :param updates: json updates to be performed on the database document\n                        (or row).\n        \"\"\"\n        raise NotImplementedError\n\n    def replace(self, resource, id_, document):\n        \"\"\" Replaces a collection/table document/row.\n        :param resource: resource being accessed. You should then use\n                         the ``_datasource`` helper function to retrieve\n                         the actual datasource name.\n        :param id_: the unique id of the document.\n        :param document: the new json document\n\n        .. versionadded:: 0.1.0\n        \"\"\"\n        raise NotImplementedError\n\n    def remove(self, resource, lookup={}):\n        \"\"\" Removes a document/row or an entire set of documents/rows from a\n        database collection/table.\n\n        :param resource: resource being accessed. You should then use\n                         the ``_datasource`` helper function to retrieve\n                         the actual datasource name.\n        :param lookup: a dict with the query that documents must match in order\n                       to qualify for deletion. For single document deletes,\n                       this is usually the unique id of the document to be\n                       removed.\n\n        .. versionchanged:: 0.3\n           '_id' arg removed; replaced with 'lookup'.\n        \"\"\"\n        raise NotImplementedError\n\n    def combine_queries(self, query_a, query_b):\n        \"\"\" Takes two db queries and applies db-specific syntax to produce\n        the intersection.\n\n        .. versionadded: 0.1.0\n           Support for intelligent combination of db queries\n        \"\"\"\n        raise NotImplementedError\n\n    def get_value_from_query(self, query, field_name):\n        \"\"\" Parses the given potentially-complex query and returns the value\n        being assigned to the field given in `field_name`.\n\n        This mainly exists to deal with more complicated compound queries\n\n        .. versionadded: 0.1.0\n           Support for parsing values embedded in compound db queries\n        \"\"\"\n        raise NotImplementedError\n\n    def query_contains_field(self, query, field_name):\n        \"\"\" For the specified field name, does the query contain it?\n        Used know whether we need to parse a compound query.\n\n        .. versionadded: 0.1.0\n           Support for parsing values embedded in compound db queries\n        \"\"\"\n        raise NotImplementedError\n\n    def is_empty(self, resource):\n        \"\"\" Returns True if the collection is empty; False otherwise. While\n        a user could rely on self.find() method to achieve the same result,\n        this method can probably take advantage of specific datastore features\n        to provide better perfomance.\n\n        Don't forget, a 'resource' could have a pre-defined filter. If that is\n        the case, it will have to be taken into consideration when performing\n        the is_empty() check (see eve.io.mongo.mongo.py implementation).\n\n        :param resource: resource being accessed. You should then use\n                         the ``_datasource`` helper function to retrieve\n                         the actual datasource name.\n\n        .. versionadded: 0.3\n        \"\"\"\n        raise NotImplementedError\n\n    def _datasource(self, resource):\n        \"\"\" Returns a tuple with the actual name of the database\n        collection/table, base query and projection for the resource being\n        accessed.\n\n        :param resource: resource being accessed.\n\n        .. versionchanged:: 0.5\n           If allow_unknown is enabled for the resource, don't return any\n           projection for the document. Addresses #397 and #250.\n\n        .. versionchanged:: 0.4\n           Return copies to avoid accidental tampering. Fix #258.\n\n        .. versionchanged:: 0.2\n           Support for 'default_sort'.\n        \"\"\"\n        dsource = config.SOURCES[resource]\n\n        source = copy(dsource['source'])\n        filter_ = copy(dsource['filter'])\n        sort = copy(dsource['default_sort'])\n\n        # if allow_unknown is enabled for the resource, then don't return\n        # the default or client projection so all document fields can be\n        # returned to the client (regardless of the resource schema).\n        allow_unknown = config.DOMAIN[resource]['allow_unknown']\n        projection = copy(dsource['projection']) if not allow_unknown else None\n\n        return source, filter_, projection, sort,\n\n    def _datasource_ex(self, resource, query=None, client_projection=None,\n                       client_sort=None):\n        \"\"\" Returns both db collection and exact query (base filter included)\n        to which an API resource refers to.\n\n        .. versionchanged:: 0.4\n           Always return required/auto fields (issue 282.)\n\n        .. versionchanged:: 0.3\n           Field exclusion support in client projections.\n           Honor auth_field even when client query is missing.\n           Only inject auth_field in queries when we are not creating new\n           documents.\n           'auth_field' and 'request_auth_value' fetching is now delegated to\n           auth.auth_field_and value().\n\n        .. versionchanged:: 0.2\n           Difference between resource and item endpoints is now determined\n           by the presence of a '|' in request.endpoint.\n           Support for 'default_sort'.\n\n        .. versionchanged:: 0.1.1\n           auth.request_auth_value is now used to store the auth_field value.\n\n        .. versionchanged:: 0.1.0\n           Calls `combine_queries` to merge query and filter_\n           Updated logic performing `auth_field` check\n\n        .. versionchanged:: 0.0.9\n           Storing self.app.auth.userid in auth_field when 'user-restricted\n           resource access' is enabled.\n           Support for Python 3.3.\n\n        .. versionchanged:: 0.0.6\n           'auth_username_field' is injected even in empty queries.\n           Projection queries ('?projection={\"name\": 1}')\n\n        .. versionchanged:: 0.0.5\n           Support for 'user-restricted resource access'.\n\n        .. versionadded:: 0.0.4\n        \"\"\"\n\n        datasource, filter_, projection_, sort_ = self._datasource(resource)\n\n        if client_sort:\n            sort = client_sort\n        else:\n            # default sort is activated only if 'sorting' is enabled for the\n            # resource.\n            # TODO Consider raising a validation error on startup instead?\n            sort = sort_ if sort_ and config.DOMAIN[resource]['sorting'] else \\\n                None\n\n        if filter_:\n            if query:\n                # Can't just dump one set of query operators into another\n                # e.g. if the dataset contains a custom datasource pattern\n                #   'filter': {'username': {'$exists': True}}\n                # and we try to filter on the field `username`,\n                # which is correct?\n\n                # Solution: call the db driver `combine_queries` operation\n                # which will apply db-specific syntax to produce the\n                # intersection of the two queries\n                query = self.combine_queries(query, filter_)\n            else:\n                query = filter_\n\n        fields = projection_\n        if client_projection:\n            # only allow fields which are included with the standard projection\n            # for the resource (avoid sniffing of private fields)\n            keep_fields = auto_fields(resource)\n            if 0 not in client_projection.values():\n                # inclusive projection - all values are 0 unless spec. or auto\n                fields = dict([(field, field in keep_fields) for field in\n                               fields.keys()])\n            for field, value in client_projection.items():\n                field_base = field.split('.')[0]\n                if field_base not in keep_fields and field_base in fields:\n                    fields[field] = value\n            fields = dict([(field, 1) for field, value in fields.items() if\n                           value])\n\n        # If the current HTTP method is in `public_methods` or\n        # `public_item_methods`, skip the `auth_field` check\n\n        # Only inject the auth_field in the query when not creating new\n        # documents.\n        if request and request.method not in ('POST', 'PUT'):\n            auth_field, request_auth_value = auth_field_and_value(resource)\n            if auth_field and request.authorization and request_auth_value:\n                if query:\n                    # If the auth_field *replaces* a field in the query,\n                    # and the values are /different/, deny the request\n                    # This prevents the auth_field condition from\n                    # overwriting the query (issue #77)\n                    auth_field_in_query = \\\n                        self.app.data.query_contains_field(query, auth_field)\n                    if auth_field_in_query and \\\n                            self.app.data.get_value_from_query(\n                                query, auth_field) != request_auth_value:\n                        abort(401, description=debug_error_message(\n                            'Incompatible User-Restricted Resource request. '\n                            'Request was for \"%s\"=\"%s\" but `auth_field` '\n                            'requires \"%s\"=\"%s\".' % (\n                                auth_field,\n                                self.app.data.get_value_from_query(\n                                    query, auth_field),\n                                auth_field,\n                                request_auth_value)\n                        ))\n                    else:\n                        query = self.app.data.combine_queries(\n                            query, {auth_field: request_auth_value}\n                        )\n                else:\n                    query = {auth_field: request_auth_value}\n        return datasource, query, fields, sort\n",
  "output": {
    "before": "# -*- coding: utf-8 -*-\n\n\"\"\"\n    eve.io.base\n    ~~~~~~~~~~~\n\n    Standard interface implemented by Eve data layers.\n\n    :copyright: (c) 2014 by Nicola Iarocci.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport datetime\nimport simplejson as json\nfrom copy import copy\nfrom flask import request, abort\nfrom eve.utils import date_to_str\nfrom eve.auth import auth_field_and_value\nfrom eve.utils import config, debug_error_message, auto_fields\n\n\nclass BaseJSONEncoder(json.JSONEncoder):\n    \"\"\" Proprietary JSONEconder subclass used by the json render function.\n    This is needed to address the encoding of special values.\n    \"\"\"\n    def default(self, obj):\n        if isinstance(obj, datetime.datetime):\n            # convert any datetime to RFC 1123 format\n            return date_to_str(obj)\n        elif isinstance(obj, (datetime.time, datetime.date)):\n            # should not happen since the only supported date-like format\n            # supported at dmain schema level is 'datetime' .\n            return obj.isoformat()\n        return json.JSONEncoder.default(self, obj)\n\n\nclass ConnectionException(Exception):\n    \"\"\" Raised when DataLayer subclasses cannot find/activate to their\n    database connection.\n\n    :param driver_exception: the original exception raised by the source db\n                             driver\n    \"\"\"\n    def __init__(self, driver_exception=None):\n        self.driver_exception = driver_exception\n\n    def __str__(self):\n        msg = (\"Error initializing the driver. Make sure the database server\"\n               \"is running. \")\n        if self.driver_exception:\n            msg += \"Driver exception: %s\" % repr(self.driver_exception)\n        return msg\n\n\nclass DataLayer(object):\n    \"\"\" Base data layer class. Defines the interface that actual data-access\n    classes, being subclasses, must implement. Implemented as a Flask\n    extension.\n\n    Admittedly, this interface is a Mongo rip-off. See the io.mongo\n    package for an implementation example.\n\n    .. versionchanged:: 0.2\n       Allow subclasses to provide their own specialized json encoder.\n\n    .. versionchanged:: 0.1.1\n       'serializers' dictionary added.\n\n    .. versionchanged:: 0.1.0\n       Support for PUT method.\n\n    .. versionchanged:: 0.0.6\n       support for 'projections' has been added. For more information see\n       http://docs.mongodb.org/manual/reference/glossary/#term-projection.\n       While typically a MongoDB feature, other subclasses could decide to\n       provide support for their own projection syntax.\n\n    .. versionchanged:: 0.0.4\n       the _datasource helper function has been added.\n    \"\"\"\n\n    # if custom serialize functions are needed, add them to the 'serializers'\n    # dictionary, eg:\n    # serializers = {'objectid': ObjectId, 'datetime': serialize_date}\n    serializers = {}\n\n    # json.JSONEncoder subclass for serializing data to json.\n    # Subclasses should provide their own specialized encoder (see\n    # eve.io.mongo.MongoJSONEncoder).\n    json_encoder_class = BaseJSONEncoder\n\n    def __init__(self, app):\n        \"\"\" Implements the Flask extension pattern.\n\n        .. versionchanged:: 0.2\n           Explicit initialize self.driver to None.\n        \"\"\"\n        self.driver = None\n        if app is not None:\n            self.app = app\n            self.init_app(self.app)\n        else:\n            self.app = None\n\n    def init_app(self, app):\n        \"\"\" This is where you want to initialize the db driver so it will be\n        alive through the whole instance lifespan.\n        \"\"\"\n        raise NotImplementedError\n\n    def find(self, resource, req, sub_resource_lookup):\n        \"\"\" Retrieves a set of documents (rows), matching the current request.\n        Consumed when a request hits a collection/document endpoint\n        (`/people/`).\n\n        :param resource: resource being accessed. You should then use\n                         the ``_datasource`` helper function to retrieve both\n                         the db collection/table and base query (filter), if\n                         any.\n        :param req: an instance of ``eve.utils.ParsedRequest``. This contains\n                    all the constraints that must be fulfilled in order to\n                    satisfy the original request (where and sort parts, paging,\n                    etc). Be warned that `where` and `sort` expresions will\n                    need proper parsing, according to the syntax that you want\n                    to support with your driver. For example ``eve.io.Mongo``\n                    supports both Python and Mongo-like query syntaxes.\n        :param sub_resource_lookup: sub-resource lookup from the endpoint url.\n\n        .. versionchanged:: 0.3\n           Support for sub-resources.\n        \"\"\"\n        raise NotImplementedError\n\n    def find_one(self, resource, req, **lookup):\n        \"\"\" Retrieves a single document/record. Consumed when a request hits an\n        item endpoint (`/people/id/`).\n\n        :param resource: resource being accessed. You should then use the\n                         ``_datasource`` helper function to retrieve both the\n                         db collection/table and base query (filter), if any.\n        :param req: an instance of ``eve.utils.ParsedRequest``. This contains\n                    all the constraints that must be fulfilled in order to\n                    satisfy the original request (where and sort parts, paging,\n                    etc). As we are going to only look for one document here,\n                    the only req attribute that you want to process here is\n                    ``req.projection``.\n\n        :param **lookup: the lookup fields. This will most likely be a record\n                         id or, if alternate lookup is supported by the API,\n                         the corresponding query.\n\n\n        .. versionchanged:: 0.4\n           Added the 'req' argument.\n        \"\"\"\n        raise NotImplementedError\n\n    def find_one_raw(self, resource, _id):\n        \"\"\" Retrieves a single, raw document. No projections or datasource\n        filters are being applied here. Just looking up the document by unique\n        id.\n\n        :param resource: resource name.\n        :param id: unique id.\n\n        .. versionadded:: 0.4\n        \"\"\"\n        raise NotImplementedError\n\n    def find_list_of_ids(self, resource, ids, client_projection=None):\n        \"\"\" Retrieves a list of documents based on a list of primary keys\n        The primary key is the field defined in `ID_FIELD`.\n        This is a separate function to allow us to use per-database\n        optimizations for this type of query.\n\n        :param resource: resource name.\n        :param ids: a list of ids corresponding to the documents\n        to retrieve\n        :param client_projection: a specific projection to use\n        :return: a list of documents matching the ids in `ids` from the\n        collection specified in `resource`\n\n        .. versionadded:: 0.1.0\n        \"\"\"\n        raise NotImplementedError\n\n    def insert(self, resource, doc_or_docs):\n        \"\"\" Inserts a document into a resource collection/table.\n\n        :param resource: resource being accessed. You should then use\n                         the ``_datasource`` helper function to retrieve both\n                         the actual datasource name.\n        :param doc_or_docs: json document or list of json documents to be added\n                            to the database.\n\n        .. versionchanged:: 0.0.6\n            'document' param renamed to 'doc_or_docs', making support for bulk\n            inserts apparent.\n        \"\"\"\n        raise NotImplementedError\n\n    def update(self, resource, id_, updates):\n        \"\"\" Updates a collection/table document/row.\n        :param resource: resource being accessed. You should then use\n                         the ``_datasource`` helper function to retrieve\n                         the actual datasource name.\n        :param id_: the unique id of the document.\n        :param updates: json updates to be performed on the database document\n                        (or row).\n        \"\"\"\n        raise NotImplementedError\n\n    def replace(self, resource, id_, document):\n        \"\"\" Replaces a collection/table document/row.\n        :param resource: resource being accessed. You should then use\n                         the ``_datasource`` helper function to retrieve\n                         the actual datasource name.\n        :param id_: the unique id of the document.\n        :param document: the new json document\n\n        .. versionadded:: 0.1.0\n        \"\"\"\n        raise NotImplementedError\n\n    def remove(self, resource, lookup={}):\n        \"\"\" Removes a document/row or an entire set of documents/rows from a\n        database collection/table.\n\n        :param resource: resource being accessed. You should then use\n                         the ``_datasource`` helper function to retrieve\n                         the actual datasource name.\n        :param lookup: a dict with the query that documents must match in order\n                       to qualify for deletion. For single document deletes,\n                       this is usually the unique id of the document to be\n                       removed.\n\n        .. versionchanged:: 0.3\n           '_id' arg removed; replaced with 'lookup'.\n        \"\"\"\n        raise NotImplementedError\n\n    def combine_queries(self, query_a, query_b):\n        \"\"\" Takes two db queries and applies db-specific syntax to produce\n        the intersection.\n\n        .. versionadded: 0.1.0\n           Support for intelligent combination of db queries\n        \"\"\"\n        raise NotImplementedError\n\n    def get_value_from_query(self, query, field_name):\n        \"\"\" Parses the given potentially-complex query and returns the value\n        being assigned to the field given in `field_name`.\n\n        This mainly exists to deal with more complicated compound queries\n\n        .. versionadded: 0.1.0\n           Support for parsing values embedded in compound db queries\n        \"\"\"\n        raise NotImplementedError\n\n    def query_contains_field(self, query, field_name):\n        \"\"\" For the specified field name, does the query contain it?\n        Used know whether we need to parse a compound query.\n\n        .. versionadded: 0.1.0\n           Support for parsing values embedded in compound db queries\n        \"\"\"\n        raise NotImplementedError\n\n    def is_empty(self, resource):\n        \"\"\" Returns True if the collection is empty; False otherwise. While\n        a user could rely on self.find() method to achieve the same result,\n        this method can probably take advantage of specific datastore features\n        to provide better perfomance.\n\n        Don't forget, a 'resource' could have a pre-defined filter. If that is\n        the case, it will have to be taken into consideration when performing\n        the is_empty() check (see eve.io.mongo.mongo.py implementation).\n\n        :param resource: resource being accessed. You should then use\n                         the ``_datasource`` helper function to retrieve\n                         the actual datasource name.\n\n        .. versionadded: 0.3\n        \"\"\"\n        raise NotImplementedError\n\n    def _datasource(self, resource):\n        \"\"\" Returns a tuple with the actual name of the database\n        collection/table, base query and projection for the resource being\n        accessed.\n\n        :param resource: resource being accessed.\n\n        .. versionchanged:: 0.5\n           If allow_unknown is enabled for the resource, don't return any\n           projection for the document. Addresses #397 and #250.\n\n        .. versionchanged:: 0.4\n           Return copies to avoid accidental tampering. Fix #258.\n\n        .. versionchanged:: 0.2\n           Support for 'default_sort'.\n        \"\"\"\n        dsource = config.SOURCES[resource]\n\n        source = copy(dsource['source'])\n        filter_ = copy(dsource['filter'])\n        sort = copy(dsource['default_sort'])\n\n        # if allow_unknown is enabled for the resource, then don't return\n        # the default or client projection so all document fields can be\n        # returned to the client (regardless of the resource schema).\n        allow_unknown = config.DOMAIN[resource]['allow_unknown']\n        projection = copy(dsource['projection']) if not allow_unknown else None\n\n        return source, filter_, projection, sort,\n\n    def _datasource_ex(self, resource, query=None, client_projection=None,\n                       client_sort=None):\n        \"\"\" Returns both db collection and exact query (base filter included)\n        to which an API resource refers to.\n\n        .. versionchanged:: 0.4\n           Always return required/auto fields (issue 282.)\n\n        .. versionchanged:: 0.3\n           Field exclusion support in client projections.\n           Honor auth_field even when client query is missing.\n           Only inject auth_field in queries when we are not creating new\n           documents.\n           'auth_field' and 'request_auth_value' fetching is now delegated to\n           auth.auth_field_and value().\n\n        .. versionchanged:: 0.2\n           Difference between resource and item endpoints is now determined\n           by the presence of a '|' in request.endpoint.\n           Support for 'default_sort'.\n\n        .. versionchanged:: 0.1.1\n           auth.request_auth_value is now used to store the auth_field value.\n\n        .. versionchanged:: 0.1.0\n           Calls `combine_queries` to merge query and filter_\n           Updated logic performing `auth_field` check\n\n        .. versionchanged:: 0.0.9\n           Storing self.app.auth.userid in auth_field when 'user-restricted\n           resource access' is enabled.\n           Support for Python 3.3.\n\n        .. versionchanged:: 0.0.6\n           'auth_username_field' is injected even in empty queries.\n           Projection queries ('?projection={\"name\": 1}')\n\n        .. versionchanged:: 0.0.5\n           Support for 'user-restricted resource access'.\n\n        .. versionadded:: 0.0.4\n        \"\"\"\n\n        datasource, filter_, projection_, sort_ = self._datasource(resource)\n\n        if client_sort:\n            sort = client_sort\n        else:\n            # default sort is activated only if 'sorting' is enabled for the\n            # resource.\n            # TODO Consider raising a validation error on startup instead?\n            sort = sort_ if sort_ and config.DOMAIN[resource]['sorting'] else \\\n                None\n\n        if filter_:\n            if query:\n                # Can't just dump one set of query operators into another\n                # e.g. if the dataset contains a custom datasource pattern\n                #   'filter': {'username': {'$exists': True}}\n                # and we try to filter on the field `username`,\n                # which is correct?\n\n                # Solution: call the db driver `combine_queries` operation\n                # which will apply db-specific syntax to produce the\n                # intersection of the two queries\n                query = self.combine_queries(query, filter_)\n            else:\n                query = filter_\n\n        fields = projection_\n        if client_projection:\n            # only allow fields which are included with the standard projection\n            # for the resource (avoid sniffing of private fields)\n            keep_fields = auto_fields(resource)\n            if 0 not in client_projection.values():\n                # inclusive projection - all values are 0 unless spec. or auto\n                fields = dict([(field, field in keep_fields) for field in\n                               fields.keys()])\n            for field, value in client_projection.items():\n                field_base = field.split('.')[0]\n                if field_base not in keep_fields and field_base in fields:\n                    fields[field] = value\n            fields = dict([(field, 1) for field, value in fields.items() if\n                           value])\n\n        # If the current HTTP method is in `public_methods` or\n        # `public_item_methods`, skip the `auth_field` check\n\n        # Only inject the auth_field in the query when not creating new\n        # documents.\n        if request and request.method not in ('POST', 'PUT'):\n            auth_field, request_auth_value = auth_field_and_value(resource)\n            if auth_field and request.authorization and request_auth_value:\n                if query:\n                    # If the auth_field *replaces* a field in the query,\n                    # and the values are /different/, deny the request\n                    # This prevents the auth_field condition from\n                    # overwriting the query (issue #77)\n                    auth_field_in_query = \\\n                        self.app.data.query_contains_field(query, auth_field)\n                    if auth_field_in_query and \\\n                            self.app.data.get_value_from_query(\n                                query, auth_field) != request_auth_value:\n                        abort(401, description=debug_error_message(\n                            'Incompatible User-Restricted Resource request. '\n                            'Request was for \"%s\"=\"%s\" but `auth_field` '\n                            'requires \"%s\"=\"%s\".' % (\n                                auth_field,\n                                self.app.data.get_value_from_query(\n                                    query, auth_field),\n                                auth_field,\n                                request_auth_value)\n                        ))\n                    else:\n                        query = self.app.data.combine_queries(\n                            query, {auth_field: request_auth_value}\n                        )\n                else:\n                    query = {auth_field: request_auth_value}\n        return datasource, query, fields, sort\n```\n\n**Explanation:**\n\n- **BaseJSONEncoder:** A custom JSON encoder subclass used to handle serialization.\n- **ConnectionException:** Exception raised when the DataLayer can't establish a connection to the database.\n- **DataLayer:**",
    "after": "# -*- coding: utf-8 -*-\n\n\"\"\"\n    eve.io.base\n    ~~~~~~~~~~~\n\n    Standard interface implemented by Eve data layers.\n\n    :copyright: (c) 2014 by Nicola Iarocci.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport datetime\nimport simplejson as json\nfrom copy import copy\nfrom flask import request, abort\nfrom eve.utils import date_to_str\nfrom eve.auth import auth_field_and_value\nfrom eve.utils import config, debug_error_message, auto_fields\n\n\nclass BaseJSONEncoder(json.JSONEncoder):\n    \"\"\" Proprietary JSONEconder subclass used by the json render function.\n    This is needed to address the encoding of special values.\n    \"\"\"\n    def default(self, obj):\n        if isinstance(obj, datetime.datetime):\n            # convert any datetime to RFC 1123 format\n            return date_to_str(obj)\n        elif isinstance(obj, (datetime.time, datetime.date)):\n            # should not happen since the only supported date-like format\n            # supported at dmain schema level is 'datetime' .\n            return obj.isoformat()\n        return json.JSONEncoder.default(self, obj)\n\n\nclass ConnectionException(Exception):\n    \"\"\" Raised when DataLayer subclasses cannot find/activate to their\n    database connection.\n\n    :param driver_exception: the original exception raised by the source db\n                             driver\n    \"\"\"\n    def __init__(self, driver_exception=None):\n        self.driver_exception = driver_exception\n\n    def __str__(self):\n        msg = (\"Error initializing the driver. Make sure the database server\"\n               \"is running. \")\n        if self.driver_exception:\n            msg += \"Driver exception: %s\" % repr(self.driver_exception)\n        return msg\n\n\nclass DataLayer(object):\n    \"\"\" Base data layer class. Defines the interface that actual data-access\n    classes, being subclasses, must implement. Implemented as a Flask\n    extension.\n\n    Admittedly, this interface is a Mongo rip-off. See the io.mongo\n    package for an implementation example.\n\n    .. versionchanged:: 0.2\n       Allow subclasses to provide their own specialized json encoder.\n\n    .. versionchanged:: 0.1.1\n       'serializers' dictionary added.\n\n    .. versionchanged:: 0.1.0\n       Support for PUT method.\n\n    .. versionchanged:: 0.0.6\n       support for 'projections' has been added. For more information see\n       http://docs.mongodb.org/manual/reference/glossary/#term-projection.\n       While typically a MongoDB feature, other subclasses could decide to\n       provide support for their own projection syntax.\n\n    .. versionchanged:: 0.0.4\n       the _datasource helper function has been added.\n    \"\"\"\n\n    # if custom serialize functions are needed, add them to the 'serializers'\n    # dictionary, eg:\n    # serializers = {'objectid': ObjectId, 'datetime': serialize_date}\n    serializers = {}\n\n    # json.JSONEncoder subclass for serializing data to json.\n    # Subclasses should provide their own specialized encoder (see\n    # eve.io.mongo.MongoJSONEncoder).\n    json_encoder_class = BaseJSONEncoder\n\n    def __init__(self, app):\n        \"\"\" Implements the Flask extension pattern.\n\n        .. versionchanged:: 0.2\n           Explicit initialize self.driver to None.\n        \"\"\"\n        self.driver = None\n        if app is not None:\n            self.app = app\n            self.init_app(self.app)\n        else:\n            self.app = None\n\n    def init_app(self, app):\n        \"\"\" This is where you want to initialize the db driver so it will be\n        alive through the whole instance lifespan.\n        \"\"\"\n        raise NotImplementedError\n\n    def find(self, resource, req, sub_resource_lookup):\n        \"\"\" Retrieves a set of documents (rows), matching the current request.\n        Consumed when a request hits a collection/document endpoint\n        (`/people/`).\n\n        :param resource: resource being accessed. You should then use\n                         the ``_datasource`` helper function to retrieve both\n                         the db collection/table and base query (filter), if\n                         any.\n        :param req: an instance of ``eve.utils.ParsedRequest``. This contains\n                    all the constraints that must be fulfilled in order to\n                    satisfy the original request (where and sort parts, paging,\n                    etc). Be warned that `where` and `sort` expresions will\n                    need proper parsing, according to the syntax that you want\n                    to support with your driver. For example ``eve.io.Mongo``\n                    supports both Python and Mongo-like query syntaxes.\n        :param sub_resource_lookup: sub-resource lookup from the endpoint url.\n\n        .. versionchanged:: 0.3\n           Support for sub-resources.\n        \"\"\"\n        raise NotImplementedError\n\n    def find_one(self, resource, req, **lookup):\n        \"\"\" Retrieves a single document/record. Consumed when a request hits an\n        item endpoint (`/people/id/`).\n\n        :param resource: resource being accessed. You should then use the\n                         ``_datasource`` helper function to retrieve both the\n                         db collection/table and base query (filter), if any.\n        :param req: an instance of ``eve.utils.ParsedRequest``. This contains\n                    all the constraints that must be fulfilled in order to\n                    satisfy the original request (where and sort parts, paging,\n                    etc). As we are going to only look for one document here,\n                    the only req attribute that you want to process here is\n                    ``req.projection``.\n\n        :param **lookup: the lookup fields. This will most likely be a record\n                         id or, if alternate lookup is supported by the API,\n                         the corresponding query.\n\n\n        .. versionchanged:: 0.4\n           Added the 'req' argument.\n        \"\"\"\n        raise NotImplementedError\n\n    def find_one_raw(self, resource, _id):\n        \"\"\" Retrieves a single, raw document. No projections or datasource\n        filters are being applied here. Just looking up the document by unique\n        id.\n\n        :param resource: resource name.\n        :param id: unique id.\n\n        .. versionadded:: 0.4\n        \"\"\"\n        raise NotImplementedError\n\n    def find_list_of_ids(self, resource, ids, client_projection=None):\n        \"\"\" Retrieves a list of documents based on a list of primary keys\n        The primary key is the field defined in `ID_FIELD`.\n        This is a separate function to allow us to use per-database\n        optimizations for this type of query.\n\n        :param resource: resource name.\n        :param ids: a list of ids corresponding to the documents\n        to retrieve\n        :param client_projection: a specific projection to use\n        :return: a list of documents matching the ids in `ids` from the\n        collection specified in `resource`\n\n        .. versionadded:: 0.1.0\n        \"\"\"\n        raise NotImplementedError\n\n    def insert(self, resource, doc_or_docs):\n        \"\"\" Inserts a document into a resource collection/table.\n\n        :param resource: resource being accessed. You should then use\n                         the ``_datasource`` helper function to retrieve both\n                         the actual datasource name.\n        :param doc_or_docs: json document or list of json documents to be added\n                            to the database.\n\n        .. versionchanged:: 0.0.6\n            'document' param renamed to 'doc_or_docs', making support for bulk\n            inserts apparent.\n        \"\"\"\n        raise NotImplementedError\n\n    def update(self, resource, id_, updates):\n        \"\"\" Updates a collection/table document/row.\n        :param resource: resource being accessed. You should then use\n                         the ``_datasource`` helper function to retrieve\n                         the actual datasource name.\n        :param id_: the unique id of the document.\n        :param updates: json updates to be performed on the database document\n                        (or row).\n        \"\"\"\n        raise NotImplementedError\n\n    def replace(self, resource, id_, document):\n        \"\"\" Replaces a collection/table document/row.\n        :param resource: resource being accessed. You should then use\n                         the ``_datasource`` helper function to retrieve\n                         the actual datasource name.\n        :param id_: the unique id of the document.\n        :param document: the new json document\n\n        .. versionadded:: 0.1.0\n        \"\"\"\n        raise NotImplementedError\n\n    def remove(self, resource, lookup={}):\n        \"\"\" Removes a document/row or an entire set of documents/rows from a\n        database collection/table.\n\n        :param resource: resource being accessed. You should then use\n                         the ``_datasource`` helper function to retrieve\n                         the actual datasource name.\n        :param lookup: a dict with the query that documents must match in order\n                       to qualify for deletion. For single document deletes,\n                       this is usually the unique id of the document to be\n                       removed.\n\n        .. versionchanged:: 0.3\n           '_id' arg removed; replaced with 'lookup'.\n        \"\"\"\n        raise NotImplementedError\n\n    def combine_queries(self, query_a, query_b):\n        \"\"\" Takes two db queries and applies db-specific syntax to produce\n        the intersection.\n\n        .. versionadded: 0.1.0\n           Support for intelligent combination of db queries\n        \"\"\"\n        raise NotImplementedError\n\n    def get_value_from_query(self, query, field_name):\n        \"\"\" Parses the given potentially-complex query and returns the value\n        being assigned to the field given in `field_name`.\n\n        This mainly exists to deal with more complicated compound queries\n\n        .. versionadded: 0.1.0\n           Support for parsing values embedded in compound db queries\n        \"\"\"\n        raise NotImplementedError\n\n    def query_contains_field(self, query, field_name):\n        \"\"\" For the specified field name, does the query contain it?\n        Used know whether we need to parse a compound query.\n\n        .. versionadded: 0.1.0\n           Support for parsing values embedded in compound db queries\n        \"\"\"\n        raise NotImplementedError\n\n    def is_empty(self, resource):\n        \"\"\" Returns True if the collection is empty; False otherwise. While\n        a user could rely on self.find() method to achieve the same result,\n        this method can probably take advantage of specific datastore features\n        to provide better perfomance.\n\n        Don't forget, a 'resource' could have a pre-defined filter. If that is\n        the case, it will have to be taken into consideration when performing\n        the is_empty() check (see eve.io.mongo.mongo.py implementation).\n\n        :param resource: resource being accessed. You should then use\n                         the ``_datasource`` helper function to retrieve\n                         the actual datasource name.\n\n        .. versionadded: 0.3\n        \"\"\"\n        raise NotImplementedError\n\n    def _datasource(self, resource):\n        \"\"\" Returns a tuple with the actual name of the database\n        collection/table, base query and projection for the resource being\n        accessed.\n\n        :param resource: resource being accessed.\n\n        .. versionchanged:: 0.5\n           If allow_unknown is enabled for the resource, don't return any\n           projection for the document. Addresses #397 and #250.\n\n        .. versionchanged:: 0.4\n           Return copies to avoid accidental tampering. Fix #258.\n\n        .. versionchanged:: 0.2\n           Support for 'default_sort'.\n        \"\"\"\n        dsource = config.SOURCES[resource]\n\n        source = copy(dsource['source'])\n        filter_ = copy(dsource['filter'])\n        sort = copy(dsource['default_sort'])\n\n        # if allow_unknown is enabled for the resource, then don't return\n        # the default or client projection so all document fields can be\n        # returned to the client (regardless of the resource schema).\n        allow_unknown = config.DOMAIN[resource]['allow_unknown']\n        projection = copy(dsource['projection']) if not allow_unknown else None\n\n        return source, filter_, projection, sort,\n\n    def _datasource_ex(self, resource, query=None, client_projection=None,\n                       client_sort=None):\n        \"\"\" Returns both db collection and exact query (base filter included)\n        to which an API resource refers to.\n\n        .. versionchanged:: 0.4\n           Always return required/auto fields (issue 282.)\n\n        .. versionchanged:: 0.3\n           Field exclusion support in client projections.\n           Honor auth_field even when client query is missing.\n           Only inject auth_field in queries when we are not creating new\n           documents.\n           'auth_field' and 'request_auth_value' fetching is now delegated to\n           auth.auth_field_and value().\n\n        .. versionchanged:: 0.2\n           Difference between resource and item endpoints is now determined\n           by the presence of a '|' in request.endpoint.\n           Support for 'default_sort'.\n\n        .. versionchanged:: 0.1.1\n           auth.request_auth_value is now used to store the auth_field value.\n\n        .. versionchanged:: 0.1.0\n           Calls `combine_queries` to merge query and filter_\n           Updated logic performing `auth_field` check\n\n        .. versionchanged:: 0.0.9\n           Storing self.app.auth.userid in auth_field when 'user-restricted\n           resource access' is enabled.\n           Support for Python 3.3.\n\n        .. versionchanged:: 0.0.6\n           'auth_username_field' is injected even in empty queries.\n           Projection queries ('?projection={\"name\": 1}')\n\n        .. versionchanged:: 0.0.5\n           Support for 'user-restricted resource access'.\n\n        .. versionadded:: 0.0.4\n        \"\"\"\n\n        datasource, filter_, projection_, sort_ = self._datasource(resource)\n\n        if client_sort:\n            sort = client_sort\n        else:\n            # default sort is activated only if 'sorting' is enabled for the\n            # resource.\n            # TODO Consider raising a validation error on startup instead?\n            sort = sort_ if sort_ and config.DOMAIN[resource]['sorting'] else \\\n                None\n\n        if filter_:\n            if query:\n                # Can't just dump one set of query operators into another\n                # e.g. if the dataset contains a custom datasource pattern\n                #   'filter': {'username': {'$exists': True}}\n                # and we try to filter on the field `username`,\n                # which is correct?\n\n                # Solution: call the db driver `combine_queries` operation\n                # which will apply db-specific syntax to produce the\n                # intersection of the two queries\n                query = self.combine_queries(query, filter_)\n            else:\n                query = filter_\n\n        fields = projection_\n        if client_projection:\n            # only allow fields which are included with the standard projection\n            # for the resource (avoid sniffing of private fields)\n            keep_fields = auto_fields(resource)\n            if 0 not in client_projection.values():\n                # inclusive projection - all values are 0 unless spec. or auto\n                fields = dict([(field, field in keep_fields) for field in\n                               fields.keys()])\n            for field, value in client_projection.items():\n                field_base = field.split('.')[0]\n                if field_base not in keep_fields and field_base in fields:\n                    fields[field] = value\n            fields = dict([(field, 1) for field, value in fields.items() if\n                           value])\n\n        # If the current HTTP method is in `public_methods` or\n        # `public_item_methods`, skip the `auth_field` check\n\n        # Only inject the auth_field in the query when not creating new\n        # documents.\n        if request and request.method not in ('POST', 'PUT'):\n            auth_field, request_auth_value = auth_field_and_value(resource)\n            if auth_field and request.authorization and request_auth_value:\n                if query:\n                    # If the auth_field *replaces* a field in the query,\n                    # and the values are /different/, deny the request\n                    # This prevents the auth_field condition from\n                    # overwriting the query (issue #77)\n                    auth_field_in_query = \\\n                        self.app.data.query_contains_field(query, auth_field)\n                    if auth_field_in_query and \\\n                            self.app.data.get_value_from_query(\n                                query, auth_field) != request_auth_value:\n                        abort(401, description=debug_error_message(\n                            'Incompatible User-Restricted Resource request. '\n                            'Request was for \"%s\"=\"%s\" but `auth_field` '\n                            'requires \"%s\"=\"%s\".' % (\n                                auth_field,\n                                self.app.data.get_value_from_query(\n                                    query, auth_field),\n                                auth_field,\n                                request_auth_value)\n                        ))\n                    else:\n                        query = self.app.data.combine_queries(\n                            query, {auth_field: request_auth_value}\n                        )\n                else:\n                    query = {auth_field: request_auth_value}\n        return datasource, query, fields, sort\n    \n    def _prepare_data(self, data, resource):\n        \"\"\" This function handles data preparation and adds specific\n        data formatting.\n        \"\"\"\n        raise NotImplementedError\n\n    def _format_data(self, data"
  },
  "feature_stats": {
    "indices": [
      2,
      2457,
      2973,
      5116,
      3592,
      7627,
      2279,
      590,
      1612,
      311,
      8751
    ],
    "f_before": [
      0.0,
      0.24452459812164307,
      0.057569846510887146,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "f_after": [
      0.0,
      0.24452459812164307,
      0.057569846510887146,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "g_before": [
      0.03441312536597252,
      0.05388457700610161,
      0.0881442204117775,
      0.0,
      0.05671624466776848,
      0.007066335529088974,
      0.1250649094581604,
      0.060998838394880295,
      0.12132084369659424,
      0.04261282831430435,
      0.01221943274140358
    ],
    "g_after": [
      0.03441312536597252,
      0.05388457700610161,
      0.0881442204117775,
      0.0,
      0.05671624466776848,
      0.007066335529088974,
      0.1250649094581604,
      0.060998838394880295,
      0.12132084369659424,
      0.04261282831430435,
      0.01221943274140358
    ],
    "num_batches_for_stats": 10
  },
  "loss_summary": {
    "train_mean_loss": 6.500702248136203,
    "train_mean_l2": 4.52228784327209,
    "train_mean_l1": 1.9784144236048062,
    "num_steps": 3000,
    "num_batches": 3000
  },
  "feature_std_summary": {
    "plot_path": "outputs/plots/20251126-190647/feature_std_layer_12.html",
    "mean_std": 0.993312418460846,
    "max_std": 26.361066818237305
  }
}