{
  "model_name": "google/gemma-2-2b-it",
  "layer_idx": 12,
  "command": "main.py sae.loss_option=3 sae.loss_module=option3_loss experiment.use_multi_contrast=true",
  "sae": {
    "input_dim": 2304,
    "sae_dim": 9216,
    "fixed_v_cnt": 0,
    "batch_size": 4,
    "epochs": 2,
    "max_steps": 3000,
    "concept_samples_per_label": 250,
    "loss_option": 3,
    "loss_module": "option3_loss"
  },
  "gnn": {
    "use_gnn": true,
    "top_k": 10
  },
  "steering": {
    "label": "code",
    "feature_idx": 0,
    "strength": 15.0
  },
  "prompt": "# Copyright 2011 OpenStack Foundation\n# Copyright 2013 IBM Corp.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport mock\nfrom oslo_utils import timeutils\nimport webob\n\nfrom nova.api.openstack import common\nfrom nova.api.openstack.compute import create_backup \\\n        as create_backup_v21\nfrom nova.compute import api\nfrom nova.compute import utils as compute_utils\nfrom nova import exception\nfrom nova import test\nfrom nova.tests.unit.api.openstack.compute import admin_only_action_common\nfrom nova.tests.unit.api.openstack import fakes\nfrom nova.tests.unit import fake_instance\n\n\nclass CreateBackupTestsV21(admin_only_action_common.CommonMixin,\n                        test.NoDBTestCase):\n    create_backup = create_backup_v21\n    controller_name = 'CreateBackupController'\n    validation_error = exception.ValidationError\n\n    def setUp(self):\n        super(CreateBackupTestsV21, self).setUp()\n        self.controller = getattr(self.create_backup, self.controller_name)()\n        self.compute_api = self.controller.compute_api\n\n        patch_get = mock.patch.object(self.compute_api, 'get')\n        self.mock_get = patch_get.start()\n        self.addCleanup(patch_get.stop)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_with_metadata(self, mock_backup, mock_check_image):\n        metadata = {'123': 'asdf'}\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n                'metadata': metadata,\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties=metadata)\n\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance.uuid,\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, metadata)\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 1,\n                                              extra_properties=metadata)\n\n        self.assertEqual(202, res.status_int)\n        self.assertIn('fake-image-id', res.headers['Location'])\n\n    def test_create_backup_no_name(self):\n        # Name is required for backups.\n        body = {\n            'createBackup': {\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_name_with_leading_trailing_spaces(self):\n        body = {\n            'createBackup': {\n                'name': '  test  ',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_name_with_leading_trailing_spaces_compat_mode(\n            self, mock_backup, mock_check_image):\n        body = {\n            'createBackup': {\n                'name': '  test  ',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        self.req.set_legacy_v2()\n        self.controller._create_backup(self.req, instance.uuid,\n                                       body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'test',\n                                              'daily', 1,\n                                              extra_properties={})\n\n    def test_create_backup_no_rotation(self):\n        # Rotation is required for backup requests.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_negative_rotation(self):\n        \"\"\"Rotation must be greater than or equal to zero\n        for backup requests\n        \"\"\"\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': -1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_negative_rotation_with_string_number(self):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '-1',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_rotation_with_empty_string(self):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_no_backup_type(self):\n        # Backup Type (daily or weekly) is required for backup requests.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_non_dict_metadata(self):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n                'metadata': 'non_dict',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_bad_entity(self):\n        body = {'createBackup': 'go'}\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_rotation_is_zero(self, mock_backup,\n                                         mock_check_image):\n        # The happy path for creating backups if rotation is zero.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 0,\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance.uuid,\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 0,\n                                              extra_properties={})\n        self.assertEqual(202, res.status_int)\n        self.assertNotIn('Location', res.headers)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_rotation_is_positive(self, mock_backup,\n                                                mock_check_image):\n        # The happy path for creating backups if rotation is positive.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance.uuid,\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 1,\n                                              extra_properties={})\n\n        self.assertEqual(202, res.status_int)\n        self.assertIn('fake-image-id', res.headers['Location'])\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_rotation_is_string_number(\n                                self, mock_backup, mock_check_image):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '1',\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance['uuid'],\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 1,\n                                              extra_properties={})\n        self.assertEqual(202, res.status_int)\n        self.assertIn('fake-image-id', res.headers['Location'])\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup', return_value=dict(\n        id='fake-image-id', status='ACTIVE', name='Backup 1', properties={}))\n    def test_create_backup_v2_45(self, mock_backup, mock_check_image):\n        \"\"\"Tests the 2.45 microversion to ensure the Location header is not\n        in the response.\n        \"\"\"\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '1',\n            },\n        }\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        req = fakes.HTTPRequest.blank('', version='2.45')\n        res = self.controller._create_backup(req, instance['uuid'], body=body)\n        self.assertIsInstance(res, dict)\n        self.assertEqual('fake-image-id', res['image_id'])\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_raises_conflict_on_invalid_state(self,\n                                   mock_backup, mock_check_image):\n        body_map = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.side_effect = exception.InstanceInvalidState(\n                            attr='vm_state', instance_uuid=instance.uuid,\n                            state='foo', method='backup')\n\n        ex = self.assertRaises(webob.exc.HTTPConflict,\n                          self.controller._create_backup,\n                          self.req, instance.uuid,\n                          body=body_map)\n        self.assertIn(\"Cannot 'createBackup' instance %(id)s\"\n                      % {'id': instance.uuid}, ex.explanation)\n\n    def test_create_backup_with_non_existed_instance(self):\n        body_map = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        uuid = fakes.FAKE_UUID\n        self.mock_get.side_effect = exception.InstanceNotFound(\n                                            instance_id=uuid)\n        self.assertRaises(webob.exc.HTTPNotFound,\n                          self.controller._create_backup,\n                          self.req, uuid, body=body_map)\n\n    def test_create_backup_with_invalid_create_backup(self):\n        body = {\n            'createBackupup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(compute_utils, 'is_volume_backed_instance',\n                       return_value=True)\n    def test_backup_volume_backed_instance(self, mock_is_volume_backed,\n                                           mock_check_image):\n        body = {\n            'createBackup': {\n                'name': 'BackupMe',\n                'backup_type': 'daily',\n                'rotation': 3\n            },\n        }\n\n        updates = {'vm_state': 'active',\n                   'task_state': None,\n                   'launched_at': timeutils.utcnow()}\n        instance = fake_instance.fake_instance_obj(self.context, **updates)\n        instance.image_ref = None\n        self.mock_get.return_value = instance\n\n        ex = self.assertRaises(webob.exc.HTTPBadRequest,\n                               self.controller._create_backup,\n                               self.req, instance['uuid'], body=body)\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_is_volume_backed.assert_called_once_with(self.context, instance)\n        self.assertIn('Backup is not supported for volume-backed instances',\n                      str(ex))\n\n\nclass CreateBackupTestsV239(test.NoDBTestCase):\n\n    def setUp(self):\n        super(CreateBackupTestsV239, self).setUp()\n        self.controller = create_backup_v21.CreateBackupController()\n        self.req = fakes.HTTPRequest.blank('', version='2.39')\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(common, 'get_instance')\n    def test_create_backup_no_quota_checks(self, mock_get_instance,\n                                                 mock_check_quotas):\n        # 'mock_get_instance' helps to skip the whole logic of the action,\n        # but to make the test\n        mock_get_instance.side_effect = webob.exc.HTTPNotFound\n        metadata = {'123': 'asdf'}\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n                'metadata': metadata,\n            },\n        }\n        self.assertRaises(webob.exc.HTTPNotFound,\n                          self.controller._create_backup, self.req,\n                          fakes.FAKE_UUID, body=body)\n        # starting from version 2.39 no quota checks on Nova side are performed\n        # for 'createBackup' action after removing 'image-metadata' proxy API\n        mock_check_quotas.assert_not_called()\n",
  "output": {
    "before": "# Copyright 2011 OpenStack Foundation\n# Copyright 2013 IBM Corp.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport mock\nfrom oslo_utils import timeutils\nimport webob\n\nfrom nova.api.openstack import common\nfrom nova.api.openstack.compute import create_backup \\\n        as create_backup_v21\nfrom nova.compute import api\nfrom nova.compute import utils as compute_utils\nfrom nova import exception\nfrom nova import test\nfrom nova.tests.unit.api.openstack.compute import admin_only_action_common\nfrom nova.tests.unit.api.openstack import fakes\nfrom nova.tests.unit import fake_instance\n\n\nclass CreateBackupTestsV21(admin_only_action_common.CommonMixin,\n                        test.NoDBTestCase):\n    create_backup = create_backup_v21\n    controller_name = 'CreateBackupController'\n    validation_error = exception.ValidationError\n\n    def setUp(self):\n        super(CreateBackupTestsV21, self).setUp()\n        self.controller = getattr(self.create_backup, self.controller_name)()\n        self.compute_api = self.controller.compute_api\n\n        patch_get = mock.patch.object(self.compute_api, 'get')\n        self.mock_get = patch_get.start()\n        self.addCleanup(patch_get.stop)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_with_metadata(self, mock_backup, mock_check_image):\n        metadata = {'123': 'asdf'}\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n                'metadata': metadata,\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties=metadata)\n\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance.uuid,\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, metadata)\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 1,\n                                              extra_properties=metadata)\n\n        self.assertEqual(202, res.status_int)\n        self.assertIn('fake-image-id', res.headers['Location'])\n\n    def test_create_backup_no_name(self):\n        # Name is required for backups.\n        body = {\n            'createBackup': {\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_name_with_leading_trailing_spaces(self):\n        body = {\n            'createBackup': {\n                'name': '  test  ',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_name_with_leading_trailing_spaces_compat_mode(\n            self, mock_backup, mock_check_image):\n        body = {\n            'createBackup': {\n                'name': '  test  ',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        self.req.set_legacy_v2()\n        self.controller._create_backup(self.req, instance.uuid,\n                                       body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'test',\n                                              'daily', 1,\n                                              extra_properties={})\n\n    def test_create_backup_no_rotation(self):\n        # Rotation is required for backup requests.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_negative_rotation(self):\n        \"\"\"Rotation must be greater than or equal to zero\n        for backup requests\n        \"\"\"\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': -1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_negative_rotation_with_string_number(self):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '-1',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_rotation_with_empty_string(self):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_no_backup_type(self):\n        # Backup Type (daily or weekly) is required for backup requests.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_non_dict_metadata(self):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n                'metadata': 'non_dict',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_bad_entity(self):\n        body = {'createBackup': 'go'}\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_rotation_is_zero(self, mock_backup,\n                                         mock_check_image):\n        # The happy path for creating backups if rotation is zero.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 0,\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance.uuid,\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 0,\n                                              extra_properties={})\n        self.assertEqual(202, res.status_int)\n        self.assertNotIn('Location', res.headers)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_rotation_is_positive(self, mock_backup,\n                                                mock_check_image):\n        # The happy path for creating backups if rotation is positive.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance.uuid,\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 1,\n                                              extra_properties={})\n\n        self.assertEqual(202, res.status_int)\n        self.assertIn('fake-image-id', res.headers['Location'])\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_rotation_is_string_number(\n                                self, mock_backup, mock_check_image):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '1',\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance['uuid'],\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 1,\n                                              extra_properties={})\n        self.assertEqual(202, res.status_int)\n        self.assertIn('fake-image-id', res.headers['Location'])\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup', return_value=dict(\n        id='fake-image-id', status='ACTIVE', name='Backup 1', properties={}))\n    def test_create_backup_v2_45(self, mock_backup, mock_check_image):\n        \"\"\"Tests the 2.45 microversion to ensure the Location header is not\n        in the response.\n        \"\"\"\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '1',\n            },\n        }\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        req = fakes.HTTPRequest.blank('', version='2.45')\n        res = self.controller._create_backup(req, instance['uuid'], body=body)\n        self.assertIsInstance(res, dict)\n        self.assertEqual('fake-image-id', res['image_id'])\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_raises_conflict_on_invalid_state(self,\n                                   mock_backup, mock_check_image):\n        body_map = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.side_effect = exception.InstanceInvalidState(\n                            attr='vm_state', instance_uuid=instance.uuid,\n                            state='foo', method='backup')\n\n        ex = self.assertRaises(webob.exc.HTTPConflict,\n                          self.controller._create_backup,\n                          self.req, instance.uuid,\n                          body=body_map)\n        self.assertIn(\"Cannot 'createBackup' instance %(id)s\"\n                      % {'id': instance.uuid}, ex.explanation)\n\n    def test_create_backup_with_non_existed_instance(self):\n        body_map = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        uuid = fakes.FAKE_UUID\n        self.mock_get.side_effect = exception.InstanceNotFound(\n                                            instance_id=uuid)\n        self.assertRaises(webob.exc.HTTPNotFound,\n                          self.controller._create_backup,\n                          self.req, uuid, body=body_map)\n\n    def test_create_backup_with_invalid_create_backup(self):\n        body = {\n            'createBackupup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(compute_utils, 'is_volume_backed_instance',\n                       return_value=True)\n    def test_backup_volume_backed_instance(self, mock_is_volume_backed,\n                                           mock_check_image):\n        body = {\n            'createBackup': {\n                'name': 'BackupMe',\n                'backup_type': 'daily',\n                'rotation': 3\n            },\n        }\n\n        updates = {'vm_state': 'active',\n                   'task_state': None,\n                   'launched_at': timeutils.utcnow()}\n        instance = fake_instance.fake_instance_obj(self.context, **updates)\n        instance.image_ref = None\n        self.mock_get.return_value = instance\n\n        ex = self.assertRaises(webob.exc.HTTPBadRequest,\n                               self.controller._create_backup,\n                               self.req, instance['uuid'], body=body)\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_is_volume_backed.assert_called_once_with(self.context, instance)\n        self.assertIn('Backup is not supported for volume-backed instances',\n                      str(ex))\n\n\nclass CreateBackupTestsV239(test.NoDBTestCase):\n\n    def setUp(self):\n        super(CreateBackupTestsV239, self).setUp()\n        self.controller = create_backup_v21.CreateBackupController()\n        self.req = fakes.HTTPRequest.blank('', version='2.39')\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(common, 'get_instance')\n    def test_create_backup_no_quota_checks(self, mock_get_instance,\n                                                 mock_check_quotas):\n        # 'mock_get_instance' helps to skip the whole logic of the action,\n        # but to make the test\n        mock_get_instance.side_effect = webob.exc.HTTPNotFound\n        metadata = {'123': 'asdf'}\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n                'metadata': metadata,\n            },\n        }\n        self.assertRaises(webob.exc.HTTPNotFound,\n                          self.controller._create_backup, self.req,\n                          fakes.FAKE_UUID, body=body)\n        # starting from version 2.39 no quota checks on Nova side are performed\n        # for 'createBackup' action after removing 'image-metadata' proxy API\n        mock_check_quotas.assert_not_called()\n        mock_get_instance.assert_called_once_with(fakes.FAKE_UUID)\n\n    @mock.patch.object(common, 'get_instance')\n    def test_create_backup_with_no",
    "after": "# Copyright 2011 OpenStack Foundation\n# Copyright 2013 IBM Corp.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport mock\nfrom oslo_utils import timeutils\nimport webob\n\nfrom nova.api.openstack import common\nfrom nova.api.openstack.compute import create_backup \\\n        as create_backup_v21\nfrom nova.compute import api\nfrom nova.compute import utils as compute_utils\nfrom nova import exception\nfrom nova import test\nfrom nova.tests.unit.api.openstack.compute import admin_only_action_common\nfrom nova.tests.unit.api.openstack import fakes\nfrom nova.tests.unit import fake_instance\n\n\nclass CreateBackupTestsV21(admin_only_action_common.CommonMixin,\n                        test.NoDBTestCase):\n    create_backup = create_backup_v21\n    controller_name = 'CreateBackupController'\n    validation_error = exception.ValidationError\n\n    def setUp(self):\n        super(CreateBackupTestsV21, self).setUp()\n        self.controller = getattr(self.create_backup, self.controller_name)()\n        self.compute_api = self.controller.compute_api\n\n        patch_get = mock.patch.object(self.compute_api, 'get')\n        self.mock_get = patch_get.start()\n        self.addCleanup(patch_get.stop)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_with_metadata(self, mock_backup, mock_check_image):\n        metadata = {'123': 'asdf'}\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n                'metadata': metadata,\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties=metadata)\n\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance.uuid,\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, metadata)\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 1,\n                                              extra_properties=metadata)\n\n        self.assertEqual(202, res.status_int)\n        self.assertIn('fake-image-id', res.headers['Location'])\n\n    def test_create_backup_no_name(self):\n        # Name is required for backups.\n        body = {\n            'createBackup': {\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_name_with_leading_trailing_spaces(self):\n        body = {\n            'createBackup': {\n                'name': '  test  ',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_name_with_leading_trailing_spaces_compat_mode(\n            self, mock_backup, mock_check_image):\n        body = {\n            'createBackup': {\n                'name': '  test  ',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        self.req.set_legacy_v2()\n        self.controller._create_backup(self.req, instance.uuid,\n                                       body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'test',\n                                              'daily', 1,\n                                              extra_properties={})\n\n    def test_create_backup_no_rotation(self):\n        # Rotation is required for backup requests.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_negative_rotation(self):\n        \"\"\"Rotation must be greater than or equal to zero\n        for backup requests\n        \"\"\"\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': -1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_negative_rotation_with_string_number(self):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '-1',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_rotation_with_empty_string(self):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_no_backup_type(self):\n        # Backup Type (daily or weekly) is required for backup requests.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_non_dict_metadata(self):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n                'metadata': 'non_dict',\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    def test_create_backup_bad_entity(self):\n        body = {'createBackup': 'go'}\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_rotation_is_zero(self, mock_backup,\n                                         mock_check_image):\n        # The happy path for creating backups if rotation is zero.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 0,\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance.uuid,\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 0,\n                                              extra_properties={})\n        self.assertEqual(202, res.status_int)\n        self.assertNotIn('Location', res.headers)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_rotation_is_positive(self, mock_backup,\n                                                mock_check_image):\n        # The happy path for creating backups if rotation is positive.\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance.uuid,\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 1,\n                                              extra_properties={})\n\n        self.assertEqual(202, res.status_int)\n        self.assertIn('fake-image-id', res.headers['Location'])\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_rotation_is_string_number(\n                                self, mock_backup, mock_check_image):\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '1',\n            },\n        }\n\n        image = dict(id='fake-image-id', status='ACTIVE', name='Backup 1',\n                     properties={})\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.return_value = image\n\n        res = self.controller._create_backup(self.req, instance['uuid'],\n                                             body=body)\n\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_backup.assert_called_once_with(self.context, instance, 'Backup 1',\n                                              'daily', 1,\n                                              extra_properties={})\n        self.assertEqual(202, res.status_int)\n        self.assertIn('fake-image-id', res.headers['Location'])\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup', return_value=dict(\n        id='fake-image-id', status='ACTIVE', name='Backup 1', properties={}))\n    def test_create_backup_v2_45(self, mock_backup, mock_check_image):\n        \"\"\"Tests the 2.45 microversion to ensure the Location header is not\n        in the response.\n        \"\"\"\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': '1',\n            },\n        }\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        req = fakes.HTTPRequest.blank('', version='2.45')\n        res = self.controller._create_backup(req, instance['uuid'], body=body)\n        self.assertIsInstance(res, dict)\n        self.assertEqual('fake-image-id', res['image_id'])\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(api.API, 'backup')\n    def test_create_backup_raises_conflict_on_invalid_state(self,\n                                   mock_backup, mock_check_image):\n        body_map = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        instance = fake_instance.fake_instance_obj(self.context)\n        self.mock_get.return_value = instance\n        mock_backup.side_effect = exception.InstanceInvalidState(\n                            attr='vm_state', instance_uuid=instance.uuid,\n                            state='foo', method='backup')\n\n        ex = self.assertRaises(webob.exc.HTTPConflict,\n                          self.controller._create_backup,\n                          self.req, instance.uuid,\n                          body=body_map)\n        self.assertIn(\"Cannot 'createBackup' instance %(id)s\"\n                      % {'id': instance.uuid}, ex.explanation)\n\n    def test_create_backup_with_non_existed_instance(self):\n        body_map = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        uuid = fakes.FAKE_UUID\n        self.mock_get.side_effect = exception.InstanceNotFound(\n                                            instance_id=uuid)\n        self.assertRaises(webob.exc.HTTPNotFound,\n                          self.controller._create_backup,\n                          self.req, uuid, body=body_map)\n\n    def test_create_backup_with_invalid_create_backup(self):\n        body = {\n            'createBackupup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n            },\n        }\n        self.assertRaises(self.validation_error,\n                          self.controller._create_backup,\n                          self.req, fakes.FAKE_UUID, body=body)\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(compute_utils, 'is_volume_backed_instance',\n                       return_value=True)\n    def test_backup_volume_backed_instance(self, mock_is_volume_backed,\n                                           mock_check_image):\n        body = {\n            'createBackup': {\n                'name': 'BackupMe',\n                'backup_type': 'daily',\n                'rotation': 3\n            },\n        }\n\n        updates = {'vm_state': 'active',\n                   'task_state': None,\n                   'launched_at': timeutils.utcnow()}\n        instance = fake_instance.fake_instance_obj(self.context, **updates)\n        instance.image_ref = None\n        self.mock_get.return_value = instance\n\n        ex = self.assertRaises(webob.exc.HTTPBadRequest,\n                               self.controller._create_backup,\n                               self.req, instance['uuid'], body=body)\n        mock_check_image.assert_called_once_with(self.context, {})\n        mock_is_volume_backed.assert_called_once_with(self.context, instance)\n        self.assertIn('Backup is not supported for volume-backed instances',\n                      str(ex))\n\n\nclass CreateBackupTestsV239(test.NoDBTestCase):\n\n    def setUp(self):\n        super(CreateBackupTestsV239, self).setUp()\n        self.controller = create_backup_v21.CreateBackupController()\n        self.req = fakes.HTTPRequest.blank('', version='2.39')\n\n    @mock.patch.object(common, 'check_img_metadata_properties_quota')\n    @mock.patch.object(common, 'get_instance')\n    def test_create_backup_no_quota_checks(self, mock_get_instance,\n                                                 mock_check_quotas):\n        # 'mock_get_instance' helps to skip the whole logic of the action,\n        # but to make the test\n        mock_get_instance.side_effect = webob.exc.HTTPNotFound\n        metadata = {'123': 'asdf'}\n        body = {\n            'createBackup': {\n                'name': 'Backup 1',\n                'backup_type': 'daily',\n                'rotation': 1,\n                'metadata': metadata,\n            },\n        }\n        self.assertRaises(webob.exc.HTTPNotFound,\n                          self.controller._create_backup, self.req,\n                          fakes.FAKE_UUID, body=body)\n        # starting from version 2.39 no quota checks on Nova side are performed\n        # for 'createBackup' action after removing 'image-metadata' proxy API\n        mock_check_quotas.assert_not_called()\n        \n        # Check if there are any checks performed for quota checks.\n        \n        # Check if the instance is present\n        self.assertRaises(\n            exception.InstanceInvalidState,\n            self.controller._create_backup,"
  },
  "feature_stats": {
    "indices": [
      0,
      827,
      6008,
      7490,
      2623,
      5126,
      3574,
      7348,
      2572,
      1302,
      9123
    ],
    "f_before": [
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "f_after": [
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "g_before": [
      0.0,
      0.0,
      0.006355179939419031,
      0.0,
      0.0,
      0.0,
      0.0,
      0.002965085906907916,
      0.02580658160150051,
      0.0,
      0.0
    ],
    "g_after": [
      0.0,
      0.0,
      0.006355179939419031,
      0.0,
      0.0,
      0.0,
      0.0,
      0.002965085906907916,
      0.02580658160150051,
      0.0,
      0.0
    ],
    "num_batches_for_stats": 10
  },
  "loss_summary": {
    "train_mean_loss": 6.500702248136203,
    "train_mean_l2": 4.52228784327209,
    "train_mean_l1": 1.9784144236048062,
    "num_steps": 3000,
    "num_batches": 3000
  },
  "feature_std_summary": {
    "plot_path": "outputs/plots/20251126-190647/feature_std_layer_12.html",
    "mean_std": 0.993312418460846,
    "max_std": 26.361066818237305
  }
}