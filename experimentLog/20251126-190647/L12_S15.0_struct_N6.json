{
  "model_name": "google/gemma-2-2b-it",
  "layer_idx": 12,
  "command": "main.py sae.loss_option=3 sae.loss_module=option3_loss experiment.use_multi_contrast=true",
  "sae": {
    "input_dim": 2304,
    "sae_dim": 9216,
    "fixed_v_cnt": 0,
    "batch_size": 4,
    "epochs": 2,
    "max_steps": 3000,
    "concept_samples_per_label": 250,
    "loss_option": 3,
    "loss_module": "option3_loss"
  },
  "gnn": {
    "use_gnn": true,
    "top_k": 10
  },
  "steering": {
    "label": "struct",
    "feature_idx": 2,
    "strength": 15.0
  },
  "prompt": "import asyncio\nfrom datetime import datetime, timezone\nfrom functools import wraps\nimport traceback\nimport inspect\nimport logging\n\nimport ujson as json_module\nimport hashlib\nimport yaml\nfrom aiohttp import web\nimport aiohttp\nimport mongoengine\nimport os\n\nfrom .engine.objects import Operation, Network, Domain, Log, ObservedHost, TechniqueMapping, Job, Rat, Host, \\\n    ObservedRat, Adversary, CodedStep, ActiveConnection, Agent, AttackTechnique, AttackTactic, SiteUser, Setting, \\\n    Opcodes, Artifactlist, ObservedFile, AttackList, JobException, ObservedSchtask, ObservedProcess, AttackGroup\nfrom .engine.objects import ObservedDomain, ObservedOSVersion, ObservedUser, ObservedShare, ObservedCredential, \\\n    ObservedService, ObservedTimeDelta, ObservedRegKey, ObservedPersistence\nfrom . import authentication as auth\nfrom .engine.database import native_types\nfrom . import ddp\nfrom . import attack\nfrom . import util\nfrom . import interface\nfrom . import extern\n\n\nlog = logging.getLogger(__name__)\n\nroutes = []\n\n\ndef api(uri, methods, objects=None, get=None, auth_group=None, headers=None):\n    \"\"\"This is a decorator for web api endpoints\n\n    Args:\n        uri: The URI for the API, can contain keywords denoted by '{}' which indicate\n        objects: a list of tuples\n        methods: the list of HTTP methods this API accepts\n        auth_group: the group that the token must be in for access to this API\n        headers: A list of headers to return with the Response\n    \"\"\"\n    if objects is None:\n        objects = {}\n    if get is None:\n        get = {}\n    if auth_group is None:\n        auth_group = []\n    if headers is None:\n        headers = {}\n\n    def decorator(f):\n        @wraps(f)\n        async def decorated(req, token, url_match):\n            kwargs = {}\n            # Map id to object\n            for name, _class in objects.items():\n                if name in url_match:\n                    # If this fails and the request type is 'GET',\n                    # then an exception should be returned\n                    try:\n                        kwargs[name] = _class.objects.with_id(url_match[name])\n                        if kwargs[name] is None:\n                            return web.HTTPBadRequest()\n                    except (mongoengine.errors.ValidationError, ):\n                        # The client has sent an invalid id in the URL\n                        return web.HTTPBadRequest()\n\n            # Now set the default get parameters\n            # For cases where we see args like ?arg1=value1&arg2&...\n            # arg2 is set to ''\n            # but change it to True instead\n            trueified = {k: True if v == '' else v for k, v in req.GET.items()}\n\n            for k, v in get.items():\n                kwargs[k] = trueified.get(k, v)\n\n            sig = inspect.signature(f)\n\n            if 'token' in sig.parameters:\n                kwargs['token'] = token\n\n            # Finally format the output as json (or jsonfm)\n            results = await f(req, **kwargs)\n            if isinstance(results, web.StreamResponse):\n                return results\n            else:\n                json = json_module.dumps(native_types(results), sort_keys=True, indent=4)\n                return web.Response(text=json, content_type='application/json', headers=headers)\n\n        async def entrypoint(req):\n            host = None\n            try:\n                # ensure this member is authorized\n                token = auth.Token(req.cookies.get('AUTH'))\n                l = [g for g in auth_group if token.in_group(g)]\n                if len(l) == 0:\n                    raise auth.NotAuthorized()\n\n                # active connections\n                peername = req.transport.get_extra_info('peername')\n                if peername is not None:\n                    host_ip, port = peername\n                    if req.host:\n                        local_ip = req.host.split(\":\")[0]\n                        if local_ip == \"localhost\":\n                            local_ip = \"127.0.0.1\"\n                    else:\n                        local_ip = \"127.0.0.1\"\n                    token_host = None\n                    if token.in_group('agent'):\n                        agent = Agent.objects.with_id(token.session_info['_id'])\n                        if agent is None:\n                            raise auth.NotAuthorized\n                        agent.modify(**{'alive': True})\n                        token_host = agent.host\n                    host = ActiveConnection.objects(ip=host_ip, host=token_host, local_ip=local_ip).first()\n                    if host is None:\n                        host = ActiveConnection(ip=host_ip, host=token_host, local_ip=local_ip, connections=0).save()\n                    host.update(inc__connections=1)\n\n                resp = await decorated(req, token, req.match_info)\n                return resp\n            except auth.NotAuthorized:\n                return web.HTTPForbidden()\n            except Exception:\n                traceback.print_exc()\n                results = {'error': 'exception in ' + f.__name__}\n                output = json_module.dumps(results, sort_keys=True, indent=4)\n                return web.HTTPInternalServerError(text=output, content_type='application/json')\n            finally:\n                if host:\n                    host.update(dec__connections=1)\n\n        for method in methods:\n            routes.append((method, uri, entrypoint))\n        return decorated\n    return decorator\n\n\ndef websocket(uri, auth_group=None):\n    if auth_group is None:\n        auth_group = []\n\n    def decorator(f):\n        @wraps(f)\n        async def entrypoint(req):\n            try:\n                # ensure this member is authorized\n                token = auth.Token(req.cookies.get('AUTH'))\n                l = [g for g in auth_group if token.in_group(g)]\n                if len(l) == 0:\n                    raise auth.NotAuthorized()\n                return await f(req)\n            except auth.NotAuthorized:\n                return web.HTTPForbidden()\n            except Exception:\n                traceback.print_exc()\n                results = {'error': 'exception in ' + f.__name__}\n                output = json_module.dumps(results, sort_keys=True, indent=4)\n                return web.HTTPInternalServerError(text=output, content_type='application/json')\n\n        routes.append(('GET', uri, entrypoint))\n        return entrypoint\n    return decorator\n\n\n# Example usage:\n# GET  /api/jobs\n# POST /api/jobs     { 'action': 'install_service', 'host': 'mm198673-pc', ... }\n@api('/api/jobs', methods=['GET', 'POST'], get={'status': None, 'wait': False}, auth_group=['human', 'agent'])\nasync def query_jobs(request, token, status, wait):\n    if request.method == 'GET':\n        query = {}\n        if status:\n            query['status'] = status\n\n        if token.in_group('agent'):\n            agent = Agent.objects.with_id(token.session_info['_id'])\n            if not agent:\n                raise auth.NotAuthorized()\n            # are there any jobs for this agent?\n            query.update({'agent': agent.id})\n            jobs = list(Job.objects(**query))\n            if not len(jobs) and wait is not False:\n                # Now wait for jobs to be created\n                try:\n                    jobs = [(await Job.wait_next(query))]\n                except asyncio.CancelledError:\n                    return\n\n        else:\n            jobs = list(Job.objects(**query))\n            if not len(jobs) and wait is not False:\n                jobs = [(await Job.wait_next(query))]\n\n        return jobs\n    elif request.method == 'POST':\n        # only humans are allowed to create new jobs\n        token.require_group('human')\n        json = await request.json()\n        return Job(**json).save().id\n\n\n# Example usage:\n# GET  /api/jobs/<job>\n# POST /api/jobs/<job>     { 'action': 'install_service', 'host': 'mm198673-pc', ... }\n@api('/api/jobs/{job}', methods=['GET', 'PUT', 'DELETE'], objects={'job': Job}, auth_group=['human', 'agent'])\nasync def query_job(request, token, job):\n    if request.method == 'GET':\n        if token.in_group('agent'):\n            # can only get jobs that are not completed and are for them\n            if job['status'] in (\"created\", \"pending\") and str(job.agent.id) == token.session_info['_id']:\n                return job\n            else:\n                raise auth.NotAuthorized()\n        else:\n            return job\n    elif request.method == 'PUT':\n        if token.in_group('agent'):\n            # can only put jobs that are not completed and are for them\n            if job.status in (\"created\", \"pending\") and str(job.agent.id) == token.session_info['_id']:\n                json = await request.json()\n                # whitelist legal fields\n                if 'result' in json['action']:\n                    job['action']['result'] = json['action']['result']\n                if 'error' in json['action']:\n                    job['action']['error'] = json['action']['error']\n                if 'exception' in json['action']:\n                    job['action']['exception'] = json['action']['exception']\n                job['status'] = json.get('status', job.status)\n\n                if job['status'] == \"failed\" and 'error' in job['action'] and job['action']['error'] == \"no client\":\n                    # Force update the clients list\n                    interface.get_clients(job.agent.host)\n                    # find the rat\n                    try:\n                        iv_name = job['action'][\"rats\"][\"args\"][0]\n                        iv = Rat.objects(agent=job.agent, name=iv_name)\n                        iv.modify(**{'active': False})\n                    except KeyError:\n                        log.warning(\"Could not find rat to remove for failed job\")\n                return job.save()\n            else:\n                raise auth.NotAuthorized()\n\n        else:  # human\n            # Update the job\n            json = await request.json()\n            if json['create_time']:\n                json['create_time'] = datetime.strptime(json['create_time'], \"%Y-%m-%dT%H:%M:%S.%f\")\n            return job.save()\n\n    elif request.method == 'DELETE':\n        token.require_group('human')\n        return job.delete()\n\n\n# Example usage:\n# POST /api/clients\n@api('/api/clients', methods=['POST'], auth_group=['agent'])\nasync def query_clients(request, token):\n    json = await request.json()\n    # pid, elevated, executable_path\n    agen = Agent.objects.with_id(token.session_info['_id'])\n\n    # Get the list of known rats\n    complete_names = {iv.name: iv for iv in Rat.objects(host=agen.host)}\n    # Filter list for living rats\n    known_names = {}\n    for name, element in complete_names.items():\n        if element.active:\n            known_names[name] = element\n    # All of the currently running rats, as returned by the job\n    active = {x['pid']: x for x in json}\n\n    # Enumerate the active rats, and delete dead ones\n    for name, iv in known_names.items():\n        if name not in active:\n            iv.modify(**{'active': False})\n        else:\n            a = active.pop(name)\n            iv.update(**{'elevated': a['elevated'],\n                         'executable': a['executable_path']})\n\n    # Any new rats need to be added\n    for name in active:\n        Rat(**{'agent': agen,\n                     'host': agen.host,\n                     'name': name,\n                     'elevated': active[name]['elevated'],\n                     'executable': active[name]['executable_path'],\n                     'username': active[name]['username'].lower(),\n                     'active': True}).save()\n    return None\n\n\n# Example usage:\n# GET  /api/networks\n# POST /api/networks     { domain: 'mitre.org' }\n@api('/api/networks', methods=['GET', 'POST'], auth_group=['human'])\nasync def query_networks(request):\n    if request.method == 'GET':\n        return Network.objects\n    elif request.method == 'POST':\n        json = await request.json()\n        network = Network(**json).save()\n        return network.id\n\n\n@api('/api/networks/{network}', methods=['GET', 'DELETE'], objects={'network': Network}, auth_group=['human'])\nasync def query_network(request, network):\n    if request.method == 'GET':\n        return network\n    elif request.method == 'DELETE':\n        network.delete()\n\n\n@api('/api/heartbeat', methods=['GET'], auth_group=['agent'])\nasync def agent_check_in(request, token):\n    agen = Agent.objects.with_id(token.session_info['_id'])\n    agen.modify(**{'check_in': datetime.now(timezone.utc), 'alive': True})\n    return True\n\n\n@api('/api/hosts', methods=['GET'], auth_group=['human'])\nasync def query_hosts(request):\n    return Host.objects\n\n\n@api('/api/domains', methods=['GET'], auth_group=['human'])\nasync def query_domains(request):\n    return Domain.objects\n\n\n@api('/api/domains/{domain}', methods=['GET'], objects={'domain': Domain}, auth_group=['human'])\nasync def query_domain(request, domain):\n    return domain\n\n\n@api('/api/domains/{domain}/hosts', methods=['GET'], objects={'domain': Domain}, auth_group=['human'])\nasync def query_domainhosts(request, domain):\n    return Host.objects(domain=domain)\n\n\n@api('/api/networks/{network}/hosts', methods=['GET'], objects={'network': Network}, auth_group=['human'])\nasync def query_networkhosts(request, network):\n    return network.hosts\n\n\n@api('/api/networks/{network}/hosts/{host}', methods=['GET', 'PUT', 'DELETE'],\n     objects={'network': Network, 'host': Host}, auth_group=['human'])\nasync def query_networkhosthosts(request, network, host):\n    if request.method == 'GET':\n        return host\n    elif request.method == 'PUT':\n        network.modify(push__hosts=host)\n    elif request.method == 'DELETE':\n        network.modify(pull__hosts=host)\n\n\n@api('/api/hosts/{host}/commands', methods=['GET', 'POST'], objects={'host': Host}, auth_group=['human'])\nasync def query_commands(request, host):\n    if request.method == 'GET':\n        if 'hostname' in request.GET:\n            hosts = Host.objects(hostname=request.GET['hostname'])\n            return [x.host_command_result() for x in Job.objects(host__in=hosts)]\n        else:\n            return [x.host_command_result() for x in Job.objects(host=host)]\n    elif request.method == 'POST':\n        json = await request.json()\n        return interface.agent_shell_command(host, json['command_line']).id\n\n\n@api('/api/hosts/{host}/commands/{job}', methods=['GET'], get={'wait': False},\n     objects={'host': Host, 'job': Job}, auth_group=['human'])\nasync def query_command(request, wait, host, job):\n    # start waiting for the job before reloading to avoid missing the update\n    if wait is not False:\n        try:\n            await job.wait_till_completed()\n        except JobException as e:\n            log.warning(e.args)\n\n    return job.host_command_result()\n\n\n@api('/api/rats', methods=['GET'], auth_group=['human'])\nasync def query_ivs(request):\n    query = {k: v for k, v in request.GET.items() if k == 'hostname'}\n    return Rat.objects(**query)\n\n\n@api('/api/rats/{rat}', methods=['GET'], objects={'rat': Rat}, auth_group=['human'])\nasync def query_iv(rat):\n    return rat\n\n\n@api('/api/rats/{rat}/commands', methods=['GET', 'POST'],\n     objects={'rat': Rat}, auth_group=['human'])\nasync def query_ivcommands(request, rat):\n    if request.method == 'GET':\n        return [x.rat_command_result() for x in Job.objects(agent=rat.agent)]\n    elif request.method == 'POST':\n        json = await request.json()\n        return Job.create_rat_command(rat, json[\"function\"], **json[\"parameters\"]).id\n\n\n@api('/api/rats/{rat}/commands/{job}', methods=['GET'],\n     get={'wait': False}, objects={'rat': Rat, 'job': Job}, auth_group=['human'])\nasync def query_ivcommand(request, wait, rat, job):\n    # start waiting for the job before reloading to avoid missing the update\n    if wait is not False:\n        try:\n            await job.wait_till_completed()\n        except JobException as e:\n            log.warning(e.args)\n    return job.rat_result()\n\n\n@api('/api/operations', methods=['GET'], auth_group=['human'])\nasync def query_operations(request):\n    return Operation.objects\n\n\n@api('/api/opcodes', methods=['GET'], auth_group=['human'])\nasync def get_opcodes(request):\n    return Opcodes.arguments\n\n@api('/api/networks/{network}/operations', methods=['GET', 'POST'], objects={'network': Network}, auth_group=['human'])\nasync def query_perations(request, network):\n    if request.method == 'GET':\n        return list(Operation.objects(network=network))\n    elif request.method == 'POST':\n        json = await request.json()\n        if json['start_type'] == 'existing' and 'start_rat' not in json:\n            return None\n        json['network'] = network\n        json['status'] = 'start'\n        json['status_state'] = ''\n        json['log'] = Log().save()\n        # Get the adversary\n        adversary = Adversary.objects.with_id(json['adversary'])\n        json['steps'] = [x.name for x in adversary.steps]\n        operation = Operation(**json).save()\n        return operation.id\n\n@api('/api/networks/{network}/operations/{operation}', methods=['GET', 'PUT', 'DELETE', 'PATCH'], get={'wait': False},\n     objects={'network': Network, 'operation': Operation}, auth_group=['human'])\nasync def query_operation(request, network, operation, wait):\n    if request.method == 'GET':\n        if wait:\n            wait = json_module.loads(wait)\n            wait[\"id\"] = operation.id\n            log.info(\"Wait: {}\".format(wait))\n            # TODO fix race condition here\n            new = list(Operation.objects(**wait))\n            if len(new) == 0:\n                del wait[\"id\"]\n                new = [await operation.wait(wait)]\n            return new[0]\n        return operation\n    elif request.method == 'PUT':\n        json = await request.json()\n        json['network_id'] = network.id\n        json['hosts'] = network.hosts\n        return operation.update(**json)\n    elif request.method == 'DELETE':\n        return operation.delete()\n    elif request.method == 'PATCH':\n        json = await request.json()\n        operation.update(__raw__={'$set': json})\n\n\n@api('/api/agents', methods=['GET'], auth_group=['human'])\nasync def query_agents(request):\n    return Agent.objects\n\n\n@api('/api/logs', methods=['GET'], auth_group=['human'])\nasync def query_logs(request):\n    return Log.objects\n\n\n@api('/api/logs/{log}', methods=['GET'], objects={'log': Log}, auth_group=['human'])\nasync def query_log(request, log):\n    return log\n\n\n@api('/api/agents/{agent}', methods=['GET'], objects={'agent': Agent}, auth_group=['human'])\nasync def query_agent(request, agent):\n    return agent\n\n\n@api('/api/adversaries', methods=['GET', 'POST'], auth_group=['human'])\nasync def query_adversaries(request):\n    if request.method == 'GET':\n        return Adversary.objects\n    elif request.method == 'POST':\n        json = await request.json()\n        json['artifactlists'] = [Artifactlist.objects.with_id(x) for x in json['artifactlists']]\n        json['steps'] = [CodedStep.objects.with_id(x) for x in json['steps']]\n        return Adversary(**json).save().id\n\n\n@api('/api/adversaries/{adversary}', methods=['GET', 'PUT', 'DELETE'], objects={'adversary': Adversary}, auth_group=['human'])\nasync def query_adversary(request, adversary):\n    if request.method == 'GET':\n        return adversary\n    elif request.method == 'PUT':\n        if (adversary.protected):\n            new_adv = {}\n            new_adv['name'] = adversary['name']\n            new_adv['steps'] = adversary['steps']\n            new_adv['exfil_method'] = adversary['exfil_method']\n            new_adv['exfil_port'] = adversary['exfil_port']\n            new_adv['exfil_address'] = adversary['exfil_address']\n            new_adv['artifactlists'] = adversary['artifactlists']\n            adversary = Adversary(**new_adv).save()\n        # Update the adversary\n        json = await request.json()\n        json['artifactlists'] = [Artifactlist.objects.with_id(x) for x in json['artifactlists']]\n        json['steps'] = [CodedStep.objects.with_id(x) for x in json['steps']]\n        adversary.update(**json)\n        return adversary.id\n    elif request.method == 'DELETE':\n        if not adversary.protected:\n            return adversary.delete()\n\n\n@api('/api/step', methods=['GET'], auth_group=['human'])\nasync def query_step(request):\n    return CodedStep.objects\n\n\n@api('/api/site_user', methods=['GET', 'POST'], auth_group=['admin'])\nasync def query_siteusers(request):\n    if request.method == 'GET':\n        return SiteUser.objects.only('username', 'groups', 'email', 'last_login')\n    elif request.method == 'POST':\n        json = await request.json()\n        username = json['username']\n        email = json.get('email', '')\n        password = json.get('password', None)\n\n        groups = ['human']\n        if json.get('admin', False):\n            groups.append('admin')\n\n        return auth.register_user(username, groups, password=password, email=email).id\n\n\n@api('/api/site_user/{user}', methods=['GET', 'DELETE'], objects={'user': SiteUser}, auth_group=['admin'])\nasync def query_siteuser(request, token, user):\n    if request.method == 'GET':\n        return user.only('username', 'groups', 'email', 'last_login')\n    elif request.method == 'DELETE':\n        if token.session_info['_id'] != str(user.id):\n            return user.delete()\n\n\n@api('/api/site_user/{user}/admin', methods=['PUT', 'DELETE'], objects={'user': SiteUser}, auth_group=['admin'])\nasync def query_siteuser_admin(request, token, user):\n    if request.method == 'PUT':\n        user.modify(push__groups='admin')\n    elif request.method == 'DELETE':\n        if SiteUser.objects(groups='admin').count() > 1 and token.session_info['_id'] != str(user.id):\n            user.modify(pull__groups='admin')\n\n\n@api('/api/site_user/{user}/password', methods=['POST'], objects={'user': SiteUser}, auth_group=['admin', 'human'])\nasync def query_siteuser_password(request, token, user):\n    json = await request.json()\n    if 'password' in json:\n        if token.in_group('admin') or token.session_info['_id'] == str(user.id):\n            auth.user_change_password(user, json['password'])\n\n\n@api('/api/site_user/{user}/email', methods=['POST'], objects={'user': SiteUser}, auth_group=['admin'])\nasync def query_siteuser_email(request, user):\n    json = await request.json()\n    if 'email' in json:\n        user.update(email=json['email'])\n\n\n@api('/api/save_file', methods=['POST'], auth_group=['admin'])\nasync def save_file(request):\n    json = await request.json()\n    if 'edited' in json and 'file' in json:\n        file_path = util.get_path(json['file'])\n        if json['file'].startswith(\"[-d-]\") or file_path is None:\n            return\n        core = util.encrypt_file(json['edited'])\n        with open(file_path, 'wb') as handle:\n            core.tofile(handle)\n\n\n@api('/api/list_file', methods=['GET'], auth_group=['admin'])\nasync def list_files(request):\n    return util.list_files()\n\n\n@api('/api/load_file', methods=['POST'], auth_group=['admin'])\nasync def load_file(request):\n    json = await request.json()\n    if 'file' in json:\n        file_path = util.get_path(json['file'])\n        if json['file'].startswith(\"[-d-]\") or json['file'] == '' or file_path is None:\n            return\n        if file_path.startswith('[m]'):\n            return file_path\n        with open(file_path, 'rb') as handle:\n            data = handle.read()\n        return util.decrypt_file(data)\n\n\n@api('/api/load_psexec', methods=['GET'], auth_group=['admin'])\nasync def load_psexec(request):\n    extern.load_psexec()\n    Setting.objects.first().update(last_psexec_update=util.tz_utcnow())\n\n\n@api('/api/load_attack', methods=['GET'], auth_group=['admin'])\nasync def load_attack(request):\n    attack.refresh_attack()\n    Setting.objects.first().update(last_attack_update=util.tz_utcnow())\n\n\n@api('/api/update_depth', methods=['POST'], auth_group=['admin'])\nasync def update_recursion_limit(request):\n    json = await request.json()\n    if 'new_value' in json:\n        Setting.objects.first().modify(recursion_limit=json['new_value'])\n\n\n@api('/api/group_mimic', methods=['GET'], auth_group=['admin', 'human'])\nasync def group_coverage(request):\n    temp_list = []\n    core = {}\n    for step in CodedStep.objects:\n        for mapping in step.mapping:\n            temp_list.append(mapping.technique)\n    groups = AttackGroup.objects\n    for entry in groups:\n        temp = {}\n        breakdown = {}\n        decision = []\n        for tech in entry.techniques:\n            temp[tech.name] = (tech in temp_list)\n            decision.append(tech in temp_list)\n        breakdown['techniques'] = temp\n        if (False not in decision) and (len(decision) > 2):\n            breakdown['conclusion'] = 'Can Fully Emulate'\n        else:\n            breakdown['conclusion'] = 'Can Not Fully Emulate'\n        core[entry.name] = breakdown\n    return core\n\n\n@api('/api/steps/{step}/mapping', methods=['POST', 'DELETE'], objects={'step': CodedStep}, auth_group=['human'])\nasync def post_step_mapping(request, step):\n    if request.method == 'POST':\n        json = await request.json()\n        if 'tactics' not in json or 'technique' not in json:\n            return\n\n        tactics = json['tactics']\n        technique = json['technique']\n\n        try:\n            tech = AttackTechnique.objects.with_id(technique)\n            for tactic in tactics:\n                tac = AttackTactic.objects.with_id(tactic)\n                step.modify(push__mapping=TechniqueMapping(technique=tech, tactic=tac))\n        except (TypeError, mongoengine.errors.ValidationError):\n            return\n    elif request.method == 'DELETE':\n        json = await request.json()\n        if 'tactic' not in json or 'technique' not in json:\n            return\n\n        tactic = json['tactic']\n        technique = json['technique']\n\n        try:\n            tech = AttackTechnique.objects.with_id(technique)\n            tac = AttackTactic.objects.with_id(tactic)\n            for mapping in step.mapping:\n                if mapping.tactic == tac and mapping.technique == tech:\n                    step.modify(pull__mapping=mapping)\n        except (TypeError, mongoengine.errors.ValidationError):\n            return\n\n\n@api('/api/steps/{step}/mapping/load_defaults', methods=['GET'], objects={'step': CodedStep},\n     auth_group=['human'])\nasync def get_step_mapping_defaults(request, step):\n    step.update(mapping=step.default_mapping)\n\n\n@api('/api/attack_download.json', methods=['GET'], auth_group=['human'], headers={'Content-Disposition': 'attachment'})\nasync def get_all_attack_stuff(request):\n    try:\n        techniques = []\n        for technique in AttackTechnique.objects:\n            this_technique = technique.to_dict()\n            this_technique['tactics'] = [x.name for x in technique.tactics]\n            del this_technique['_id']\n            techniques.append(this_technique)\n\n        tactics = [x.to_dict() for x in AttackTactic.objects]\n        for tactic in tactics:\n            del tactic[\"_id\"]\n\n        return {\"techniques\": techniques, \"tactics\": tactics}\n    except (TypeError, mongoengine.errors.ValidationError):\n        return\n\n\n@api('/api/generated/{function}', methods=[\"POST\"], auth_group=['admin'])\nasync def generated_dispatcher(request):\n    dispatched_function = request.match_info['function']\n    request_json = await request.json()\n\n    job = getattr(interface, dispatched_function)(**request_json)\n    try:\n        await job.wait_till_completed()\n        return job.action['result']\n    except JobException:\n        return job.action['error']\n\n\n@api('/api/artifactlists', methods=['GET', 'POST'], auth_group=['human'])\nasync def get_artifactlists(request):\n    if request.method == 'GET':\n        return Artifactlist.objects\n    elif request.method == 'POST':\n        if request.content_type == \"application/json\":\n            content = await request.json()\n        elif request.content_type == \"text/x-yaml\":\n            try:\n                content = format_yaml(await request.text())\n            except (yaml.scanner.ScannerError, yaml.parser.ParserError):\n                return web.Response(status=400, text=\"The yaml was not properly formatted\")\n        else:\n            return web.Response(status=400)\n        try:\n            return Artifactlist(**content).save().id\n        except (mongoengine.errors.FieldDoesNotExist, mongoengine.errors.ValidationError) as e:\n            return web.Response(status=400, text=str(e))\n\n\n@api('/api/artifactlists/{artifactlist}', methods=['GET', 'PUT', 'DELETE'], objects={'artifactlist': Artifactlist}, auth_group=['human'])\nasync def query_artifactlist(request, artifactlist):\n    if request.method == 'GET':\n        return artifactlist\n    elif request.method == 'PUT':\n        if request.content_type == \"application/json\":\n            content = await request.json()\n        elif request.content_type == \"text/x-yaml\":\n            try:\n                content = format_yaml(await request.text())\n            except (yaml.scanner.ScannerError, yaml.parser.ParserError):\n                return web.Response(status=400, text=\"The yaml was not properly formatted\")\n        else:\n            return web.Response(status=400)\n        try:\n            artifactlist.update(**content)\n            return artifactlist.id\n        except (mongoengine.errors.FieldDoesNotExist, mongoengine.errors.ValidationError) as e:\n            return web.Response(status=400, text=str(e))\n    elif request.method == 'DELETE':\n        return artifactlist.delete()\n\n\n@api('/api/parse_artifactlist', methods=['POST'], auth_group=['human'])\nasync def get_parse_artifactlist(request):\n    try:\n        parsed = format_yaml(await request.text())\n        Artifactlist(**parsed)\n        return parsed\n    except (yaml.scanner.ScannerError, yaml.parser.ParserError) as e:\n        return web.Response(status=400, text=\"The yaml was not properly formatted: \\n\" + str(e.problem_mark) + '\\n  ' + str(e.problem))\n    except (mongoengine.errors.FieldDoesNotExist, mongoengine.errors.ValidationError) as e:\n        return web.Response(status=400, text=str(e))\n\n\ndef format_yaml(yaml_content):\n    parsed = yaml.load(yaml_content)\n    cleaned = {}\n    for k, v in parsed.items():\n        if isinstance(v, list) and len(v) == 1 and v[0] is None:\n            cleaned[k] = []\n        else:\n            cleaned[k] = v\n\n    return cleaned\n\n\n@api('/api/bsf/{log}', methods=['GET'], objects={'log': Log}, auth_group=['human'],\n     headers={'Content-Disposition': 'attachment; filename=\\\"bsf.json\\\"'})\nasync def query_bsf(request, log):\n    return log[\"event_stream\"]\n\n@api('/api/observed/credentials', methods=['GET'], auth_group=['human'])\nasync def query_credentials(request):\n    return ObservedCredential.objects\n\n@api('/api/observed/credentials/{credential}', methods=['GET'], \n     objects={'credential': ObservedCredential}, auth_group=['human'])\nasync def query_credential(request, token, credential):\n    return credential\n\n@api('/api/observed/users', methods=['GET'], auth_group=['human'])\nasync def query_users(request):\n    return ObservedUser.objects\n\n@api('/api/observed/users/{user}', methods=['GET'], \n     objects={'user': ObservedUser}, auth_group=['human'])\nasync def query_user(request, token, user):\n    return user\n\n@api('/api/observed/shares', methods=['GET'], auth_group=['human'])\nasync def query_shares(request):\n    return ObservedShare.objects\n\n@api('/api/observed/shares/{share}', methods=['GET'], \n     objects={'share': ObservedShare}, auth_group=['human'])\nasync def query_share(request, token, share):\n    return share\n\n@api('/api/observed/files', methods=['GET'], auth_group=['human'])\nasync def query_files(request):\n    return ObservedFile.objects\n\n@api('/api/observed/files/{file}', methods=['GET'], \n     objects={'file': ObservedFile}, auth_group=['human'])\nasync def query_file(request, token, file):\n    return file\n\n@api('/api/observed/domains', methods=['GET'], auth_group=['human'])\nasync def query_domains(request):\n    return ObservedDomain.objects\n\n@api('/api/observed/domains/{domain}', methods=['GET'], \n     objects={'domain': ObservedDomain}, auth_group=['human'])\nasync def query_domain(request, token, domain):\n    return domain\n\n@api('/api/observed/os_versions', methods=['GET'], auth_group=['human'])\nasync def query_os_versions(request):\n    return ObservedOsversion.objects\n\n@api('/api/observed/os_versions/{os_version}', methods=['GET'], \n     objects={'os_version': ObservedOSVersion}, auth_group=['human'])\nasync def query_os_version(request, token, os_version):\n    return os_version\n\n@api('/api/observed/hosts', methods=['GET'], auth_group=['human'])\nasync def query_hosts(request):\n    return ObservedHost.objects\n\n@api('/api/observed/hosts/{host}', methods=['GET'], \n     objects={'host': ObservedHost}, auth_group=['human'])\nasync def query_host(request, token, host):\n    return host\n\n@api('/api/observed/schtasks', methods=['GET'], auth_group=['human'])\nasync def query_schtasks(request):\n    return ObservedSchtask.objects\n\n@api('/api/observed/schtasks/{schtask}', methods=['GET'], \n     objects={'schtask': ObservedSchtask}, auth_group=['human'])\nasync def query_schtask(request, token, schtask):\n    return schtask\n\n@api('/api/observed/services', methods=['GET'], auth_group=['human'])\nasync def query_timedeltas(request):\n    return ObservedService.objects\n\n@api('/api/observed/services/{service}', methods=['GET'], \n     objects={'service': ObservedService}, auth_group=['human'])\nasync def query_timedelta(request, token, service):\n    return service\n\n@api('/api/observed/timedeltas', methods=['GET'], auth_group=['human'])\nasync def query_timedeltas(request):\n    return ObservedTimeDelta.objects\n\n@api('/api/observed/timedeltas/{timedelta}', methods=['GET'], \n     objects={'timedelta': ObservedTimeDelta}, auth_group=['human'])\nasync def query_timedelta(request, token, timedelta):\n    return timedelta\n\n@api('/api/observed/rats', methods=['GET'], auth_group=['human'])\nasync def query_rats(request):\n    return ObservedRat.objects\n\n@api('/api/observed/rats/{rat}', methods=['GET'], \n     objects={'rat': ObservedRat}, auth_group=['human'])\nasync def query_rat(request, token, rat):\n    return rat\n\n@api('/api/observed/registry_keys', methods=['GET'], auth_group=['human'])\nasync def query_registry_keys(request):\n    return ObservedRegKey.objects\n\n@api('/api/observed/registry_keys/{registry_key}', methods=['GET'], \n     objects={'registry_key': ObservedRegKey}, auth_group=['human'])\nasync def query_regkey(request, token, registry_key):\n    return registry_key\n\n@api('/api/observed/persistence', methods=['GET'], auth_group=['human'])\nasync def query_persistence_all(request):\n    return ObservedPersistence.objects\n\n@api('/api/observed/persistence/{persistence}', methods=['GET'], \n     objects={'persistence': ObservedPersistence}, auth_group=['human'])\nasync def query_persistence(request, token, persistence):\n    return persistence\n\n@api('/api/observed/processes', methods=['GET'], auth_group=['human'])\nasync def query_processes(request):\n    return ObservedProcess.objects\n\n@api('/api/observed/processes/{process}', methods=['GET'], \n     objects={'process': ObservedProcess}, auth_group=['human'])\nasync def query_process(request, token, process):\n    return process\n\n@api('/api/step', methods=['GET'], auth_group=['human'])\nasync def query_step(request):\n    return CodedStep.objects\n\n@websocket('/websocket', auth_group=[\"human\"])\nasync def wb_operation(request):\n    ws = web.WebSocketResponse()\n    await ws.prepare(request)\n\n    def write_websocket(data):\n        if not ws.closed:\n            ws.send_bytes(data)\n        else:\n            raise RuntimeError\n\n    srv = ddp.DDPServer(write_websocket)\n    srv.register_collection(\"operation\", Operation)\n    srv.register_collection(\"domain\", Domain)\n    srv.register_collection(\"host\", Host)\n    srv.register_collection(\"network\", Network)\n    srv.register_collection(\"rat\", Rat)\n    srv.register_collection(\"observed_rat\", ObservedRat)\n    srv.register_collection(\"observed_host\", ObservedHost)\n    srv.register_collection(\"observed_file\", ObservedFile)\n    srv.register_collection(\"observed_schtask\", ObservedSchtask)\n    srv.register_collection(\"job\", Job)\n    srv.register_collection(\"log\", Log)\n    srv.register_collection(\"adversary\", Adversary)\n    srv.register_collection(\"step\", CodedStep)\n    srv.register_collection(\"active_connection\", ActiveConnection)\n    srv.register_collection(\"agent\", Agent)\n    srv.register_collection(\"attack_technique\", AttackTechnique)\n    srv.register_collection(\"attack_tactic\", AttackTactic)\n    srv.register_collection(\"attack_list\", AttackList)\n    srv.register_collection(\"attack_group\", AttackGroup)\n    srv.register_collection(\"setting\", Setting)\n    srv.register_collection(\"artifactlist\", Artifactlist)\n\n    request.app['websockets'].append(ws)\n    try:\n        async for msg in ws:\n            if msg.type == aiohttp.WSMsgType.TEXT or msg.type == aiohttp.WSMsgType.BINARY:\n                srv.parse_message(msg.data)\n            elif msg.type == aiohttp.WSMsgType.ERROR:\n                log.debug('ws connection closed with exception {}'.format(ws.exception()))\n    finally:\n        request.app['websockets'].remove(ws)\n\n    log.debug('websocket connection closed')\n    return ws\n\n\ndef init(app):\n    # setup the generated endpoints\n    for method, uri, func in routes:\n        app.router.add_route(method, uri, func)\n",
  "output": {
    "before": "import asyncio\nfrom datetime import datetime, timezone\nfrom functools import wraps\nimport traceback\nimport inspect\nimport logging\n\nimport ujson as json_module\nimport hashlib\nimport yaml\nfrom aiohttp import web\nimport aiohttp\nimport mongoengine\nimport os\n\nfrom .engine.objects import Operation, Network, Domain, Log, ObservedHost, TechniqueMapping, Job, Rat, Host, \\\n    ObservedRat, Adversary, CodedStep, ActiveConnection, Agent, AttackTechnique, AttackTactic, SiteUser, Setting, \\\n    Opcodes, Artifactlist, ObservedFile, AttackList, JobException, ObservedSchtask, ObservedProcess, AttackGroup\nfrom .engine.objects import ObservedDomain, ObservedOSVersion, ObservedUser, ObservedShare, ObservedCredential, \\\n    ObservedService, ObservedTimeDelta, ObservedRegKey, ObservedPersistence\nfrom . import authentication as auth\nfrom .engine.database import native_types\nfrom . import ddp\nfrom . import attack\nfrom . import util\nfrom . import interface\nfrom . import extern\n\n\nlog = logging.getLogger(__name__)\n\nroutes = []\n\n\ndef api(uri, methods, objects=None, get=None, auth_group=None, headers=None):\n    \"\"\"This is a decorator for web api endpoints\n\n    Args:\n        uri: The URI for the API, can contain keywords denoted by '{}' which indicate\n        objects: a list of tuples\n        methods: the list of HTTP methods this API accepts\n        auth_group: the group that the token must be in for access to this API\n        headers: A list of headers to return with the Response\n    \"\"\"\n    if objects is None:\n        objects = {}\n    if get is None:\n        get = {}\n    if auth_group is None:\n        auth_group = []\n    if headers is None:\n        headers = {}\n\n    def decorator(f):\n        @wraps(f)\n        async def decorated(req, token, url_match):\n            kwargs = {}\n            # Map id to object\n            for name, _class in objects.items():\n                if name in url_match:\n                    # If this fails and the request type is 'GET',\n                    # then an exception should be returned\n                    try:\n                        kwargs[name] = _class.objects.with_id(url_match[name])\n                        if kwargs[name] is None:\n                            return web.HTTPBadRequest()\n                    except (mongoengine.errors.ValidationError, ):\n                        # The client has sent an invalid id in the URL\n                        return web.HTTPBadRequest()\n\n            # Now set the default get parameters\n            # For cases where we see args like ?arg1=value1&arg2&...\n            # arg2 is set to ''\n            # but change it to True instead\n            trueified = {k: True if v == '' else v for k, v in req.GET.items()}\n\n            for k, v in get.items():\n                kwargs[k] = trueified.get(k, v)\n\n            sig = inspect.signature(f)\n\n            if 'token' in sig.parameters:\n                kwargs['token'] = token\n\n            # Finally format the output as json (or jsonfm)\n            results = await f(req, **kwargs)\n            if isinstance(results, web.StreamResponse):\n                return results\n            else:\n                json = json_module.dumps(native_types(results), sort_keys=True, indent=4)\n                return web.Response(text=json, content_type='application/json', headers=headers)\n\n        async def entrypoint(req):\n            host = None\n            try:\n                # ensure this member is authorized\n                token = auth.Token(req.cookies.get('AUTH'))\n                l = [g for g in auth_group if token.in_group(g)]\n                if len(l) == 0:\n                    raise auth.NotAuthorized()\n\n                # active connections\n                peername = req.transport.get_extra_info('peername')\n                if peername is not None:\n                    host_ip, port = peername\n                    if req.host:\n                        local_ip = req.host.split(\":\")[0]\n                        if local_ip == \"localhost\":\n                            local_ip = \"127.0.0.1\"\n                    else:\n                        local_ip = \"127.0.0.1\"\n                    token_host = None\n                    if token.in_group('agent'):\n                        agent = Agent.objects.with_id(token.session_info['_id'])\n                        if agent is None:\n                            raise auth.NotAuthorized\n                        agent.modify(**{'alive': True})\n                        token_host = agent.host\n                    host = ActiveConnection.objects(ip=host_ip, host=token_host, local_ip=local_ip).first()\n                    if host is None:\n                        host = ActiveConnection(ip=host_ip, host=token_host, local_ip=local_ip, connections=0).save()\n                    host.update(inc__connections=1)\n\n                resp = await decorated(req, token, req.match_info)\n                return resp\n            except auth.NotAuthorized:\n                return web.HTTPForbidden()\n            except Exception:\n                traceback.print_exc()\n                results = {'error': 'exception in ' + f.__name__}\n                output = json_module.dumps(results, sort_keys=True, indent=4)\n                return web.HTTPInternalServerError(text=output, content_type='application/json')\n            finally:\n                if host:\n                    host.update(dec__connections=1)\n\n        for method in methods:\n            routes.append((method, uri, entrypoint))\n        return decorated\n    return decorator\n\n\ndef websocket(uri, auth_group=None):\n    if auth_group is None:\n        auth_group = []\n\n    def decorator(f):\n        @wraps(f)\n        async def entrypoint(req):\n            try:\n                # ensure this member is authorized\n                token = auth.Token(req.cookies.get('AUTH'))\n                l = [g for g in auth_group if token.in_group(g)]\n                if len(l) == 0:\n                    raise auth.NotAuthorized()\n                return await f(req)\n            except auth.NotAuthorized:\n                return web.HTTPForbidden()\n            except Exception:\n                traceback.print_exc()\n                results = {'error': 'exception in ' + f.__name__}\n                output = json_module.dumps(results, sort_keys=True, indent=4)\n                return web.HTTPInternalServerError(text=output, content_type='application/json')\n\n        routes.append(('GET', uri, entrypoint))\n        return entrypoint\n    return decorator\n\n\n# Example usage:\n# GET  /api/jobs\n# POST /api/jobs     { 'action': 'install_service', 'host': 'mm198673-pc', ... }\n@api('/api/jobs', methods=['GET', 'POST'], get={'status': None, 'wait': False}, auth_group=['human', 'agent'])\nasync def query_jobs(request, token, status, wait):\n    if request.method == 'GET':\n        query = {}\n        if status:\n            query['status'] = status\n\n        if token.in_group('agent'):\n            agent = Agent.objects.with_id(token.session_info['_id'])\n            if not agent:\n                raise auth.NotAuthorized()\n            # are there any jobs for this agent?\n            query.update({'agent': agent.id})\n            jobs = list(Job.objects(**query))\n            if not len(jobs) and wait is not False:\n                # Now wait for jobs to be created\n                try:\n                    jobs = [(await Job.wait_next(query))]\n                except asyncio.CancelledError:\n                    return\n\n        else:\n            jobs = list(Job.objects(**query))\n            if not len(jobs) and wait is not False:\n                jobs = [(await Job.wait_next(query))]\n\n        return jobs\n    elif request.method == 'POST':\n        # only humans are allowed to create new jobs\n        token.require_group('human')\n        json = await request.json()\n        return Job(**json).save().id\n\n\n# Example usage:\n# GET  /api/jobs/<job>\n# POST /api/jobs/<job>     { 'action': 'install_service', 'host': 'mm198673-pc', ... }\n@api('/api/jobs/{job}', methods=['GET', 'PUT', 'DELETE'], objects={'job': Job}, auth_group=['human', 'agent'])\nasync def query_job(request, token, job):\n    if request.method == 'GET':\n        if token.in_group('agent'):\n            # can only get jobs that are not completed and are for them\n            if job['status'] in (\"created\", \"pending\") and str(job.agent.id) == token.session_info['_id']:\n                return job\n            else:\n                raise auth.NotAuthorized()\n        else:\n            return job\n    elif request.method == 'PUT':\n        if token.in_group('agent'):\n            # can only put jobs that are not completed and are for them\n            if job.status in (\"created\", \"pending\") and str(job.agent.id) == token.session_info['_id']:\n                json = await request.json()\n                # whitelist legal fields\n                if 'result' in json['action']:\n                    job['action']['result'] = json['action']['result']\n                if 'error' in json['action']:\n                    job['action']['error'] = json['action']['error']\n                if 'exception' in json['action']:\n                    job['action']['exception'] = json['action']['exception']\n                job['status'] = json.get('status', job.status)\n\n                if job['status'] == \"failed\" and 'error' in job['action'] and job['action']['error'] == \"no client\":\n                    # Force update the clients list\n                    interface.get_clients(job.agent.host)\n                    # find the rat\n                    try:\n                        iv_name = job['action'][\"rats\"][\"args\"][0]\n                        iv = Rat.objects(agent=job.agent, name=iv_name)\n                        iv.modify(**{'active': False})\n                    except KeyError:\n                        log.warning(\"Could not find rat to remove for failed job\")\n                return job.save()\n            else:\n                raise auth.NotAuthorized()\n\n        else:  # human\n            # Update the job\n            json = await request.json()\n            if json['create_time']:\n                json['create_time'] = datetime.strptime(json['create_time'], \"%Y-%m-%dT%H:%M:%S.%f\")\n            return job.save()\n\n    elif request.method == 'DELETE':\n        token.require_group('human')\n        return job.delete()\n\n\n# Example usage:\n# POST /api/clients\n@api('/api/clients', methods=['POST'], auth_group=['agent'])\nasync def query_clients(request, token):\n    json = await request.json()\n    # pid, elevated, executable_path\n    agen = Agent.objects.with_id(token.session_info['_id'])\n\n    # Get the list of known rats\n    complete_names = {iv.name: iv for iv in Rat.objects(host=agen.host)}\n    # Filter list for living rats\n    known_names = {}\n    for name, element in complete_names.items():\n        if element.active:\n            known_names[name] = element\n    # All of the currently running rats, as returned by the job\n    active = {x['pid']: x for x in json}\n\n    # Enumerate the active rats, and delete dead ones\n    for name, iv in known_names.items():\n        if name not in active:\n            iv.modify(**{'active': False})\n        else:\n            a = active.pop(name)\n            iv.update(**{'elevated': a['elevated'],\n                         'executable': a['executable_path']})\n\n    # Any new rats need to be added\n    for name in active:\n        Rat(**{'agent': agen,\n                     'host': agen.host,\n                     'name': name,\n                     'elevated': active[name]['elevated'],\n                     'executable': active[name]['executable_path'],\n                     'username': active[name]['username'].lower(),\n                     'active': True}).save()\n    return None\n\n\n# Example usage:\n# GET  /api/networks\n# POST /api/networks     { domain: 'mitre.org' }\n@api('/api/networks', methods=['GET', 'POST'], auth_group=['human'])\nasync def query_networks(request):\n    if request.method == 'GET':\n        return Network.objects\n    elif request.method == 'POST':\n        json = await request.json()\n        network = Network(**json).save()\n        return network.id\n\n\n@api('/api/networks/{network}', methods=['GET', 'DELETE'], objects={'network': Network}, auth_group=['human'])\nasync def query_network(request, network):\n    if request.method == 'GET':\n        return network\n    elif request.method == 'DELETE':\n        network.delete()\n\n\n@api('/api/heartbeat', methods=['GET'], auth_group=['agent'])\nasync def agent_check_in(request, token):\n    agen = Agent.objects.with_id(token.session_info['_id'])\n    agen.modify(**{'check_in': datetime.now(timezone.utc), 'alive': True})\n    return True\n\n\n@api('/api/hosts', methods=['GET'], auth_group=['human'])\nasync def query_hosts(request):\n    return Host.objects\n\n\n@api('/api/domains', methods=['GET'], auth_group=['human'])\nasync def query_domains(request):\n    return Domain.objects\n\n\n@api('/api/domains/{domain}', methods=['GET'], objects={'domain': Domain}, auth_group=['human'])\nasync def query_domain(request, domain):\n    return domain\n\n\n@api('/api/domains/{domain}/hosts', methods=['GET'], objects={'domain': Domain}, auth_group=['human'])\nasync def query_domainhosts(request, domain):\n    return Host.objects(domain=domain)\n\n\n@api('/api/networks/{network}/hosts', methods=['GET'], objects={'network': Network}, auth_group=['human'])\nasync def query_networkhosts(request, network):\n    return network.hosts\n\n\n@api('/api/networks/{network}/hosts/{host}', methods=['GET', 'PUT', 'DELETE'],\n     objects={'network': Network, 'host': Host}, auth_group=['human'])\nasync def query_networkhosthosts(request, network, host):\n    if request.method == 'GET':\n        return host\n    elif request.method == 'PUT':\n        network.modify(push__hosts=host)\n    elif request.method == 'DELETE':\n        network.modify(pull__hosts=host)\n\n\n@api('/api/hosts/{host}/commands', methods=['GET', 'POST'], objects={'host': Host}, auth_group=['human'])\nasync def query_commands(request, host):\n    if request.method == 'GET':\n        if 'hostname' in request.GET:\n            hosts = Host.objects(hostname=request.GET['hostname'])\n            return [x.host_command_result() for x in Job.objects(host__in=hosts)]\n        else:\n            return [x.host_command_result() for x in Job.objects(host=host)]\n    elif request.method == 'POST':\n        json = await request.json()\n        return interface.agent_shell_command(host, json['command_line']).id\n\n\n@api('/api/hosts/{host}/commands/{job}', methods=['GET'], get={'wait': False},\n     objects={'host': Host, 'job': Job}, auth_group=['human'])\nasync def query_command(request, wait, host, job):\n    # start waiting for the job before reloading to avoid missing the update\n    if wait is not False:\n        try:\n            await job.wait_till_completed()\n        except JobException as e:\n            log.warning(e.args)\n\n    return job.host_command_result()\n\n\n@api('/api/rats', methods=['GET'], auth_group=['human'])\nasync def query_ivs(request):\n    query = {k: v for k, v in request.GET.items() if k == 'hostname'}\n    return Rat.objects(**query)\n\n\n@api('/api/rats/{rat}', methods=['GET'], objects={'rat': Rat}, auth_group=['human'])\nasync def query_iv(rat):\n    return rat\n\n\n@api('/api/rats/{rat}/commands', methods=['GET', 'POST'],\n     objects={'rat': Rat}, auth_group=['human'])\nasync def query_ivcommands(request, rat):\n    if request.method == 'GET':\n        return [x.rat_command_result() for x in Job.objects(agent=rat.agent)]\n    elif request.method == 'POST':\n        json = await request.json()\n        return Job.create_rat_command(rat, json[\"function\"], **json[\"parameters\"]).id\n\n\n@api('/api/rats/{rat}/commands/{job}', methods=['GET'],\n     get={'wait': False}, objects={'rat': Rat, 'job': Job}, auth_group=['human'])\nasync def query_ivcommand(request, wait, rat, job):\n    # start waiting for the job before reloading to avoid missing the update\n    if wait is not False:\n        try:\n            await job.wait_till_completed()\n        except JobException as e:\n            log.warning(e.args)\n    return job.rat_result()\n\n\n@api('/api/operations', methods=['GET'], auth_group=['human'])\nasync def query_operations(request):\n    return Operation.objects\n\n\n@api('/api/opcodes', methods=['GET'], auth_group=['human'])\nasync def get_opcodes(request):\n    return Opcodes.arguments\n\n@api('/api/networks/{network}/operations', methods=['GET', 'POST'], objects={'network': Network}, auth_group=['human'])\nasync def query_perations(request, network):\n    if request.method == 'GET':\n        return list(Operation.objects(network=network))\n    elif request.method == 'POST':\n        json = await request.json()\n        if json['start_type'] == 'existing' and 'start_rat' not in json:\n            return None\n        json['network'] = network\n        json['status'] = 'start'\n        json['status_state'] = ''\n        json['log'] = Log().save()\n        # Get the adversary\n        adversary = Adversary.objects.with_id(json['adversary'])\n        json['steps'] = [x.name for x in adversary.steps]\n        operation = Operation(**json).save()\n        return operation.id\n\n@api('/api/networks/{network}/operations/{operation}', methods=['GET', 'PUT', 'DELETE', 'PATCH'], get={'wait': False},\n     objects={'network': Network, 'operation': Operation}, auth_group=['human'])\nasync def query_operation(request, network, operation, wait):\n    if request.method == 'GET':\n        if wait:\n            wait = json_module.loads(wait)\n            wait[\"id\"] = operation.id\n            log.info(\"Wait: {}\".format(wait))\n            # TODO fix race condition here\n            new = list(Operation.objects(**wait))\n            if len(new) == 0:\n                del wait[\"id\"]\n                new = [await operation.wait(wait)]\n            return new[0]\n        return operation\n    elif request.method == 'PUT':\n        json = await request.json()\n        json['network_id'] = network.id\n        json['hosts'] = network.hosts\n        return operation.update(**json)\n    elif request.method == 'DELETE':\n        return operation.delete()\n    elif request.method == 'PATCH':\n        json = await request.json()\n        operation.update(__raw__={'$set': json})\n\n\n@api('/api/agents', methods=['GET'], auth_group=['human'])\nasync def query_agents(request):\n    return Agent.objects\n\n\n@api('/api/logs', methods=['GET'], auth_group=['human'])\nasync def query_logs(request):\n    return Log.objects\n\n\n@api('/api/logs/{log}', methods=['GET'], objects={'log': Log}, auth_group=['human'])\nasync def query_log(request, log):\n    return log\n\n\n@api('/api/agents/{agent}', methods=['GET'], objects={'agent': Agent}, auth_group=['human'])\nasync def query_agent(request, agent):\n    return agent\n\n\n@api('/api/adversaries', methods=['GET', 'POST'], auth_group=['human'])\nasync def query_adversaries(request):\n    if request.method == 'GET':\n        return Adversary.objects\n    elif request.method == 'POST':\n        json = await request.json()\n        json['artifactlists'] = [Artifactlist.objects.with_id(x) for x in json['artifactlists']]\n        json['steps'] = [CodedStep.objects.with_id(x) for x in json['steps']]\n        return Adversary(**json).save().id\n\n\n@api('/api/adversaries/{adversary}', methods=['GET', 'PUT', 'DELETE'], objects={'adversary': Adversary}, auth_group=['human'])\nasync def query_adversary(request, adversary):\n    if request.method == 'GET':\n        return adversary\n    elif request.method == 'PUT':\n        if (adversary.protected):\n            new_adv = {}\n            new_adv['name'] = adversary['name']\n            new_adv['steps'] = adversary['steps']\n            new_adv['exfil_method'] = adversary['exfil_method']\n            new_adv['exfil_port'] = adversary['exfil_port']\n            new_adv['exfil_address'] = adversary['exfil_address']\n            new_adv['artifactlists'] = adversary['artifactlists']\n            adversary = Adversary(**new_adv).save()\n        # Update the adversary\n        json = await request.json()\n        json['artifactlists'] = [Artifactlist.objects.with_id(x) for x in json['artifactlists']]\n        json['steps'] = [CodedStep.objects.with_id(x) for x in json['steps']]\n        adversary.update(**json)\n        return adversary.id\n    elif request.method == 'DELETE':\n        if not adversary.protected:\n            return adversary.delete()\n\n\n@api('/api/step', methods=['GET'], auth_group=['human'])\nasync def query_step(request):\n    return CodedStep.objects\n\n\n@api('/api/site_user', methods=['GET', 'POST'], auth_group=['admin'])\nasync def query_siteusers(request):\n    if request.method == 'GET':\n        return SiteUser.objects.only('username', 'groups', 'email', 'last_login')\n    elif request.method == 'POST':\n        json = await request.json()\n        username = json['username']\n        email = json.get('email', '')\n        password = json.get('password', None)\n\n        groups = ['human']\n        if json.get('admin', False):\n            groups.append('admin')\n\n        return auth.register_user(username, groups, password=password, email=email).id\n\n\n@api('/api/site_user/{user}', methods=['GET', 'DELETE'], objects={'user': SiteUser}, auth_group=['admin'])\nasync def query_siteuser(request, token, user):\n    if request.method == 'GET':\n        return user.only('username', 'groups', 'email', 'last_login')\n    elif request.method == 'DELETE':\n        if token.session_info['_id'] != str(user.id):\n            return user.delete()\n\n\n@api('/api/site_user/{user}/admin', methods=['PUT', 'DELETE'], objects={'user': SiteUser}, auth_group=['admin'])\nasync def query_siteuser_admin(request, token, user):\n    if request.method == 'PUT':\n        user.modify(push__groups='admin')\n    elif request.method == 'DELETE':\n        if SiteUser.objects(groups='admin').count() > 1 and token.session_info['_id'] != str(user.id):\n            user.modify(pull__groups='admin')\n\n\n@api('/api/site_user/{user}/password', methods=['POST'], objects={'user': SiteUser}, auth_group=['admin', 'human'])\nasync def query_siteuser_password(request, token, user):\n    json = await request.json()\n    if 'password' in json:\n        if token.in_group('admin') or token.session_info['_id'] == str(user.id):\n            auth.user_change_password(user, json['password'])\n\n\n@api('/api/site_user/{user}/email', methods=['POST'], objects={'user': SiteUser}, auth_group=['admin'])\nasync def query_siteuser_email(request, user):\n    json = await request.json()\n    if 'email' in json:\n        user.update(email=json['email'])\n\n\n@api('/api/save_file', methods=['POST'], auth_group=['admin'])\nasync def save_file(request):\n    json = await request.json()\n    if 'edited' in json and 'file' in json:\n        file_path = util.get_path(json['file'])\n        if json['file'].startswith(\"[-d-]\") or file_path is None:\n            return\n        core = util.encrypt_file(json['edited'])\n        with open(file_path, 'wb') as handle:\n            core.tofile(handle)\n\n\n@api('/api/list_file', methods=['GET'], auth_group=['admin'])\nasync def list_files(request):\n    return util.list_files()\n\n\n@api('/api/load_file', methods=['POST'], auth_group=['admin'])\nasync def load_file(request):\n    json = await request.json()\n    if 'file' in json:\n        file_path = util.get_path(json['file'])\n        if json['file'].startswith(\"[-d-]\") or json['file'] == '' or file_path is None:\n            return\n        if file_path.startswith('[m]'):\n            return file_path\n        with open(file_path, 'rb') as handle:\n            data = handle.read()\n        return util.decrypt_file(data)\n\n\n@api('/api/load_psexec', methods=['GET'], auth_group=['admin'])\nasync def load_psexec(request):\n    extern.load_psexec()\n    Setting.objects.first().update(last_psexec_update=util.tz_utcnow())\n\n\n@api('/api/load_attack', methods=['GET'], auth_group=['admin'])\nasync def load_attack(request):\n    attack.refresh_attack()\n    Setting.objects.first().update(last_attack_update=util.tz_utcnow())\n\n\n@api('/api/update_depth', methods=['POST'], auth_group=['admin'])\nasync def update_recursion_limit(request):\n    json = await request.json()\n    if 'new_value' in json:\n        Setting.objects.first().modify(recursion_limit=json['new_value'])\n\n\n@api('/api/group_mimic', methods=['GET'], auth_group=['admin', 'human'])\nasync def group_coverage(request):\n    temp_list = []\n    core = {}\n    for step in CodedStep.objects:\n        for mapping in step.mapping:\n            temp_list.append(mapping.technique)\n    groups = AttackGroup.objects\n    for entry in groups:\n        temp = {}\n        breakdown = {}\n        decision = []\n        for tech in entry.techniques:\n            temp[tech.name] = (tech in temp_list)\n            decision.append(tech in temp_list)\n        breakdown['techniques'] = temp\n        if (False not in decision) and (len(decision) > 2):\n            breakdown['conclusion'] = 'Can Fully Emulate'\n        else:\n            breakdown['conclusion'] = 'Can Not Fully Emulate'\n        core[entry.name] = breakdown\n    return core\n\n\n@api('/api/steps/{step}/mapping', methods=['POST', 'DELETE'], objects={'step': CodedStep}, auth_group=['human'])\nasync def post_step_mapping(request, step):\n    if request.method == 'POST':\n        json = await request.json()\n        if 'tactics' not in json or 'technique' not in json:\n            return\n\n        tactics = json['tactics']\n        technique = json['technique']\n\n        try:\n            tech = AttackTechnique.objects.with_id(technique)\n            for tactic in tactics:\n                tac = AttackTactic.objects.with_id(tactic)\n                step.modify(push__mapping=TechniqueMapping(technique=tech, tactic=tac))\n        except (TypeError, mongoengine.errors.ValidationError):\n            return\n    elif request.method == 'DELETE':\n        json = await request.json()\n        if 'tactic' not in json or 'technique' not in json:\n            return\n\n        tactic = json['tactic']\n        technique = json['technique']\n\n        try:\n            tech = AttackTechnique.objects.with_id(technique)\n            tac = AttackTactic.objects.with_id(tactic)\n            for mapping in step.mapping:\n                if mapping.tactic == tac and mapping.technique == tech:\n                    step.modify(pull__mapping=mapping)\n        except (TypeError, mongoengine.errors.ValidationError):\n            return\n\n\n@api('/api/steps/{step}/mapping/load_defaults', methods=['GET'], objects={'step': CodedStep},\n     auth_group=['human'])\nasync def get_step_mapping_defaults(request, step):\n    step.update(mapping=step.default_mapping)\n\n\n@api('/api/attack_download.json', methods=['GET'], auth_group=['human'], headers={'Content-Disposition': 'attachment'})\nasync def get_all_attack_stuff(request):\n    try:\n        techniques = []\n        for technique in AttackTechnique.objects:\n            this_technique = technique.to_dict()\n            this_technique['tactics'] = [x.name for x in technique.tactics]\n            del this_technique['_id']\n            techniques.append(this_technique)\n\n        tactics = [x.to_dict() for x in AttackTactic.objects]\n        for tactic in tactics:\n            del tactic[\"_id\"]\n\n        return {\"techniques\": techniques, \"tactics\": tactics}\n    except (TypeError, mongoengine.errors.ValidationError):\n        return\n\n\n@api('/api/generated/{function}', methods=[\"POST\"], auth_group=['admin'])\nasync def generated_dispatcher(request):\n    dispatched_function = request.match_info['function']\n    request_json = await request.json()\n\n    job = getattr(interface, dispatched_function)(**request_json)\n    try:\n        await job.wait_till_completed()\n        return job.action['result']\n    except JobException:\n        return job.action['error']\n\n\n@api('/api/artifactlists', methods=['GET', 'POST'], auth_group=['human'])\nasync def get_artifactlists(request):\n    if request.method == 'GET':\n        return Artifactlist.objects\n    elif request.method == 'POST':\n        if request.content_type == \"application/json\":\n            content = await request.json()\n        elif request.content_type == \"text/x-yaml\":\n            try:\n                content = format_yaml(await request.text())\n            except (yaml.scanner.ScannerError, yaml.parser.ParserError):\n                return web.Response(status=400, text=\"The yaml was not properly formatted\")\n        else:\n            return web.Response(status=400)\n        try:\n            return Artifactlist(**content).save().id\n        except (mongoengine.errors.FieldDoesNotExist, mongoengine.errors.ValidationError) as e:\n            return web.Response(status=400, text=str(e))\n\n\n@api('/api/artifactlists/{artifactlist}', methods=['GET', 'PUT', 'DELETE'], objects={'artifactlist': Artifactlist}, auth_group=['human'])\nasync def query_artifactlist(request, artifactlist):\n    if request.method == 'GET':\n        return artifactlist\n    elif request.method == 'PUT':\n        if request.content_type == \"application/json\":\n            content = await request.json()\n        elif request.content_type == \"text/x-yaml\":\n            try:\n                content = format_yaml(await request.text())\n            except (yaml.scanner.ScannerError, yaml.parser.ParserError):\n                return web.Response(status=400, text=\"The yaml was not properly formatted\")\n        else:\n            return web.Response(status=400)\n        try:\n            artifactlist.update(**content)\n            return artifactlist.id\n        except (mongoengine.errors.FieldDoesNotExist, mongoengine.errors.ValidationError) as e:\n            return web.Response(status=400, text=str(e))\n    elif request.method == 'DELETE':\n        return artifactlist.delete()\n\n\n@api('/api/parse_artifactlist', methods=['POST'], auth_group=['human'])\nasync def get_parse_artifactlist(request):\n    try:\n        parsed = format_yaml(await request.text())\n        Artifactlist(**parsed)\n        return parsed\n    except (yaml.scanner.ScannerError, yaml.parser.ParserError) as e:\n        return web.Response(status=400, text=\"The yaml was not properly formatted: \\n\" + str(e.problem_mark) + '\\n  ' + str(e.problem))\n    except (mongoengine.errors.FieldDoesNotExist, mongoengine.errors.ValidationError) as e:\n        return web.Response(status=400, text=str(e))\n\n\ndef format_yaml(yaml_content):\n    parsed = yaml.load(yaml_content)\n    cleaned = {}\n    for k, v in parsed.items():\n        if isinstance(v, list) and len(v) == 1 and v[0] is None:\n            cleaned[k] = []\n        else:\n            cleaned[k] = v\n\n    return cleaned\n\n\n@api('/api/bsf/{log}', methods=['GET'], objects={'log': Log}, auth_group=['human'],\n     headers={'Content-Disposition': 'attachment; filename=\\\"bsf.json\\\"'})\nasync def query_bsf(request, log):\n    return log[\"event_stream\"]\n\n@api('/api/observed/credentials', methods=['GET'], auth_group=['human'])\nasync def query_credentials(request):\n    return ObservedCredential.objects\n\n@api('/api/observed/credentials/{credential}', methods=['GET'], \n     objects={'credential': ObservedCredential}, auth_group=['human'])\nasync def query_credential(request, token, credential):\n    return credential\n\n@api('/api/observed/users', methods=['GET'], auth_group=['human'])\nasync def query_users(request):\n    return ObservedUser.objects\n\n@api('/api/observed/users/{user}', methods=['GET'], \n     objects={'user': ObservedUser}, auth_group=['human'])\nasync def query_user(request, token, user):\n    return user\n\n@api('/api/observed/shares', methods=['GET'], auth_group=['human'])\nasync def query_shares(request):\n    return ObservedShare.objects\n\n@api('/api/observed/shares/{share}', methods=['GET'], \n     objects={'share': ObservedShare}, auth_group=['human'])\nasync def query_share(request, token, share):\n    return share\n\n@api('/api/observed/files', methods=['GET'], auth_group=['human'])\nasync def query_files(request):\n    return ObservedFile.objects\n\n@api('/api/observed/files/{file}', methods=['GET'], \n     objects={'file': ObservedFile}, auth_group=['human'])\nasync def query_file(request, token, file):\n    return file\n\n@api('/api/observed/domains', methods=['GET'], auth_group=['human'])\nasync def query_domains(request):\n    return ObservedDomain.objects\n\n@api('/api/observed/domains/{domain}', methods=['GET'], \n     objects={'domain': ObservedDomain}, auth_group=['human'])\nasync def query_domain(request, token, domain):\n    return domain\n\n@api('/api/observed/os_versions', methods=['GET'], auth_group=['human'])\nasync def query_os_versions(request):\n    return ObservedOsversion.objects\n\n@api('/api/observed/os_versions/{os_version}', methods=['GET'], \n     objects={'os_version': ObservedOSVersion}, auth_group=['human'])\nasync def query_os_version(request, token, os_version):\n    return os_version\n\n@api('/api/observed/hosts', methods=['GET'], auth_group=['human'])\nasync def query_hosts(request):\n    return ObservedHost.objects\n\n@api('/api/observed/hosts/{host}', methods=['GET'], \n     objects={'host': ObservedHost}, auth_group=['human'])\nasync def query_host(request, token, host):\n    return host\n\n@api('/api/observed/schtasks', methods=['GET'], auth_group=['human'])\nasync def query_schtasks(request):\n    return ObservedSchtask.objects\n\n@api('/api/observed/schtasks/{schtask}', methods=['GET'], \n     objects={'schtask': ObservedSchtask}, auth_group=['human'])\nasync def query_schtask(request, token, schtask):\n    return schtask\n\n@api('/api/observed/services', methods=['GET'], auth_group=['human'])\nasync def query_timedeltas(request):\n    return ObservedService.objects\n\n@api('/api/observed/services/{service}', methods=['GET'], \n     objects={'service': ObservedService}, auth_group=['human'])\nasync def query_timedelta(request, token, service):\n    return service\n\n@api('/api/observed/timedeltas', methods=['GET'], auth_group=['human'])\nasync def query_timedeltas(request):\n    return ObservedTimeDelta.objects\n\n@api('/api/observed/timedeltas/{timedelta}', methods=['GET'], \n     objects={'timedelta': ObservedTimeDelta}, auth_group=['human'])\nasync def query_timedelta(request, token, timedelta):\n    return timedelta\n\n@api('/api/observed/rats', methods=['GET'], auth_group=['human'])\nasync def query_rats(request):\n    return ObservedRat.objects\n\n@api('/api/observed/rats/{rat}', methods=['GET'], \n     objects={'rat': ObservedRat}, auth_group=['human'])\nasync def query_rat(request, token, rat):\n    return rat\n\n@api('/api/observed/registry_keys', methods=['GET'], auth_group=['human'])\nasync def query_registry_keys(request):\n    return ObservedRegKey.objects\n\n@api('/api/observed/registry_keys/{registry_key}', methods=['GET'], \n     objects={'registry_key': ObservedRegKey}, auth_group=['human'])\nasync def query_regkey(request, token, registry_key):\n    return registry_key\n\n@api('/api/observed/persistence', methods=['GET'], auth_group=['human'])\nasync def query_persistence_all(request):\n    return ObservedPersistence.objects\n\n@api('/api/observed/persistence/{persistence}', methods=['GET'], \n     objects={'persistence': ObservedPersistence}, auth_group=['human'])\nasync def query_persistence(request, token, persistence):\n    return persistence\n\n@api('/api/observed/processes', methods=['GET'], auth_group=['human'])\nasync def query_processes(request):\n    return ObservedProcess.objects\n\n@api('/api/observed/processes/{process}', methods=['GET'], \n     objects={'process': ObservedProcess}, auth_group=['human'])\nasync def query_process(request, token, process):\n    return process\n\n@api('/api/step', methods=['GET'], auth_group=['human'])\nasync def query_step(request):\n    return CodedStep.objects\n\n@websocket('/websocket', auth_group=[\"human\"])\nasync def wb_operation(request):\n    ws = web.WebSocketResponse()\n    await ws.prepare(request)\n\n    def write_websocket(data):\n        if not ws.closed:\n            ws.send_bytes(data)\n        else:\n            raise RuntimeError\n\n    srv = ddp.DDPServer(write_websocket)\n    srv.register_collection(\"operation\", Operation)\n    srv.register_collection(\"domain\", Domain)\n    srv.register_collection(\"host\", Host)\n    srv.register_collection(\"network\", Network)\n    srv.register_collection(\"rat\", Rat)\n    srv.register_collection(\"observed_rat\", ObservedRat)\n    srv.register_collection(\"observed_host\", ObservedHost)\n    srv.register_collection(\"observed_file\", ObservedFile)\n    srv.register_collection(\"observed_schtask\", ObservedSchtask)\n    srv.register_collection(\"job\", Job)\n    srv.register_collection(\"log\", Log)\n    srv.register_collection(\"adversary\", Adversary)\n    srv.register_collection(\"step\", CodedStep)\n    srv.register_collection(\"active_connection\", ActiveConnection)\n    srv.register_collection(\"agent\", Agent)\n    srv.register_collection(\"attack_technique\", AttackTechnique)\n    srv.register_collection(\"attack_tactic\", AttackTactic)\n    srv.register_collection(\"attack_list\", AttackList)\n    srv.register_collection(\"attack_group\", AttackGroup)\n    srv.register_collection(\"setting\", Setting)\n    srv.register_collection(\"artifactlist\", Artifactlist)\n\n    request.app['websockets'].append(ws)\n    try:\n        async for msg in ws:\n            if msg.type == aiohttp.WSMsgType.TEXT or msg.type == aiohttp.WSMsgType.BINARY:\n                srv.parse_message(msg.data)\n            elif msg.type == aiohttp.WSMsgType.ERROR:\n                log.debug('ws connection closed with exception {}'.format(ws.exception()))\n    finally:\n        request.app['websockets'].remove(ws)\n\n    log.debug('websocket connection closed')\n    return ws\n\n\ndef init(app):\n    # setup the generated endpoints\n    for method, uri, func in routes:\n        app.router.add_route(method, uri, func)\n        \n    return\n    return.data.data.\n    return.data\n    return\n    return,\n    \n    return data\n\n    return\n    \n    return\n\n    return data\n    return\n    return\n    ",
    "after": "import asyncio\nfrom datetime import datetime, timezone\nfrom functools import wraps\nimport traceback\nimport inspect\nimport logging\n\nimport ujson as json_module\nimport hashlib\nimport yaml\nfrom aiohttp import web\nimport aiohttp\nimport mongoengine\nimport os\n\nfrom .engine.objects import Operation, Network, Domain, Log, ObservedHost, TechniqueMapping, Job, Rat, Host, \\\n    ObservedRat, Adversary, CodedStep, ActiveConnection, Agent, AttackTechnique, AttackTactic, SiteUser, Setting, \\\n    Opcodes, Artifactlist, ObservedFile, AttackList, JobException, ObservedSchtask, ObservedProcess, AttackGroup\nfrom .engine.objects import ObservedDomain, ObservedOSVersion, ObservedUser, ObservedShare, ObservedCredential, \\\n    ObservedService, ObservedTimeDelta, ObservedRegKey, ObservedPersistence\nfrom . import authentication as auth\nfrom .engine.database import native_types\nfrom . import ddp\nfrom . import attack\nfrom . import util\nfrom . import interface\nfrom . import extern\n\n\nlog = logging.getLogger(__name__)\n\nroutes = []\n\n\ndef api(uri, methods, objects=None, get=None, auth_group=None, headers=None):\n    \"\"\"This is a decorator for web api endpoints\n\n    Args:\n        uri: The URI for the API, can contain keywords denoted by '{}' which indicate\n        objects: a list of tuples\n        methods: the list of HTTP methods this API accepts\n        auth_group: the group that the token must be in for access to this API\n        headers: A list of headers to return with the Response\n    \"\"\"\n    if objects is None:\n        objects = {}\n    if get is None:\n        get = {}\n    if auth_group is None:\n        auth_group = []\n    if headers is None:\n        headers = {}\n\n    def decorator(f):\n        @wraps(f)\n        async def decorated(req, token, url_match):\n            kwargs = {}\n            # Map id to object\n            for name, _class in objects.items():\n                if name in url_match:\n                    # If this fails and the request type is 'GET',\n                    # then an exception should be returned\n                    try:\n                        kwargs[name] = _class.objects.with_id(url_match[name])\n                        if kwargs[name] is None:\n                            return web.HTTPBadRequest()\n                    except (mongoengine.errors.ValidationError, ):\n                        # The client has sent an invalid id in the URL\n                        return web.HTTPBadRequest()\n\n            # Now set the default get parameters\n            # For cases where we see args like ?arg1=value1&arg2&...\n            # arg2 is set to ''\n            # but change it to True instead\n            trueified = {k: True if v == '' else v for k, v in req.GET.items()}\n\n            for k, v in get.items():\n                kwargs[k] = trueified.get(k, v)\n\n            sig = inspect.signature(f)\n\n            if 'token' in sig.parameters:\n                kwargs['token'] = token\n\n            # Finally format the output as json (or jsonfm)\n            results = await f(req, **kwargs)\n            if isinstance(results, web.StreamResponse):\n                return results\n            else:\n                json = json_module.dumps(native_types(results), sort_keys=True, indent=4)\n                return web.Response(text=json, content_type='application/json', headers=headers)\n\n        async def entrypoint(req):\n            host = None\n            try:\n                # ensure this member is authorized\n                token = auth.Token(req.cookies.get('AUTH'))\n                l = [g for g in auth_group if token.in_group(g)]\n                if len(l) == 0:\n                    raise auth.NotAuthorized()\n\n                # active connections\n                peername = req.transport.get_extra_info('peername')\n                if peername is not None:\n                    host_ip, port = peername\n                    if req.host:\n                        local_ip = req.host.split(\":\")[0]\n                        if local_ip == \"localhost\":\n                            local_ip = \"127.0.0.1\"\n                    else:\n                        local_ip = \"127.0.0.1\"\n                    token_host = None\n                    if token.in_group('agent'):\n                        agent = Agent.objects.with_id(token.session_info['_id'])\n                        if agent is None:\n                            raise auth.NotAuthorized\n                        agent.modify(**{'alive': True})\n                        token_host = agent.host\n                    host = ActiveConnection.objects(ip=host_ip, host=token_host, local_ip=local_ip).first()\n                    if host is None:\n                        host = ActiveConnection(ip=host_ip, host=token_host, local_ip=local_ip, connections=0).save()\n                    host.update(inc__connections=1)\n\n                resp = await decorated(req, token, req.match_info)\n                return resp\n            except auth.NotAuthorized:\n                return web.HTTPForbidden()\n            except Exception:\n                traceback.print_exc()\n                results = {'error': 'exception in ' + f.__name__}\n                output = json_module.dumps(results, sort_keys=True, indent=4)\n                return web.HTTPInternalServerError(text=output, content_type='application/json')\n            finally:\n                if host:\n                    host.update(dec__connections=1)\n\n        for method in methods:\n            routes.append((method, uri, entrypoint))\n        return decorated\n    return decorator\n\n\ndef websocket(uri, auth_group=None):\n    if auth_group is None:\n        auth_group = []\n\n    def decorator(f):\n        @wraps(f)\n        async def entrypoint(req):\n            try:\n                # ensure this member is authorized\n                token = auth.Token(req.cookies.get('AUTH'))\n                l = [g for g in auth_group if token.in_group(g)]\n                if len(l) == 0:\n                    raise auth.NotAuthorized()\n                return await f(req)\n            except auth.NotAuthorized:\n                return web.HTTPForbidden()\n            except Exception:\n                traceback.print_exc()\n                results = {'error': 'exception in ' + f.__name__}\n                output = json_module.dumps(results, sort_keys=True, indent=4)\n                return web.HTTPInternalServerError(text=output, content_type='application/json')\n\n        routes.append(('GET', uri, entrypoint))\n        return entrypoint\n    return decorator\n\n\n# Example usage:\n# GET  /api/jobs\n# POST /api/jobs     { 'action': 'install_service', 'host': 'mm198673-pc', ... }\n@api('/api/jobs', methods=['GET', 'POST'], get={'status': None, 'wait': False}, auth_group=['human', 'agent'])\nasync def query_jobs(request, token, status, wait):\n    if request.method == 'GET':\n        query = {}\n        if status:\n            query['status'] = status\n\n        if token.in_group('agent'):\n            agent = Agent.objects.with_id(token.session_info['_id'])\n            if not agent:\n                raise auth.NotAuthorized()\n            # are there any jobs for this agent?\n            query.update({'agent': agent.id})\n            jobs = list(Job.objects(**query))\n            if not len(jobs) and wait is not False:\n                # Now wait for jobs to be created\n                try:\n                    jobs = [(await Job.wait_next(query))]\n                except asyncio.CancelledError:\n                    return\n\n        else:\n            jobs = list(Job.objects(**query))\n            if not len(jobs) and wait is not False:\n                jobs = [(await Job.wait_next(query))]\n\n        return jobs\n    elif request.method == 'POST':\n        # only humans are allowed to create new jobs\n        token.require_group('human')\n        json = await request.json()\n        return Job(**json).save().id\n\n\n# Example usage:\n# GET  /api/jobs/<job>\n# POST /api/jobs/<job>     { 'action': 'install_service', 'host': 'mm198673-pc', ... }\n@api('/api/jobs/{job}', methods=['GET', 'PUT', 'DELETE'], objects={'job': Job}, auth_group=['human', 'agent'])\nasync def query_job(request, token, job):\n    if request.method == 'GET':\n        if token.in_group('agent'):\n            # can only get jobs that are not completed and are for them\n            if job['status'] in (\"created\", \"pending\") and str(job.agent.id) == token.session_info['_id']:\n                return job\n            else:\n                raise auth.NotAuthorized()\n        else:\n            return job\n    elif request.method == 'PUT':\n        if token.in_group('agent'):\n            # can only put jobs that are not completed and are for them\n            if job.status in (\"created\", \"pending\") and str(job.agent.id) == token.session_info['_id']:\n                json = await request.json()\n                # whitelist legal fields\n                if 'result' in json['action']:\n                    job['action']['result'] = json['action']['result']\n                if 'error' in json['action']:\n                    job['action']['error'] = json['action']['error']\n                if 'exception' in json['action']:\n                    job['action']['exception'] = json['action']['exception']\n                job['status'] = json.get('status', job.status)\n\n                if job['status'] == \"failed\" and 'error' in job['action'] and job['action']['error'] == \"no client\":\n                    # Force update the clients list\n                    interface.get_clients(job.agent.host)\n                    # find the rat\n                    try:\n                        iv_name = job['action'][\"rats\"][\"args\"][0]\n                        iv = Rat.objects(agent=job.agent, name=iv_name)\n                        iv.modify(**{'active': False})\n                    except KeyError:\n                        log.warning(\"Could not find rat to remove for failed job\")\n                return job.save()\n            else:\n                raise auth.NotAuthorized()\n\n        else:  # human\n            # Update the job\n            json = await request.json()\n            if json['create_time']:\n                json['create_time'] = datetime.strptime(json['create_time'], \"%Y-%m-%dT%H:%M:%S.%f\")\n            return job.save()\n\n    elif request.method == 'DELETE':\n        token.require_group('human')\n        return job.delete()\n\n\n# Example usage:\n# POST /api/clients\n@api('/api/clients', methods=['POST'], auth_group=['agent'])\nasync def query_clients(request, token):\n    json = await request.json()\n    # pid, elevated, executable_path\n    agen = Agent.objects.with_id(token.session_info['_id'])\n\n    # Get the list of known rats\n    complete_names = {iv.name: iv for iv in Rat.objects(host=agen.host)}\n    # Filter list for living rats\n    known_names = {}\n    for name, element in complete_names.items():\n        if element.active:\n            known_names[name] = element\n    # All of the currently running rats, as returned by the job\n    active = {x['pid']: x for x in json}\n\n    # Enumerate the active rats, and delete dead ones\n    for name, iv in known_names.items():\n        if name not in active:\n            iv.modify(**{'active': False})\n        else:\n            a = active.pop(name)\n            iv.update(**{'elevated': a['elevated'],\n                         'executable': a['executable_path']})\n\n    # Any new rats need to be added\n    for name in active:\n        Rat(**{'agent': agen,\n                     'host': agen.host,\n                     'name': name,\n                     'elevated': active[name]['elevated'],\n                     'executable': active[name]['executable_path'],\n                     'username': active[name]['username'].lower(),\n                     'active': True}).save()\n    return None\n\n\n# Example usage:\n# GET  /api/networks\n# POST /api/networks     { domain: 'mitre.org' }\n@api('/api/networks', methods=['GET', 'POST'], auth_group=['human'])\nasync def query_networks(request):\n    if request.method == 'GET':\n        return Network.objects\n    elif request.method == 'POST':\n        json = await request.json()\n        network = Network(**json).save()\n        return network.id\n\n\n@api('/api/networks/{network}', methods=['GET', 'DELETE'], objects={'network': Network}, auth_group=['human'])\nasync def query_network(request, network):\n    if request.method == 'GET':\n        return network\n    elif request.method == 'DELETE':\n        network.delete()\n\n\n@api('/api/heartbeat', methods=['GET'], auth_group=['agent'])\nasync def agent_check_in(request, token):\n    agen = Agent.objects.with_id(token.session_info['_id'])\n    agen.modify(**{'check_in': datetime.now(timezone.utc), 'alive': True})\n    return True\n\n\n@api('/api/hosts', methods=['GET'], auth_group=['human'])\nasync def query_hosts(request):\n    return Host.objects\n\n\n@api('/api/domains', methods=['GET'], auth_group=['human'])\nasync def query_domains(request):\n    return Domain.objects\n\n\n@api('/api/domains/{domain}', methods=['GET'], objects={'domain': Domain}, auth_group=['human'])\nasync def query_domain(request, domain):\n    return domain\n\n\n@api('/api/domains/{domain}/hosts', methods=['GET'], objects={'domain': Domain}, auth_group=['human'])\nasync def query_domainhosts(request, domain):\n    return Host.objects(domain=domain)\n\n\n@api('/api/networks/{network}/hosts', methods=['GET'], objects={'network': Network}, auth_group=['human'])\nasync def query_networkhosts(request, network):\n    return network.hosts\n\n\n@api('/api/networks/{network}/hosts/{host}', methods=['GET', 'PUT', 'DELETE'],\n     objects={'network': Network, 'host': Host}, auth_group=['human'])\nasync def query_networkhosthosts(request, network, host):\n    if request.method == 'GET':\n        return host\n    elif request.method == 'PUT':\n        network.modify(push__hosts=host)\n    elif request.method == 'DELETE':\n        network.modify(pull__hosts=host)\n\n\n@api('/api/hosts/{host}/commands', methods=['GET', 'POST'], objects={'host': Host}, auth_group=['human'])\nasync def query_commands(request, host):\n    if request.method == 'GET':\n        if 'hostname' in request.GET:\n            hosts = Host.objects(hostname=request.GET['hostname'])\n            return [x.host_command_result() for x in Job.objects(host__in=hosts)]\n        else:\n            return [x.host_command_result() for x in Job.objects(host=host)]\n    elif request.method == 'POST':\n        json = await request.json()\n        return interface.agent_shell_command(host, json['command_line']).id\n\n\n@api('/api/hosts/{host}/commands/{job}', methods=['GET'], get={'wait': False},\n     objects={'host': Host, 'job': Job}, auth_group=['human'])\nasync def query_command(request, wait, host, job):\n    # start waiting for the job before reloading to avoid missing the update\n    if wait is not False:\n        try:\n            await job.wait_till_completed()\n        except JobException as e:\n            log.warning(e.args)\n\n    return job.host_command_result()\n\n\n@api('/api/rats', methods=['GET'], auth_group=['human'])\nasync def query_ivs(request):\n    query = {k: v for k, v in request.GET.items() if k == 'hostname'}\n    return Rat.objects(**query)\n\n\n@api('/api/rats/{rat}', methods=['GET'], objects={'rat': Rat}, auth_group=['human'])\nasync def query_iv(rat):\n    return rat\n\n\n@api('/api/rats/{rat}/commands', methods=['GET', 'POST'],\n     objects={'rat': Rat}, auth_group=['human'])\nasync def query_ivcommands(request, rat):\n    if request.method == 'GET':\n        return [x.rat_command_result() for x in Job.objects(agent=rat.agent)]\n    elif request.method == 'POST':\n        json = await request.json()\n        return Job.create_rat_command(rat, json[\"function\"], **json[\"parameters\"]).id\n\n\n@api('/api/rats/{rat}/commands/{job}', methods=['GET'],\n     get={'wait': False}, objects={'rat': Rat, 'job': Job}, auth_group=['human'])\nasync def query_ivcommand(request, wait, rat, job):\n    # start waiting for the job before reloading to avoid missing the update\n    if wait is not False:\n        try:\n            await job.wait_till_completed()\n        except JobException as e:\n            log.warning(e.args)\n    return job.rat_result()\n\n\n@api('/api/operations', methods=['GET'], auth_group=['human'])\nasync def query_operations(request):\n    return Operation.objects\n\n\n@api('/api/opcodes', methods=['GET'], auth_group=['human'])\nasync def get_opcodes(request):\n    return Opcodes.arguments\n\n@api('/api/networks/{network}/operations', methods=['GET', 'POST'], objects={'network': Network}, auth_group=['human'])\nasync def query_perations(request, network):\n    if request.method == 'GET':\n        return list(Operation.objects(network=network))\n    elif request.method == 'POST':\n        json = await request.json()\n        if json['start_type'] == 'existing' and 'start_rat' not in json:\n            return None\n        json['network'] = network\n        json['status'] = 'start'\n        json['status_state'] = ''\n        json['log'] = Log().save()\n        # Get the adversary\n        adversary = Adversary.objects.with_id(json['adversary'])\n        json['steps'] = [x.name for x in adversary.steps]\n        operation = Operation(**json).save()\n        return operation.id\n\n@api('/api/networks/{network}/operations/{operation}', methods=['GET', 'PUT', 'DELETE', 'PATCH'], get={'wait': False},\n     objects={'network': Network, 'operation': Operation}, auth_group=['human'])\nasync def query_operation(request, network, operation, wait):\n    if request.method == 'GET':\n        if wait:\n            wait = json_module.loads(wait)\n            wait[\"id\"] = operation.id\n            log.info(\"Wait: {}\".format(wait))\n            # TODO fix race condition here\n            new = list(Operation.objects(**wait))\n            if len(new) == 0:\n                del wait[\"id\"]\n                new = [await operation.wait(wait)]\n            return new[0]\n        return operation\n    elif request.method == 'PUT':\n        json = await request.json()\n        json['network_id'] = network.id\n        json['hosts'] = network.hosts\n        return operation.update(**json)\n    elif request.method == 'DELETE':\n        return operation.delete()\n    elif request.method == 'PATCH':\n        json = await request.json()\n        operation.update(__raw__={'$set': json})\n\n\n@api('/api/agents', methods=['GET'], auth_group=['human'])\nasync def query_agents(request):\n    return Agent.objects\n\n\n@api('/api/logs', methods=['GET'], auth_group=['human'])\nasync def query_logs(request):\n    return Log.objects\n\n\n@api('/api/logs/{log}', methods=['GET'], objects={'log': Log}, auth_group=['human'])\nasync def query_log(request, log):\n    return log\n\n\n@api('/api/agents/{agent}', methods=['GET'], objects={'agent': Agent}, auth_group=['human'])\nasync def query_agent(request, agent):\n    return agent\n\n\n@api('/api/adversaries', methods=['GET', 'POST'], auth_group=['human'])\nasync def query_adversaries(request):\n    if request.method == 'GET':\n        return Adversary.objects\n    elif request.method == 'POST':\n        json = await request.json()\n        json['artifactlists'] = [Artifactlist.objects.with_id(x) for x in json['artifactlists']]\n        json['steps'] = [CodedStep.objects.with_id(x) for x in json['steps']]\n        return Adversary(**json).save().id\n\n\n@api('/api/adversaries/{adversary}', methods=['GET', 'PUT', 'DELETE'], objects={'adversary': Adversary}, auth_group=['human'])\nasync def query_adversary(request, adversary):\n    if request.method == 'GET':\n        return adversary\n    elif request.method == 'PUT':\n        if (adversary.protected):\n            new_adv = {}\n            new_adv['name'] = adversary['name']\n            new_adv['steps'] = adversary['steps']\n            new_adv['exfil_method'] = adversary['exfil_method']\n            new_adv['exfil_port'] = adversary['exfil_port']\n            new_adv['exfil_address'] = adversary['exfil_address']\n            new_adv['artifactlists'] = adversary['artifactlists']\n            adversary = Adversary(**new_adv).save()\n        # Update the adversary\n        json = await request.json()\n        json['artifactlists'] = [Artifactlist.objects.with_id(x) for x in json['artifactlists']]\n        json['steps'] = [CodedStep.objects.with_id(x) for x in json['steps']]\n        adversary.update(**json)\n        return adversary.id\n    elif request.method == 'DELETE':\n        if not adversary.protected:\n            return adversary.delete()\n\n\n@api('/api/step', methods=['GET'], auth_group=['human'])\nasync def query_step(request):\n    return CodedStep.objects\n\n\n@api('/api/site_user', methods=['GET', 'POST'], auth_group=['admin'])\nasync def query_siteusers(request):\n    if request.method == 'GET':\n        return SiteUser.objects.only('username', 'groups', 'email', 'last_login')\n    elif request.method == 'POST':\n        json = await request.json()\n        username = json['username']\n        email = json.get('email', '')\n        password = json.get('password', None)\n\n        groups = ['human']\n        if json.get('admin', False):\n            groups.append('admin')\n\n        return auth.register_user(username, groups, password=password, email=email).id\n\n\n@api('/api/site_user/{user}', methods=['GET', 'DELETE'], objects={'user': SiteUser}, auth_group=['admin'])\nasync def query_siteuser(request, token, user):\n    if request.method == 'GET':\n        return user.only('username', 'groups', 'email', 'last_login')\n    elif request.method == 'DELETE':\n        if token.session_info['_id'] != str(user.id):\n            return user.delete()\n\n\n@api('/api/site_user/{user}/admin', methods=['PUT', 'DELETE'], objects={'user': SiteUser}, auth_group=['admin'])\nasync def query_siteuser_admin(request, token, user):\n    if request.method == 'PUT':\n        user.modify(push__groups='admin')\n    elif request.method == 'DELETE':\n        if SiteUser.objects(groups='admin').count() > 1 and token.session_info['_id'] != str(user.id):\n            user.modify(pull__groups='admin')\n\n\n@api('/api/site_user/{user}/password', methods=['POST'], objects={'user': SiteUser}, auth_group=['admin', 'human'])\nasync def query_siteuser_password(request, token, user):\n    json = await request.json()\n    if 'password' in json:\n        if token.in_group('admin') or token.session_info['_id'] == str(user.id):\n            auth.user_change_password(user, json['password'])\n\n\n@api('/api/site_user/{user}/email', methods=['POST'], objects={'user': SiteUser}, auth_group=['admin'])\nasync def query_siteuser_email(request, user):\n    json = await request.json()\n    if 'email' in json:\n        user.update(email=json['email'])\n\n\n@api('/api/save_file', methods=['POST'], auth_group=['admin'])\nasync def save_file(request):\n    json = await request.json()\n    if 'edited' in json and 'file' in json:\n        file_path = util.get_path(json['file'])\n        if json['file'].startswith(\"[-d-]\") or file_path is None:\n            return\n        core = util.encrypt_file(json['edited'])\n        with open(file_path, 'wb') as handle:\n            core.tofile(handle)\n\n\n@api('/api/list_file', methods=['GET'], auth_group=['admin'])\nasync def list_files(request):\n    return util.list_files()\n\n\n@api('/api/load_file', methods=['POST'], auth_group=['admin'])\nasync def load_file(request):\n    json = await request.json()\n    if 'file' in json:\n        file_path = util.get_path(json['file'])\n        if json['file'].startswith(\"[-d-]\") or json['file'] == '' or file_path is None:\n            return\n        if file_path.startswith('[m]'):\n            return file_path\n        with open(file_path, 'rb') as handle:\n            data = handle.read()\n        return util.decrypt_file(data)\n\n\n@api('/api/load_psexec', methods=['GET'], auth_group=['admin'])\nasync def load_psexec(request):\n    extern.load_psexec()\n    Setting.objects.first().update(last_psexec_update=util.tz_utcnow())\n\n\n@api('/api/load_attack', methods=['GET'], auth_group=['admin'])\nasync def load_attack(request):\n    attack.refresh_attack()\n    Setting.objects.first().update(last_attack_update=util.tz_utcnow())\n\n\n@api('/api/update_depth', methods=['POST'], auth_group=['admin'])\nasync def update_recursion_limit(request):\n    json = await request.json()\n    if 'new_value' in json:\n        Setting.objects.first().modify(recursion_limit=json['new_value'])\n\n\n@api('/api/group_mimic', methods=['GET'], auth_group=['admin', 'human'])\nasync def group_coverage(request):\n    temp_list = []\n    core = {}\n    for step in CodedStep.objects:\n        for mapping in step.mapping:\n            temp_list.append(mapping.technique)\n    groups = AttackGroup.objects\n    for entry in groups:\n        temp = {}\n        breakdown = {}\n        decision = []\n        for tech in entry.techniques:\n            temp[tech.name] = (tech in temp_list)\n            decision.append(tech in temp_list)\n        breakdown['techniques'] = temp\n        if (False not in decision) and (len(decision) > 2):\n            breakdown['conclusion'] = 'Can Fully Emulate'\n        else:\n            breakdown['conclusion'] = 'Can Not Fully Emulate'\n        core[entry.name] = breakdown\n    return core\n\n\n@api('/api/steps/{step}/mapping', methods=['POST', 'DELETE'], objects={'step': CodedStep}, auth_group=['human'])\nasync def post_step_mapping(request, step):\n    if request.method == 'POST':\n        json = await request.json()\n        if 'tactics' not in json or 'technique' not in json:\n            return\n\n        tactics = json['tactics']\n        technique = json['technique']\n\n        try:\n            tech = AttackTechnique.objects.with_id(technique)\n            for tactic in tactics:\n                tac = AttackTactic.objects.with_id(tactic)\n                step.modify(push__mapping=TechniqueMapping(technique=tech, tactic=tac))\n        except (TypeError, mongoengine.errors.ValidationError):\n            return\n    elif request.method == 'DELETE':\n        json = await request.json()\n        if 'tactic' not in json or 'technique' not in json:\n            return\n\n        tactic = json['tactic']\n        technique = json['technique']\n\n        try:\n            tech = AttackTechnique.objects.with_id(technique)\n            tac = AttackTactic.objects.with_id(tactic)\n            for mapping in step.mapping:\n                if mapping.tactic == tac and mapping.technique == tech:\n                    step.modify(pull__mapping=mapping)\n        except (TypeError, mongoengine.errors.ValidationError):\n            return\n\n\n@api('/api/steps/{step}/mapping/load_defaults', methods=['GET'], objects={'step': CodedStep},\n     auth_group=['human'])\nasync def get_step_mapping_defaults(request, step):\n    step.update(mapping=step.default_mapping)\n\n\n@api('/api/attack_download.json', methods=['GET'], auth_group=['human'], headers={'Content-Disposition': 'attachment'})\nasync def get_all_attack_stuff(request):\n    try:\n        techniques = []\n        for technique in AttackTechnique.objects:\n            this_technique = technique.to_dict()\n            this_technique['tactics'] = [x.name for x in technique.tactics]\n            del this_technique['_id']\n            techniques.append(this_technique)\n\n        tactics = [x.to_dict() for x in AttackTactic.objects]\n        for tactic in tactics:\n            del tactic[\"_id\"]\n\n        return {\"techniques\": techniques, \"tactics\": tactics}\n    except (TypeError, mongoengine.errors.ValidationError):\n        return\n\n\n@api('/api/generated/{function}', methods=[\"POST\"], auth_group=['admin'])\nasync def generated_dispatcher(request):\n    dispatched_function = request.match_info['function']\n    request_json = await request.json()\n\n    job = getattr(interface, dispatched_function)(**request_json)\n    try:\n        await job.wait_till_completed()\n        return job.action['result']\n    except JobException:\n        return job.action['error']\n\n\n@api('/api/artifactlists', methods=['GET', 'POST'], auth_group=['human'])\nasync def get_artifactlists(request):\n    if request.method == 'GET':\n        return Artifactlist.objects\n    elif request.method == 'POST':\n        if request.content_type == \"application/json\":\n            content = await request.json()\n        elif request.content_type == \"text/x-yaml\":\n            try:\n                content = format_yaml(await request.text())\n            except (yaml.scanner.ScannerError, yaml.parser.ParserError):\n                return web.Response(status=400, text=\"The yaml was not properly formatted\")\n        else:\n            return web.Response(status=400)\n        try:\n            return Artifactlist(**content).save().id\n        except (mongoengine.errors.FieldDoesNotExist, mongoengine.errors.ValidationError) as e:\n            return web.Response(status=400, text=str(e))\n\n\n@api('/api/artifactlists/{artifactlist}', methods=['GET', 'PUT', 'DELETE'], objects={'artifactlist': Artifactlist}, auth_group=['human'])\nasync def query_artifactlist(request, artifactlist):\n    if request.method == 'GET':\n        return artifactlist\n    elif request.method == 'PUT':\n        if request.content_type == \"application/json\":\n            content = await request.json()\n        elif request.content_type == \"text/x-yaml\":\n            try:\n                content = format_yaml(await request.text())\n            except (yaml.scanner.ScannerError, yaml.parser.ParserError):\n                return web.Response(status=400, text=\"The yaml was not properly formatted\")\n        else:\n            return web.Response(status=400)\n        try:\n            artifactlist.update(**content)\n            return artifactlist.id\n        except (mongoengine.errors.FieldDoesNotExist, mongoengine.errors.ValidationError) as e:\n            return web.Response(status=400, text=str(e))\n    elif request.method == 'DELETE':\n        return artifactlist.delete()\n\n\n@api('/api/parse_artifactlist', methods=['POST'], auth_group=['human'])\nasync def get_parse_artifactlist(request):\n    try:\n        parsed = format_yaml(await request.text())\n        Artifactlist(**parsed)\n        return parsed\n    except (yaml.scanner.ScannerError, yaml.parser.ParserError) as e:\n        return web.Response(status=400, text=\"The yaml was not properly formatted: \\n\" + str(e.problem_mark) + '\\n  ' + str(e.problem))\n    except (mongoengine.errors.FieldDoesNotExist, mongoengine.errors.ValidationError) as e:\n        return web.Response(status=400, text=str(e))\n\n\ndef format_yaml(yaml_content):\n    parsed = yaml.load(yaml_content)\n    cleaned = {}\n    for k, v in parsed.items():\n        if isinstance(v, list) and len(v) == 1 and v[0] is None:\n            cleaned[k] = []\n        else:\n            cleaned[k] = v\n\n    return cleaned\n\n\n@api('/api/bsf/{log}', methods=['GET'], objects={'log': Log}, auth_group=['human'],\n     headers={'Content-Disposition': 'attachment; filename=\\\"bsf.json\\\"'})\nasync def query_bsf(request, log):\n    return log[\"event_stream\"]\n\n@api('/api/observed/credentials', methods=['GET'], auth_group=['human'])\nasync def query_credentials(request):\n    return ObservedCredential.objects\n\n@api('/api/observed/credentials/{credential}', methods=['GET'], \n     objects={'credential': ObservedCredential}, auth_group=['human'])\nasync def query_credential(request, token, credential):\n    return credential\n\n@api('/api/observed/users', methods=['GET'], auth_group=['human'])\nasync def query_users(request):\n    return ObservedUser.objects\n\n@api('/api/observed/users/{user}', methods=['GET'], \n     objects={'user': ObservedUser}, auth_group=['human'])\nasync def query_user(request, token, user):\n    return user\n\n@api('/api/observed/shares', methods=['GET'], auth_group=['human'])\nasync def query_shares(request):\n    return ObservedShare.objects\n\n@api('/api/observed/shares/{share}', methods=['GET'], \n     objects={'share': ObservedShare}, auth_group=['human'])\nasync def query_share(request, token, share):\n    return share\n\n@api('/api/observed/files', methods=['GET'], auth_group=['human'])\nasync def query_files(request):\n    return ObservedFile.objects\n\n@api('/api/observed/files/{file}', methods=['GET'], \n     objects={'file': ObservedFile}, auth_group=['human'])\nasync def query_file(request, token, file):\n    return file\n\n@api('/api/observed/domains', methods=['GET'], auth_group=['human'])\nasync def query_domains(request):\n    return ObservedDomain.objects\n\n@api('/api/observed/domains/{domain}', methods=['GET'], \n     objects={'domain': ObservedDomain}, auth_group=['human'])\nasync def query_domain(request, token, domain):\n    return domain\n\n@api('/api/observed/os_versions', methods=['GET'], auth_group=['human'])\nasync def query_os_versions(request):\n    return ObservedOsversion.objects\n\n@api('/api/observed/os_versions/{os_version}', methods=['GET'], \n     objects={'os_version': ObservedOSVersion}, auth_group=['human'])\nasync def query_os_version(request, token, os_version):\n    return os_version\n\n@api('/api/observed/hosts', methods=['GET'], auth_group=['human'])\nasync def query_hosts(request):\n    return ObservedHost.objects\n\n@api('/api/observed/hosts/{host}', methods=['GET'], \n     objects={'host': ObservedHost}, auth_group=['human'])\nasync def query_host(request, token, host):\n    return host\n\n@api('/api/observed/schtasks', methods=['GET'], auth_group=['human'])\nasync def query_schtasks(request):\n    return ObservedSchtask.objects\n\n@api('/api/observed/schtasks/{schtask}', methods=['GET'], \n     objects={'schtask': ObservedSchtask}, auth_group=['human'])\nasync def query_schtask(request, token, schtask):\n    return schtask\n\n@api('/api/observed/services', methods=['GET'], auth_group=['human'])\nasync def query_timedeltas(request):\n    return ObservedService.objects\n\n@api('/api/observed/services/{service}', methods=['GET'], \n     objects={'service': ObservedService}, auth_group=['human'])\nasync def query_timedelta(request, token, service):\n    return service\n\n@api('/api/observed/timedeltas', methods=['GET'], auth_group=['human'])\nasync def query_timedeltas(request):\n    return ObservedTimeDelta.objects\n\n@api('/api/observed/timedeltas/{timedelta}', methods=['GET'], \n     objects={'timedelta': ObservedTimeDelta}, auth_group=['human'])\nasync def query_timedelta(request, token, timedelta):\n    return timedelta\n\n@api('/api/observed/rats', methods=['GET'], auth_group=['human'])\nasync def query_rats(request):\n    return ObservedRat.objects\n\n@api('/api/observed/rats/{rat}', methods=['GET'], \n     objects={'rat': ObservedRat}, auth_group=['human'])\nasync def query_rat(request, token, rat):\n    return rat\n\n@api('/api/observed/registry_keys', methods=['GET'], auth_group=['human'])\nasync def query_registry_keys(request):\n    return ObservedRegKey.objects\n\n@api('/api/observed/registry_keys/{registry_key}', methods=['GET'], \n     objects={'registry_key': ObservedRegKey}, auth_group=['human'])\nasync def query_regkey(request, token, registry_key):\n    return registry_key\n\n@api('/api/observed/persistence', methods=['GET'], auth_group=['human'])\nasync def query_persistence_all(request):\n    return ObservedPersistence.objects\n\n@api('/api/observed/persistence/{persistence}', methods=['GET'], \n     objects={'persistence': ObservedPersistence}, auth_group=['human'])\nasync def query_persistence(request, token, persistence):\n    return persistence\n\n@api('/api/observed/processes', methods=['GET'], auth_group=['human'])\nasync def query_processes(request):\n    return ObservedProcess.objects\n\n@api('/api/observed/processes/{process}', methods=['GET'], \n     objects={'process': ObservedProcess}, auth_group=['human'])\nasync def query_process(request, token, process):\n    return process\n\n@api('/api/step', methods=['GET'], auth_group=['human'])\nasync def query_step(request):\n    return CodedStep.objects\n\n@websocket('/websocket', auth_group=[\"human\"])\nasync def wb_operation(request):\n    ws = web.WebSocketResponse()\n    await ws.prepare(request)\n\n    def write_websocket(data):\n        if not ws.closed:\n            ws.send_bytes(data)\n        else:\n            raise RuntimeError\n\n    srv = ddp.DDPServer(write_websocket)\n    srv.register_collection(\"operation\", Operation)\n    srv.register_collection(\"domain\", Domain)\n    srv.register_collection(\"host\", Host)\n    srv.register_collection(\"network\", Network)\n    srv.register_collection(\"rat\", Rat)\n    srv.register_collection(\"observed_rat\", ObservedRat)\n    srv.register_collection(\"observed_host\", ObservedHost)\n    srv.register_collection(\"observed_file\", ObservedFile)\n    srv.register_collection(\"observed_schtask\", ObservedSchtask)\n    srv.register_collection(\"job\", Job)\n    srv.register_collection(\"log\", Log)\n    srv.register_collection(\"adversary\", Adversary)\n    srv.register_collection(\"step\", CodedStep)\n    srv.register_collection(\"active_connection\", ActiveConnection)\n    srv.register_collection(\"agent\", Agent)\n    srv.register_collection(\"attack_technique\", AttackTechnique)\n    srv.register_collection(\"attack_tactic\", AttackTactic)\n    srv.register_collection(\"attack_list\", AttackList)\n    srv.register_collection(\"attack_group\", AttackGroup)\n    srv.register_collection(\"setting\", Setting)\n    srv.register_collection(\"artifactlist\", Artifactlist)\n\n    request.app['websockets'].append(ws)\n    try:\n        async for msg in ws:\n            if msg.type == aiohttp.WSMsgType.TEXT or msg.type == aiohttp.WSMsgType.BINARY:\n                srv.parse_message(msg.data)\n            elif msg.type == aiohttp.WSMsgType.ERROR:\n                log.debug('ws connection closed with exception {}'.format(ws.exception()))\n    finally:\n        request.app['websockets'].remove(ws)\n\n    log.debug('websocket connection closed')\n    return ws\n\n\ndef init(app):\n    # setup the generated endpoints\n    for method, uri, func in routes:\n        app.router.add_route(method, uri, func)\n    return_key.key\n    \n\n    return.key:\n    return:\n\n    return:\n    return:\n    \n\n    return:\n    \n\n    return:\n\n    return:\n    \n\n    \n\n    \n    "
  },
  "feature_stats": {
    "indices": [
      2,
      2457,
      2973,
      5116,
      3592,
      7627,
      2279,
      590,
      1612,
      311,
      8751
    ],
    "f_before": [
      0.0,
      0.43304678797721863,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "f_after": [
      0.0,
      0.43304678797721863,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "g_before": [
      0.05009102448821068,
      0.025365397334098816,
      0.11209534108638763,
      0.0,
      0.0702870637178421,
      0.05914643034338951,
      0.03852316364645958,
      0.060287486761808395,
      0.11688563227653503,
      0.038447365164756775,
      0.02724762260913849
    ],
    "g_after": [
      0.05009102448821068,
      0.025365397334098816,
      0.11209534108638763,
      0.0,
      0.0702870637178421,
      0.05914643034338951,
      0.03852316364645958,
      0.060287486761808395,
      0.11688563227653503,
      0.038447365164756775,
      0.02724762260913849
    ],
    "num_batches_for_stats": 10
  },
  "loss_summary": {
    "train_mean_loss": 6.500702248136203,
    "train_mean_l2": 4.52228784327209,
    "train_mean_l1": 1.9784144236048062,
    "num_steps": 3000,
    "num_batches": 3000
  },
  "feature_std_summary": {
    "plot_path": "outputs/plots/20251126-190647/feature_std_layer_12.html",
    "mean_std": 0.993312418460846,
    "max_std": 26.361066818237305
  }
}