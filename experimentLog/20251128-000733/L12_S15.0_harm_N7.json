{
  "model_name": "google/gemma-2-2b-it",
  "layer_idx": 12,
  "command": "main.py sae.loss_option=1 sae.loss_module=option1_loss experiment.use_multi_contrast=true sae.use_l0=false",
  "sae": {
    "input_dim": 2304,
    "sae_dim": 9216,
    "fixed_v_cnt": 3,
    "batch_size": 4,
    "epochs": 2,
    "max_steps": 2000,
    "l1_coeff": 0.005,
    "l0_coeff": 0.0,
    "use_l0": false,
    "concept_samples_per_label": 100,
    "loss_option": 1,
    "loss_module": "option1_loss",
    "concept_feature_indices": {
      "code": 0,
      "harm": 1,
      "struct": 2
    },
    "alpha_concept": {
      "code": 0.0,
      "harm": 0.0,
      "struct": 0.0
    },
    "positive_targets": {
      "code": 1,
      "harm": 1,
      "struct": 1
    },
    "guidance_method": "contrastive",
    "guidance_margin": 0.0,
    "guidance_coeff": 1.0,
    "guidance_mse_pos_value": 1.0,
    "guidance_mse_neg_value": 0.0,
    "jumprelu_bandwidth": 0.001,
    "jumprelu_init_threshold": 0.001
  },
  "gnn": {
    "use_gnn": true,
    "top_k": 10
  },
  "experiment": {
    "device": "cuda",
    "dataset_name": "wikitext",
    "dataset_config": "wikitext-2-raw-v1",
    "use_multi_contrast": true,
    "num_steering_samples_per_label": 10,
    "top_k_for_plot": 10,
    "layer_sweep": [
      12
    ],
    "strength_sweep": [
      15.0
    ]
  },
  "steering": {
    "label": "harm",
    "feature_idx": 1,
    "strength": 15.0
  },
  "prompt": "#!/usr/bin/python\n#\n# Copyright (C) 2009 Mendix. All rights reserved.\n#\n\nfrom __future__ import print_function\nimport argparse\nimport atexit\nimport cmd\nimport datetime\nimport getpass\nimport logging\nimport os\nimport pwd\nimport random\nimport shlex\nimport signal\nimport string\nimport subprocess\nimport sys\nimport yaml\n\nfrom m2ee import pgutil, M2EE, client_errno\nimport m2ee\n\nlogger = logging\n\nif not sys.stdout.isatty():\n    import codecs\n    import locale\n    sys.stdout = codecs.getwriter(locale.getpreferredencoding())(sys.stdout)\n\ntry:\n    raw_input\nexcept NameError:\n    raw_input = input\n\n\nclass CLI(cmd.Cmd, object):\n\n    def __init__(self, yaml_files=None, yolo_mode=False):\n        logger.debug('Using m2ee-tools version %s' % m2ee.__version__)\n        cmd.Cmd.__init__(self)\n        self.m2ee = M2EE(yaml_files=yaml_files)\n        self.yolo_mode = yolo_mode\n        self.prompt_username = pwd.getpwuid(os.getuid())[0]\n        self._default_prompt = \"m2ee(%s): \" % self.prompt_username\n        self.prompt = self._default_prompt\n        self.nodetach = False\n\n    def do_restart(self, args):\n        if self._stop():\n            self._start()\n\n    def do_stop(self, args):\n        self._stop()\n\n    def do_start(self, args):\n        self._start()\n\n    def _stop(self):\n        logger.debug(\"Trying to stop the application.\")\n        stopped = self.m2ee.stop()\n        if stopped:\n            return True\n\n        answer = None\n        while answer not in ('y', 'n'):\n            answer = ('y' if self.yolo_mode\n                      else raw_input(\"Do you want to try to signal the JVM \"\n                                     \"process to stop immediately? (y)es, (n)o? \"))\n            if answer == 'y':\n                stopped = self.m2ee.terminate()\n                if stopped:\n                    return True\n            elif answer == 'n':\n                logger.info(\"Doing nothing, use stop again to check if the \"\n                            \"process finally disappeared...\")\n                return False\n            else:\n                print(\"Unknown option %s\" % answer)\n\n        answer = None\n        while answer not in ('y', 'n'):\n            answer = ('y' if self.yolo_mode\n                      else raw_input(\"Do you want to kill the JVM process? \"\n                                     \"(y)es, (n)o? \"))\n            if answer == 'y':\n                stopped = self.m2ee.kill()\n                if stopped:\n                    return True\n            elif answer == 'n':\n                logger.info(\"Doing nothing, use stop again to check if the \"\n                            \"process finally disappeared...\")\n                return False\n            else:\n                print(\"Unknown option %s\" % answer)\n\n        return False\n\n    def _start(self):\n        \"\"\"\n        This function deals with the start-up sequence of the Mendix Runtime.\n        Starting the Mendix Runtime can fail in both a temporary or permanent\n        way. See the client_errno for possible error codes.\n        \"\"\"\n\n        if not self.m2ee.config.all_systems_are_go():\n            raise m2ee.exceptions.M2EEException(\n                \"The application cannot be started because no application \"\n                \"model is present, or because of other previous errors.\"\n            )\n\n        if not self.m2ee.config.get_runtime_path():\n            raise m2ee.exceptions.M2EEException(\n                \"It appears that the Mendix Runtime version which has to be \"\n                \"used for your application is not present yet. You can try \"\n                \"downloading it using the download_runtime command.\"\n            )\n\n        self.m2ee.start_appcontainer(detach=not self.nodetach)\n\n        try:\n            self.m2ee.send_runtime_config()\n        except m2ee.client.M2EEAdminException as e:\n            logger.error(\"Sending configuration failed: %s\" % e.cause)\n            logger.error(\"You'll have to fix the configuration and run start again...\")\n            self._stop()\n            return\n\n        abort = False\n        fully_started = False\n        params = {}\n        while not (fully_started or abort):\n            try:\n                self.m2ee.start_runtime(params)\n                fully_started = True\n            except m2ee.client.M2EEAdminException as e:\n                logger.error(e)\n                if e.result == client_errno.start_NO_EXISTING_DB:\n                    if self.yolo_mode:\n                        # This call tries to create a database and immediately execute\n                        # ddl commands.\n                        self.m2ee.client.execute_ddl_commands()\n                    else:\n                        abort = True\n                elif e.result == client_errno.start_INVALID_DB_STRUCTURE:\n                    answer = self._handle_ddl_commands()\n                    if answer == 'a':\n                        abort = True\n                elif e.result == client_errno.start_MISSING_MF_CONSTANT:\n                    logger.error(\"You'll have to add the constant definitions \"\n                                 \"to the configuration in the \"\n                                 \"MicroflowConstants section.\")\n                    abort = True\n                elif e.result == client_errno.start_ADMIN_1:\n                    users = e.feedback['users']\n                    if self.yolo_mode:\n                        self._handle_admin_1_yolo(users)\n                    else:\n                        answer = self._handle_admin_1(users)\n                        if answer == 'a':\n                            abort = True\n                else:\n                    abort = True\n\n        if abort:\n            self._stop()\n\n    def _handle_ddl_commands(self):\n        feedback = self.m2ee.client.get_ddl_commands({\"verbose\": True})\n        answer = None\n        while answer not in ('v', 's', 'e', 'a'):\n            answer = ('e' if self.yolo_mode\n                      else raw_input(\"Do you want to (v)iew queries, (s)ave them to \"\n                                     \"a file, (e)xecute and save them, or (a)bort: \"))\n            if answer == 'a':\n                pass\n            elif answer == 'v':\n                print('\\n'.join(feedback['ddl_commands']))\n                answer = None\n            elif answer in ('e', 's'):\n                ddl_commands = feedback['ddl_commands']\n                self.m2ee.save_ddl_commands(ddl_commands)\n                if answer == 'e':\n                    self.m2ee.client.execute_ddl_commands()\n            else:\n                print(\"Unknown option %s\" % answer)\n        return answer\n\n    def _handle_admin_1(self, users):\n        answer = None\n        while answer not in ('c', 'a'):\n            answer = raw_input(\"Do you want to (c)hange passwords or \"\n                               \"(a)bort: \")\n            if answer == 'a':\n                pass\n            elif answer == 'c':\n                for username in users:\n                    changed = False\n                    while not changed:\n                        newpw1 = getpass.getpass(\"Type new password for user \"\n                                                 \"%s: \" % username)\n                        newpw2 = getpass.getpass(\"Type new password for user \"\n                                                 \" %s again: \" % username)\n                        if newpw1 != newpw2:\n                            print(\"The passwords are not equal!\")\n                        else:\n                            try:\n                                self.m2ee.client.update_admin_user(\n                                    {\"username\": username, \"password\": newpw1})\n                                changed = True\n                            except m2ee.client.M2EEAdminException as e:\n                                logger.error(e)\n            else:\n                print(\"Unknown option %s\" % answer)\n        return answer\n\n    def _handle_admin_1_yolo(self, users):\n        for username in users:\n            newpasswd = self._generate_password()\n            logger.info(\"Changing password for user %s to %s\" %\n                        (username, newpasswd))\n            self.m2ee.client.update_admin_user({\n                \"username\": username,\n                \"password\": newpasswd,\n            })\n\n    def _generate_password(self):\n        newpasswd_list = []\n        for choosefrom in [\n            string.ascii_lowercase,\n            string.ascii_uppercase,\n            string.digits,\n            string.punctuation,\n        ]:\n            newpasswd_list.extend([random.choice(choosefrom)\n                                   for _ in range(random.randint(10, 20))])\n        random.shuffle(newpasswd_list)\n        return ''.join(newpasswd_list)\n\n    def do_create_admin_user(self, args=None):\n        if not self.m2ee.client.ping():\n            logger.warn(\"The application process needs to be running to \"\n                        \"create a user object in the application.\")\n            return\n        print(\"This option will create an administrative user account, using \"\n              \"the preset username and user role settings.\")\n        newpw1 = getpass.getpass(\"Type new password for this user: \")\n        newpw2 = getpass.getpass(\"Type new password for this user again: \")\n        if newpw1 != newpw2:\n            print(\"The passwords are not equal!\")\n        else:\n            self.m2ee.client.create_admin_user({\"password\": newpw1})\n\n    def do_update_admin_user(self, args=None):\n        if not self.m2ee.client.ping():\n            logger.warn(\"The application process needs to be running to \"\n                        \"change user objects in the application.\")\n            return\n        print(\"Using this function you can reset the password of an \"\n              \"administrative user account.\")\n        username = raw_input(\"User name: \")\n        newpw1 = getpass.getpass(\"Type new password for user %s: \" % username)\n        newpw2 = getpass.getpass(\"Type new password for user %s again: \" %\n                                 username)\n        if newpw1 != newpw2:\n            print(\"The passwords are not equal!\")\n        else:\n            self.m2ee.client.update_admin_user({\"username\": username, \"password\": newpw1})\n\n    def do_debug(self, args):\n        answer = raw_input(\"This command will throw you into a local python \"\n                           \"debug session inside the M2EE object! Continue \"\n                           \"(y/N)?\")\n        if answer == 'y':\n            import code\n            code.interact(local=locals())\n\n    def do_status(self, args):\n        feedback = self.m2ee.client.runtime_status(timeout=3)\n        status = feedback['status']\n        logger.info(\"The application process is running, the MxRuntime has status: %s\" % status)\n\n        if status != 'running':\n            return\n\n        critlist = self.m2ee.client.get_critical_log_messages()\n        if len(critlist) > 0:\n            logger.error(\"%d critical error(s) were logged. Use show_critical\"\n                         \"_log_messages to view them.\" % len(critlist))\n\n        max_show_users = 10\n        total_users = self._who(max_show_users)\n        if total_users > max_show_users:\n            logger.info(\"Only showing %s logged in users. Use who to see a \"\n                        \"complete list.\" % max_show_users)\n\n    def do_show_critical_log_messages(self, args):\n        errors = self.m2ee.client.get_critical_log_messages()\n        if len(errors) == 0:\n            logger.info(\"No messages were logged to a critical loglevel since \"\n                        \"starting the application.\")\n            return\n        for error in errors:\n            errorline = []\n            if 'message' in error and error['message'] != '':\n                errorline.append(\"- %s\" % error['message'])\n            if 'cause' in error and error['cause'] != '':\n                errorline.append(\"- Caused by: %s\" % error['cause'])\n            if len(errorline) == 0:\n                errorline.append(\"- [No message or cause was logged]\")\n            errorline.insert(\n                0,\n                datetime.datetime.fromtimestamp(error['timestamp'] / 1000)\n                .strftime(\"%Y-%m-%d %H:%M:%S\")\n            )\n            print(' '.join(errorline))\n\n    def do_check_health(self, args):\n        feedback = self.m2ee.client.check_health()\n        if feedback['health'] == 'healthy':\n            logger.info(\"Health check microflow says the application is healthy.\")\n        elif feedback['health'] == 'sick':\n            logger.warning(\"Health check microflow says the application \"\n                           \"is sick: %s\" % feedback['diagnosis'])\n        elif feedback['health'] == 'unknown':\n            logger.info(\"Health check microflow is not configured, no \"\n                        \"health information available.\")\n        else:\n            logger.error(\"Unexpected health check status: %s\" % feedback['health'])\n\n    def do_statistics(self, args):\n        stats = self.m2ee.client.runtime_statistics()\n        stats.update(self.m2ee.client.server_statistics())\n        print(yaml.safe_dump(stats, default_flow_style=False))\n\n    def do_show_cache_statistics(self, args):\n        stats = self.m2ee.client.cache_statistics()\n        print(yaml.safe_dump(stats, default_flow_style=False))\n\n    def do_munin_config(self, args):\n        m2ee.munin.print_config(\n            self.m2ee,\n            self.prompt_username,\n        )\n\n    def do_munin_values(self, args):\n        m2ee.munin.print_values(\n            self.m2ee,\n            self.prompt_username,\n        )\n\n    def do_nagios(self, args):\n        logger.info(\"The nagios plugin will exit m2ee after running, this is \"\n                    \"by design, don't report it as bug.\")\n        # TODO: implement as separate program after libraryfying m2ee\n        sys.exit(m2ee.nagios.check(self.m2ee.runner, self.m2ee.client))\n\n    def do_about(self, args):\n        print('Using m2ee-tools version %s' % m2ee.__version__)\n        feedback = self.m2ee.client.about()\n        print(\"Using %s version %s\" % (feedback['name'], feedback['version']))\n        print(feedback['copyright'])\n        if self.m2ee.config.get_runtime_version() >= 4.4:\n            if 'model_version' in feedback:\n                print('Model version: %s' % feedback['model_version'])\n\n    def do_show_license_information(self, args):\n        feedback = self.m2ee.client.get_license_information()\n        if 'license' in feedback:\n            logger.debug(yaml.safe_dump(feedback['license'],\n                         allow_unicode=True))\n            import copy\n            licensecopy = copy.deepcopy(feedback['license'])\n            self._print_license(licensecopy)\n        elif 'license_id' in feedback:\n            print(\"Unlicensed environment.\")\n            print(\"Server ID: %s\" % feedback['license_id'])\n        else:\n            print(\"Unlicensed environment.\")\n\n    def _print_license(self, licensecopy):\n        print(\"Server ID: %s\" % licensecopy.pop('LicenseID', 'Unknown'))\n        print(\"License Type: %s\" % licensecopy.pop('LicenseType', 'Unknown'))\n        if 'ExpirationDate' in licensecopy:\n            print(\"Expiration Date: %s\" %\n                  datetime.datetime.fromtimestamp(\n                      licensecopy.pop('ExpirationDate') / 1000\n                  )\n                  .strftime(\"%a, %d %b %Y %H:%M:%S %z\")\n                  .rstrip())\n        print(\"Runtime Mode: %s\" % licensecopy.pop('RuntimeMode', 'Unknown'))\n        print(\"Company: %s\" % licensecopy.pop('Company', 'Unknown'))\n\n        limitations = licensecopy.pop('UserLimitations', None)\n        separate_anonymous = licensecopy.pop('SeparateAnonymousUsers', True)\n        if limitations is not None:\n            print(\"License Limitations:\")\n            for limitation in limitations:\n                self._print_license_limitation(limitation, separate_anonymous)\n\n        if len(licensecopy) > 1:\n            print(yaml.safe_dump(licensecopy, allow_unicode=True))\n\n    def _print_license_limitation(self, limitation, separate_anonymous):\n        if limitation['LimitationType'] == 'Named':\n            if limitation['AmountType'] == 'Unlimited':\n                print(\"- Unlimited named %suser accounts allowed.\" %\n                      ('' if separate_anonymous else \"and anonymous \"))\n            else:\n                print(\" - %s named user account%s allowed\" %\n                      (limitation['NumberOfAllowedUsers'],\n                       's' if limitation['NumberOfAllowedUsers'] != 1 else ''))\n        elif limitation['LimitationType'] == 'Concurrent':\n            if limitation['AmountType'] == 'Unlimited':\n                print(\"- Unlimited concurrent named %suser sessions allowed.\"\n                      % (\"\" if separate_anonymous else \"and anonymous \"))\n            else:\n                print(\"- %s concurrent named %suser session%s allowed.\" %\n                      (\n                          limitation['NumberOfAllowedUsers'],\n                          '' if separate_anonymous else \"and anonymous \",\n                          ('s' if limitation['NumberOfAllowedUsers'] != 1\n                           else '')))\n        elif (limitation['LimitationType'] == 'ConcurrentAnonymous' and\n              separate_anonymous):\n            if limitation['AmountType'] == 'Unlimited':\n                print(\"- Unlimited concurrent anonymous user sessions \"\n                      \"allowed.\")\n            else:\n                print(\"- %s concurrent anonymous session%s allowed.\" %\n                      (\n                          limitation['NumberOfAllowedUsers'],\n                          ('s' if limitation['NumberOfAllowedUsers'] != 1\n                           else '')))\n\n    def do_activate_license(self, args):\n        self.m2ee.client.require_action(\"set_license\")\n        print(\"The command activate_license will set the license key used in \"\n              \"this application.\")\n        runtime_version = m2ee.version.MXVersion(self.m2ee.client.about()['version'])\n        if runtime_version < 4.1:\n            print(\"Mendix Runtime versions before 4.1 do not check the \"\n                  \"submitted license key for validity, so incorrect input \"\n                  \"will un-license your Mendix application without warning! \"\n                  \"After setting the license, use show_license_information \"\n                  \"to check the active license. Also... after setting the \"\n                  \"license in versions before Mendix 4.1 you will need to \"\n                  \"restart the application again to be sure it is fully \"\n                  \"activated.\")\n            answer = raw_input(\"Do you want to continue anyway? (type YES if \"\n                               \"you want to): \")\n            if answer != 'YES':\n                print(\"Aborting.\")\n                return\n        if not args:\n            license_key = raw_input(\"Paste your license key (a long text \"\n                                    \"string without newlines) or empty input \"\n                                    \"to abort: \")\n        else:\n            license_key = args\n        if not license_key:\n            print(\"Aborting.\")\n            return\n        self.m2ee.client.set_license({'license_key': license_key})\n\n    def do_enable_debugger(self, args):\n        self.m2ee.client.require_action(\"enable_debugger\")\n        if not args:\n            debugger_password = raw_input(\n                \"Please enter the password to be used for remote debugger \"\n                \"access from the modeler, or leave blank to auto-generate \"\n                \"a password: \")\n            if not debugger_password:\n                debugger_password = ''.join(\n                    random.choice(string.letters + string.digits)\n                    for x in range(random.randint(20, 30)))\n        else:\n            debugger_password = args\n        self.m2ee.client.enable_debugger({'password': debugger_password})\n        logger.info(\"The remote debugger is now enabled, the password to \"\n                    \"use is %s\" % debugger_password)\n        logger.info(\"You can use the remote debugger option in the Mendix \"\n                    \"Business Modeler to connect to the /debugger/ sub \"\n                    \"url on your application (e.g. \"\n                    \"https://app.example.com/debugger/). \")\n\n    def do_disable_debugger(self, args):\n        self.m2ee.client.disable_debugger()\n        logger.info(\"The remote debugger is now disabled.\")\n\n    def do_show_debugger_status(self, args):\n        feedback = self.m2ee.client.get_debugger_status()\n        enabled = feedback['enabled']\n        connected = feedback['client_connected']\n        paused = feedback['number_of_paused_microflows']\n\n        logger.info(\"The remote debugger is currently %s.\" %\n                    (\"enabled\" if enabled else \"disabled\"))\n        if connected:\n            logger.info(\"A debugger session is connected.\")\n        elif enabled:\n            logger.info(\"There is no connected debugger session.\")\n        if enabled and paused == 0:\n            logger.info(\"There are no paused microflows.\")\n        elif paused == 1:\n            logger.info(\"There is 1 paused microflow.\")\n        elif paused > 1:\n            logger.info(\"There are %s paused microflows.\" % paused)\n\n    def do_who(self, args):\n        if args:\n            try:\n                limitint = int(args)\n                self._who(limitint)\n            except ValueError:\n                logger.warn(\"Could not parse argument to an integer. Use a \"\n                            \"number as argument to limit the amount of logged \"\n                            \"in users shown.\")\n        else:\n            self._who()\n\n    def do_w(self, args):\n        self.do_who(args)\n\n    def do_reload(self, args):\n        logger.debug(\"Reloading configuration...\")\n        self.m2ee.reload_config()\n\n    def do_dump_config(self, args):\n        self.m2ee.config.dump()\n\n    def do_set_database_password(self, args):\n        password = getpass.getpass(\"Database password: \")\n        self.m2ee.config.set_database_password(password)\n\n    def do_psql(self, args):\n        if not self.m2ee.config.is_using_postgresql():\n            logger.error(\"Only PostgreSQL databases are supported right now.\")\n            return\n        pgutil.psql(self.m2ee.config)\n\n    def do_dumpdb(self, args):\n        if not self.m2ee.config.is_using_postgresql():\n            logger.error(\"Only PostgreSQL databases are supported right now.\")\n            return\n        if len(args) > 0:\n            pgutil.dumpdb(self.m2ee.config, args)\n        else:\n            pgutil.dumpdb(self.m2ee.config)\n\n    def do_restoredb(self, args):\n        if not self.m2ee.config.allow_destroy_db():\n            logger.error(\"Refusing to do a destructive database operation \"\n                         \"because the allow_destroy_db configuration option \"\n                         \"is set to false.\")\n            return\n        if not self.m2ee.config.is_using_postgresql():\n            logger.error(\"Only PostgreSQL databases are supported right now.\")\n            return\n        if not args:\n            logger.error(\"restoredb needs the name of a dump file in %s as arg\"\n                         \"ument\" % self.m2ee.config.get_database_dump_path())\n            return\n        (pid_alive, m2ee_alive) = self.m2ee.check_alive()\n        if pid_alive or m2ee_alive:\n            logger.warn(\"The application is still running, refusing to \"\n                        \"restore the database right now.\")\n            return\n        database_name = self.m2ee.config.get_pg_environment()['PGDATABASE']\n        answer = ('y' if self.yolo_mode\n                  else raw_input(\"This command will restore this dump into database \"\n                                 \"%s. Continue? (y)es, (N)o? \" % database_name))\n        if answer != 'y':\n            logger.info(\"Aborting!\")\n            return\n        pgutil.restoredb(self.m2ee.config, args)\n\n    def complete_restoredb(self, text, line, begidx, endidx):\n        if not self.m2ee.config.is_using_postgresql():\n            return []\n        database_dump_path = self.m2ee.config.get_database_dump_path()\n        return [f for f in os.listdir(database_dump_path)\n                if os.path.isfile(os.path.join(database_dump_path, f)) and\n                f.startswith(text) and\n                f.endswith(\".backup\")]\n\n    def do_emptydb(self, args):\n        if not self.m2ee.config.allow_destroy_db():\n            logger.error(\"Refusing to do a destructive database operation \"\n                         \"because the allow_destroy_db configuration option \"\n                         \"is set to false.\")\n            return\n        if not self.m2ee.config.is_using_postgresql():\n            logger.error(\"Only PostgreSQL databases are supported right now.\")\n            return\n        (pid_alive, m2ee_alive) = self.m2ee.check_alive()\n        if pid_alive or m2ee_alive:\n            logger.warn(\"The application process is still running, refusing \"\n                        \"to empty the database right now.\")\n            return\n        logger.info(\"This command will drop all tables and sequences in \"\n                    \"database %s.\" %\n                    self.m2ee.config.get_pg_environment()['PGDATABASE'])\n        answer = ('y' if self.yolo_mode\n                  else raw_input(\"Continue? (y)es, (N)o? \"))\n        if answer != 'y':\n            print(\"Aborting!\")\n            return\n        pgutil.emptydb(self.m2ee.config)\n\n    def do_unpack(self, args):\n        if not args:\n            logger.error(\"unpack needs the name of a model upload zipfile in \"\n                         \"%s as argument\" %\n                         self.m2ee.config.get_model_upload_path())\n            return\n        (pid_alive, m2ee_alive) = self.m2ee.check_alive()\n        if pid_alive or m2ee_alive:\n            logger.error(\"The application process is still running, refusing \"\n                         \"to unpack a new application model right now.\")\n            return\n        logger.info(\"This command will replace the contents of the model/ and \"\n                    \"web/ locations, using the files extracted from the \"\n                    \"archive\")\n        answer = ('y' if self.yolo_mode\n                  else raw_input(\"Continue? (y)es, (N)o? \"))\n        if answer != 'y':\n            logger.info(\"Aborting!\")\n            return\n        self.m2ee.unpack(args)\n\n    def complete_unpack(self, text, line, begidx, endidx):\n        # these complete functions seem to eat exceptions, which is very bad\n        # behaviour if anything here throws an excaption, you just won't get\n        # completion, without knowing why\n        model_upload_path = self.m2ee.config.get_model_upload_path()\n        logger.trace(\"complete_unpack: Looking for %s in %s\" %\n                     (text, model_upload_path))\n        return [f for f in os.listdir(model_upload_path)\n                if os.path.isfile(os.path.join(model_upload_path, f))\n                and f.startswith(text)\n                and (f.endswith(\".zip\") or f.endswith(\".mda\"))]\n\n    def do_check_constants(self, args):\n        constants_to_use, default_constants, obsolete_constants = self.m2ee.config.get_constants()\n        if len(default_constants) > 0:\n            logger.info('Missing constant definitions (model defaults will be used):')\n            for name in sorted(default_constants.keys()):\n                logger.info('- %s' % name)\n        else:\n            logger.info('All required constant definitions have explicit definitions.')\n        if len(obsolete_constants) > 0:\n            logger.info('Constants defined but not needed by the application:')\n            for name in sorted(obsolete_constants.keys()):\n                logger.info('- %s' % name)\n\n    def do_log(self, args):\n        if self._cleanup_logging():\n            return\n        logfile = self.m2ee.config.get_logfile()\n        if not logfile:\n            logger.warn(\"logfile location is not specified\")\n            return\n        print(\"This command will start printing log information from the \"\n              \"application right in the middle of all of the other output on \"\n              \"your screen. This can be confusing, especially when you're \"\n              \"typing something and everything gets messed up by the logging. \"\n              \"Issuing the log command again will turn off logging output.\")\n        answer = ('y' if self.yolo_mode\n                  else raw_input(\"Do you want to start log output (y/N): \"))\n        if answer == 'y':\n            cmd = (\"tail\", \"-F\", logfile)\n            proc = subprocess.Popen(cmd)\n            self.m2ee._logproc = proc\n            self.prompt = \"LOG %s\" % self._default_prompt\n\n    def do_loglevel(self, args):\n        try:\n            args = shlex.split(args)\n        except ValueError as ve:\n            logger.error(\"Input cannot be parsed: %s\" % ve.message)\n            return\n        if len(args) == 3:\n            (subscriber, node, level) = args\n            self._set_log_level(subscriber, node, level)\n        else:\n            if len(args) == 0:\n                self._get_log_levels()\n            print(\"To adjust loglevels, use: loglevel <subscribername> \"\n                  \"<lognodename> <level>\")\n            print(\"Available levels: NONE, CRITICAL, ERROR, WARNING, INFO, \"\n                  \"DEBUG, TRACE\")\n\n    def _get_log_levels(self):\n        log_levels = self.m2ee.get_log_levels()\n        print(\"Current loglevels:\")\n        log_subscribers = []\n        for (subscriber_name, node_names) in log_levels.items():\n            for (node_name, subscriber_level) in node_names.items():\n                log_subscribers.append(\"%s %s %s\" %\n                                       (subscriber_name,\n                                        node_name,\n                                        subscriber_level))\n        log_subscribers.sort()\n        print(\"\\n\".join(log_subscribers))\n\n    def _set_log_level(self, subscriber, node, level):\n        level = level.upper()\n        try:\n            self.m2ee.set_log_level(subscriber, node, level)\n            logger.info(\"Loglevel for %s set to %s\" % (node, level))\n        except m2ee.client.M2EEAdminException as e:\n            print(\"Remember, all parameters are case sensitive\")\n            raise e\n\n    def do_show_current_runtime_requests(self, args):\n        feedback = self.m2ee.client.get_current_runtime_requests()\n        if len(feedback) == 0:\n            logger.info(\"There are no currently running runtime requests.\")\n        else:\n            print(\"Current running Runtime Requests:\")\n            print(yaml.safe_dump(feedback, default_flow_style=False))\n\n    def do_show_all_thread_stack_traces(self, args):\n        feedback = self.m2ee.client.get_all_thread_stack_traces()\n        print(\"Current JVM Thread Stacktraces:\")\n        print(yaml.safe_dump(feedback, default_flow_style=False))\n\n    def do_interrupt_request(self, args):\n        if args == \"\":\n            logger.error(\"This function needs a request id as parameter\")\n            logger.error(\"Use show_current_runtime_requests to view currently \"\n                         \"running requests\")\n            return\n        feedback = self.m2ee.client.interrupt_request({\"request_id\": args})\n        if feedback[\"result\"] is False:\n            logger.error(\"A request with ID %s was not found\" % args)\n        else:\n            logger.info(\"An attempt to cancel the running action was \"\n                        \"made.\")\n\n    def do_nodetach(self, args):\n        self.nodetach = True\n        logger.info(\"Setting nodetach, application process will not run in the background.\")\n\n    def do_exit(self, args):\n        return self._exit()\n\n    def do_quit(self, args):\n        return self._exit()\n\n    def do_EOF(self, args):\n        print(\"exit\")\n        return self._exit()\n\n    def _exit(self):\n        if self.m2ee.runner.check_attached_proc():\n            logger.warning(\"There is still an attached application process running. \"\n                           \"Stop it first.\")\n            return None\n        return -1\n\n    def do_download_runtime(self, args):\n        if args:\n            mxversion = m2ee.version.MXVersion(args)\n        else:\n            mxversion = self.m2ee.config.get_runtime_version()\n\n        if mxversion is None:\n            logger.info(\"You did not specify a Mendix Runtime version to \"\n                        \"download, and no current unpacked application \"\n                        \"model is available to determine the version from. \"\n                        \"Specify a version number or use unpack first.\")\n            return\n\n        if self.m2ee.config.lookup_in_mxjar_repo(str(mxversion)):\n            logger.info(\"The Mendix Runtime for version %s is already \"\n                        \"installed. If you want to download another Runtime \"\n                        \"version, specify the version number as argument to \"\n                        \"download_runtime.\" % mxversion)\n            return\n        self.m2ee.download_and_unpack_runtime(mxversion)\n\n    def do_cleanup_runtimes(self, args):\n        self.m2ee.cleanup_runtimes_except([])\n\n    def do_cleanup_runtimes_except(self, args):\n        self.m2ee.cleanup_runtimes_except(args.split())\n\n    def complete_cleanup_runtimes_except(self, text, line, begidx, endidx):\n        words = line[:len(line)-len(text)].split()\n        found_versions = self.m2ee.list_installed_runtimes()\n        return [\"%s \" % version for version in found_versions\n                if version.startswith(text)\n                and version not in words[1:]]\n\n    def _cleanup_logging(self):\n        # atexit\n        if self.m2ee._logproc:\n            logger.debug(\"Stopping log output...\")\n            self.prompt = self._default_prompt\n            if not self.m2ee._logproc.poll():\n                os.kill(self.m2ee._logproc.pid, signal.SIGTERM)\n            self.m2ee._logproc = None\n            return True\n        return False\n\n    def _who(self, limitint=None):\n        limit = {}\n        if limitint is not None:\n            limit = {\"limit\": limitint}\n        feedback = self.m2ee.client.get_logged_in_user_names(limit)\n        logger.info(\"Logged in users: (%s) %s\" %\n                    (feedback['count'], feedback['users']))\n        return feedback['count']\n\n    def precmd(self, line):\n        try:\n            self.m2ee.reload_config_if_changed()\n        except m2ee.exceptions.M2EEException as e:\n            logger.critical(e)\n            return line\n        if line:\n            logger.trace(\"Executing command: %s\" % line)\n        return line\n\n    def cmdloop_handle_ctrl_c(self):\n        quit = False\n        while quit is not True:\n            try:\n                self.cmdloop()\n                quit = True\n            except KeyboardInterrupt:\n                sys.stdout.write('\\n')\n\n    def onecmd(self, line):\n        try:\n            return super(CLI, self).onecmd(line)\n        except m2ee.client.M2EEAdminNotAvailable:\n            (pid_alive, m2ee_alive) = self.m2ee.check_alive()\n            if not pid_alive and not m2ee_alive:\n                logger.info(\"The application process is not running.\")\n        except m2ee.client.M2EEAdminException as e:\n            logger.error(e)\n        except m2ee.client.M2EEAdminHTTPException as e:\n            logger.error(e)\n        except m2ee.client.M2EERuntimeNotFullyRunning as e:\n            logger.error(e)\n        except m2ee.client.M2EEAdminTimeout as e:\n            logger.error(e)\n        except m2ee.exceptions.M2EEException as e:\n            logger.error(e)\n\n    def unchecked_onecmd(self, line):\n        super(CLI, self).onecmd(line)\n\n    # if the emptyline function is not defined, Cmd will automagically\n    # repeat the previous command given, and that's not what we want\n    def emptyline(self):\n        pass\n\n    def completenames(self, text, *ignored):\n        do_text = \"do_%s\" % text\n        suggestions = [a[3:] for a in self.get_names() if a.startswith(do_text)]\n        if len(suggestions) == 1 \\\n                and \"complete_%s\" % suggestions[0] in self.get_names():\n            suggestions[0] = \"%s \" % suggestions[0]\n        return suggestions\n\n    def do_help(self, args):\n        print(\"\"\"Welcome to m2ee, the Mendix Runtime helper tools.\n\nAvailable commands:\n unpack - unpack an uploaded Mendix Deployment Archive from data/model-upload\n download_runtime - download a missing Mendix Runtime distribution\n start - try starting the application using the unpacked deployment files\n stop - stop the application\n restart - restart the application\n status - display Mendix Runtime status (is the application running?\n create_admin_user - create first user when starting with an empty database\n update_admin_user - reset the password of an application user\n who, w - show currently logged in users\n log - follow live logging from the application\n loglevel - view and configure loglevels\n about - show Mendix Runtime version information\n check_constants - check for missing or unneeded constant definitions\n enable_debugger - enable remote debugger API\n disable_debugger - disable remote debugger API\n show_debugger_status - show whether debugger is enabled or not\n show_current_runtime_requests - show action stack of current running requests\n interrupt_request - cancel a running runtime request\n show_license_information - show details about current mendix license key\n show_cache_statistics - show details about the runtime object cache\n cleanup_runtimes - clean up downloaded Mendix Runtime versions, except the\n     one currently in use\n cleanup_runtimes_except [<version> <version> ...] - clean up downloaded Mendix\n     Runtime versions, except the one currently in use and other ones specified\n exit, quit, <ctrl>-d - exit m2ee\n\"\"\")\n\n        if self.m2ee.config.is_using_postgresql():\n            print(\"\"\"When using PostgreSQL, you can also use:\n psql - start the postgresql shell\n dumpdb - create a database dump into the data/database folder\n emptydb - drop all tables and sequences from the database\n restoredb - restore a database dump from the data/database folder\n\"\"\")\n\n        if args == 'expert':\n            print(\"\"\"Advanced commands:\n statistics - show all application statistics that can be used for monitoring\n show_all_thread_stack_traces - show all low-level JVM threads with stack trace\n check_health - manually execute health check\n\nExtra commands you probably don't need:\n debug - dive into a local python debug session inside this program\n dump_config - dump the yaml configuration information\n nodetach - do not detach the application process after starting\n reload - reload configuration from yaml files (this is done automatically)\n munin_config - configure option for the built-in munin plugin\n munin_values - show monitoring output gathered by the built-in munin plugin\n nagios - execute the built-in nagios plugin (will exit m2ee)\n activate_license - DANGEROUS - replace/set license key\n\"\"\")\n\n        print(\"Hint: use tab autocompletion for commands!\")\n\n        if args != 'expert':\n            print(\"Use help expert to show expert and debugging commands\")\n\n\ndef start_console_logging(level):\n    logger = logging.getLogger()\n    logger.setLevel(level)\n    consolelogformatter = logging.Formatter(\"%(levelname)s: %(message)s\")\n\n    class M2EELogFilter(logging.Filter):\n        def __init__(self, level, ge):\n            self.level = level\n            # log levels greater than and equal to (True), or below (False)\n            self.ge = ge\n\n        def filter(self, record):\n            if self.ge:\n                return record.levelno >= self.level\n            return record.levelno < self.level\n\n    # log everything below ERROR to to stdout\n    stdoutlog = logging.StreamHandler(sys.stdout)\n    stdoutlog.setFormatter(consolelogformatter)\n    stdoutfilter = M2EELogFilter(logging.ERROR, False)\n    stdoutlog.addFilter(stdoutfilter)\n\n    # log everything that's ERROR and more serious to stderr\n    stderrlog = logging.StreamHandler(sys.stderr)\n    stderrlog.setFormatter(consolelogformatter)\n    stderrfilter = M2EELogFilter(logging.ERROR, True)\n    stderrlog.addFilter(stderrfilter)\n\n    logger.addHandler(stdoutlog)\n    logger.addHandler(stderrlog)\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"-c\",\n        action=\"append\",\n        dest=\"yaml_files\"\n    )\n    parser.add_argument(\n        \"-v\",\n        \"--verbose\",\n        action=\"count\",\n        dest=\"verbose\",\n        default=0,\n        help=\"increase verbosity of output (-vv to be even more verbose)\"\n    )\n    parser.add_argument(\n        \"-q\",\n        \"--quiet\",\n        action=\"count\",\n        dest=\"quiet\",\n        default=0,\n        help=\"decrease verbosity of output (-qq to be even more quiet)\"\n    )\n    parser.add_argument(\n        \"-y\",\n        \"--yolo\",\n        action=\"store_true\",\n        default=False,\n        dest=\"yolo_mode\",\n        help=\"automatically answer all questions to run as non-interactively as possible\"\n    )\n    parser.add_argument(\n        \"onecmd\",\n        nargs='*',\n    )\n    args = parser.parse_args()\n\n    # how verbose should we be? see\n    # http://docs.python.org/release/2.7/library/logging.html#logging-levels\n    verbosity = args.quiet - args.verbose\n    if args.quiet:\n        verbosity = verbosity + args.quiet\n    if args.verbose:\n        verbosity = verbosity - args.verbose\n    verbosity = verbosity * 10 + 20\n    if verbosity > 50:\n        verbosity = 100\n    if verbosity < 5:\n        verbosity = 5\n    start_console_logging(verbosity)\n\n    try:\n        cli = CLI(\n            yaml_files=args.yaml_files,\n            yolo_mode=args.yolo_mode,\n        )\n    except m2ee.exceptions.M2EEException as e:\n        logger.critical(e)\n        sys.exit(1)\n\n    atexit.register(cli._cleanup_logging)\n    if args.onecmd:\n        try:\n            cli.unchecked_onecmd(' '.join(args.onecmd))\n        except (m2ee.client.M2EEAdminException,\n                m2ee.client.M2EEAdminHTTPException,\n                m2ee.client.M2EERuntimeNotFullyRunning,\n                m2ee.client.M2EEAdminTimeout,\n                m2ee.exceptions.M2EEException) as e:\n            logger.error(e)\n            sys.exit(1)\n        except m2ee.client.M2EEAdminNotAvailable:\n            pid_alive, m2ee_alive = cli.m2ee.check_alive()\n            if not pid_alive and not m2ee_alive:\n                logger.info(\"The application process is not running.\")\n                sys.exit(0)\n            sys.exit(1)\n    else:\n        logger.info(\"Application Name: %s\" % cli.m2ee.config.get_app_name())\n        cli.onecmd('status')\n        cli.cmdloop_handle_ctrl_c()\n\n\nif __name__ == '__main__':\n    main()\n",
  "output": {
    "before": "#!/usr/bin/python\n#\n# Copyright (C) 2009 Mendix. All rights reserved.\n#\n\nfrom __future__ import print_function\nimport argparse\nimport atexit\nimport cmd\nimport datetime\nimport getpass\nimport logging\nimport os\nimport pwd\nimport random\nimport shlex\nimport signal\nimport string\nimport subprocess\nimport sys\nimport yaml\n\nfrom m2ee import pgutil, M2EE, client_errno\nimport m2ee\n\nlogger = logging\n\nif not sys.stdout.isatty():\n    import codecs\n    import locale\n    sys.stdout = codecs.getwriter(locale.getpreferredencoding())(sys.stdout)\n\ntry:\n    raw_input\nexcept NameError:\n    raw_input = input\n\n\nclass CLI(cmd.Cmd, object):\n\n    def __init__(self, yaml_files=None, yolo_mode=False):\n        logger.debug('Using m2ee-tools version %s' % m2ee.__version__)\n        cmd.Cmd.__init__(self)\n        self.m2ee = M2EE(yaml_files=yaml_files)\n        self.yolo_mode = yolo_mode\n        self.prompt_username = pwd.getpwuid(os.getuid())[0]\n        self._default_prompt = \"m2ee(%s): \" % self.prompt_username\n        self.prompt = self._default_prompt\n        self.nodetach = False\n\n    def do_restart(self, args):\n        if self._stop():\n            self._start()\n\n    def do_stop(self, args):\n        self._stop()\n\n    def do_start(self, args):\n        self._start()\n\n    def _stop(self):\n        logger.debug(\"Trying to stop the application.\")\n        stopped = self.m2ee.stop()\n        if stopped:\n            return True\n\n        answer = None\n        while answer not in ('y', 'n'):\n            answer = ('y' if self.yolo_mode\n                      else raw_input(\"Do you want to try to signal the JVM \"\n                                     \"process to stop immediately? (y)es, (n)o? \"))\n            if answer == 'y':\n                stopped = self.m2ee.terminate()\n                if stopped:\n                    return True\n            elif answer == 'n':\n                logger.info(\"Doing nothing, use stop again to check if the \"\n                            \"process finally disappeared...\")\n                return False\n            else:\n                print(\"Unknown option %s\" % answer)\n\n        answer = None\n        while answer not in ('y', 'n'):\n            answer = ('y' if self.yolo_mode\n                      else raw_input(\"Do you want to kill the JVM process? \"\n                                     \"(y)es, (n)o? \"))\n            if answer == 'y':\n                stopped = self.m2ee.kill()\n                if stopped:\n                    return True\n            elif answer == 'n':\n                logger.info(\"Doing nothing, use stop again to check if the \"\n                            \"process finally disappeared...\")\n                return False\n            else:\n                print(\"Unknown option %s\" % answer)\n\n        return False\n\n    def _start(self):\n        \"\"\"\n        This function deals with the start-up sequence of the Mendix Runtime.\n        Starting the Mendix Runtime can fail in both a temporary or permanent\n        way. See the client_errno for possible error codes.\n        \"\"\"\n\n        if not self.m2ee.config.all_systems_are_go():\n            raise m2ee.exceptions.M2EEException(\n                \"The application cannot be started because no application \"\n                \"model is present, or because of other previous errors.\"\n            )\n\n        if not self.m2ee.config.get_runtime_path():\n            raise m2ee.exceptions.M2EEException(\n                \"It appears that the Mendix Runtime version which has to be \"\n                \"used for your application is not present yet. You can try \"\n                \"downloading it using the download_runtime command.\"\n            )\n\n        self.m2ee.start_appcontainer(detach=not self.nodetach)\n\n        try:\n            self.m2ee.send_runtime_config()\n        except m2ee.client.M2EEAdminException as e:\n            logger.error(\"Sending configuration failed: %s\" % e.cause)\n            logger.error(\"You'll have to fix the configuration and run start again...\")\n            self._stop()\n            return\n\n        abort = False\n        fully_started = False\n        params = {}\n        while not (fully_started or abort):\n            try:\n                self.m2ee.start_runtime(params)\n                fully_started = True\n            except m2ee.client.M2EEAdminException as e:\n                logger.error(e)\n                if e.result == client_errno.start_NO_EXISTING_DB:\n                    if self.yolo_mode:\n                        # This call tries to create a database and immediately execute\n                        # ddl commands.\n                        self.m2ee.client.execute_ddl_commands()\n                    else:\n                        abort = True\n                elif e.result == client_errno.start_INVALID_DB_STRUCTURE:\n                    answer = self._handle_ddl_commands()\n                    if answer == 'a':\n                        abort = True\n                elif e.result == client_errno.start_MISSING_MF_CONSTANT:\n                    logger.error(\"You'll have to add the constant definitions \"\n                                 \"to the configuration in the \"\n                                 \"MicroflowConstants section.\")\n                    abort = True\n                elif e.result == client_errno.start_ADMIN_1:\n                    users = e.feedback['users']\n                    if self.yolo_mode:\n                        self._handle_admin_1_yolo(users)\n                    else:\n                        answer = self._handle_admin_1(users)\n                        if answer == 'a':\n                            abort = True\n                else:\n                    abort = True\n\n        if abort:\n            self._stop()\n\n    def _handle_ddl_commands(self):\n        feedback = self.m2ee.client.get_ddl_commands({\"verbose\": True})\n        answer = None\n        while answer not in ('v', 's', 'e', 'a'):\n            answer = ('e' if self.yolo_mode\n                      else raw_input(\"Do you want to (v)iew queries, (s)ave them to \"\n                                     \"a file, (e)xecute and save them, or (a)bort: \"))\n            if answer == 'a':\n                pass\n            elif answer == 'v':\n                print('\\n'.join(feedback['ddl_commands']))\n                answer = None\n            elif answer in ('e', 's'):\n                ddl_commands = feedback['ddl_commands']\n                self.m2ee.save_ddl_commands(ddl_commands)\n                if answer == 'e':\n                    self.m2ee.client.execute_ddl_commands()\n            else:\n                print(\"Unknown option %s\" % answer)\n        return answer\n\n    def _handle_admin_1(self, users):\n        answer = None\n        while answer not in ('c', 'a'):\n            answer = raw_input(\"Do you want to (c)hange passwords or \"\n                               \"(a)bort: \")\n            if answer == 'a':\n                pass\n            elif answer == 'c':\n                for username in users:\n                    changed = False\n                    while not changed:\n                        newpw1 = getpass.getpass(\"Type new password for user \"\n                                                 \"%s: \" % username)\n                        newpw2 = getpass.getpass(\"Type new password for user \"\n                                                 \" %s again: \" % username)\n                        if newpw1 != newpw2:\n                            print(\"The passwords are not equal!\")\n                        else:\n                            try:\n                                self.m2ee.client.update_admin_user(\n                                    {\"username\": username, \"password\": newpw1})\n                                changed = True\n                            except m2ee.client.M2EEAdminException as e:\n                                logger.error(e)\n            else:\n                print(\"Unknown option %s\" % answer)\n        return answer\n\n    def _handle_admin_1_yolo(self, users):\n        for username in users:\n            newpasswd = self._generate_password()\n            logger.info(\"Changing password for user %s to %s\" %\n                        (username, newpasswd))\n            self.m2ee.client.update_admin_user({\n                \"username\": username,\n                \"password\": newpasswd,\n            })\n\n    def _generate_password(self):\n        newpasswd_list = []\n        for choosefrom in [\n            string.ascii_lowercase,\n            string.ascii_uppercase,\n            string.digits,\n            string.punctuation,\n        ]:\n            newpasswd_list.extend([random.choice(choosefrom)\n                                   for _ in range(random.randint(10, 20))])\n        random.shuffle(newpasswd_list)\n        return ''.join(newpasswd_list)\n\n    def do_create_admin_user(self, args=None):\n        if not self.m2ee.client.ping():\n            logger.warn(\"The application process needs to be running to \"\n                        \"create a user object in the application.\")\n            return\n        print(\"This option will create an administrative user account, using \"\n              \"the preset username and user role settings.\")\n        newpw1 = getpass.getpass(\"Type new password for this user: \")\n        newpw2 = getpass.getpass(\"Type new password for this user again: \")\n        if newpw1 != newpw2:\n            print(\"The passwords are not equal!\")\n        else:\n            self.m2ee.client.create_admin_user({\"password\": newpw1})\n\n    def do_update_admin_user(self, args=None):\n        if not self.m2ee.client.ping():\n            logger.warn(\"The application process needs to be running to \"\n                        \"change user objects in the application.\")\n            return\n        print(\"Using this function you can reset the password of an \"\n              \"administrative user account.\")\n        username = raw_input(\"User name: \")\n        newpw1 = getpass.getpass(\"Type new password for user %s: \" % username)\n        newpw2 = getpass.getpass(\"Type new password for user %s again: \" %\n                                 username)\n        if newpw1 != newpw2:\n            print(\"The passwords are not equal!\")\n        else:\n            self.m2ee.client.update_admin_user({\"username\": username, \"password\": newpw1})\n\n    def do_debug(self, args):\n        answer = raw_input(\"This command will throw you into a local python \"\n                           \"debug session inside the M2EE object! Continue \"\n                           \"(y/N)?\")\n        if answer == 'y':\n            import code\n            code.interact(local=locals())\n\n    def do_status(self, args):\n        feedback = self.m2ee.client.runtime_status(timeout=3)\n        status = feedback['status']\n        logger.info(\"The application process is running, the MxRuntime has status: %s\" % status)\n\n        if status != 'running':\n            return\n\n        critlist = self.m2ee.client.get_critical_log_messages()\n        if len(critlist) > 0:\n            logger.error(\"%d critical error(s) were logged. Use show_critical\"\n                         \"_log_messages to view them.\" % len(critlist))\n\n        max_show_users = 10\n        total_users = self._who(max_show_users)\n        if total_users > max_show_users:\n            logger.info(\"Only showing %s logged in users. Use who to see a \"\n                        \"complete list.\" % max_show_users)\n\n    def do_show_critical_log_messages(self, args):\n        errors = self.m2ee.client.get_critical_log_messages()\n        if len(errors) == 0:\n            logger.info(\"No messages were logged to a critical loglevel since \"\n                        \"starting the application.\")\n            return\n        for error in errors:\n            errorline = []\n            if 'message' in error and error['message'] != '':\n                errorline.append(\"- %s\" % error['message'])\n            if 'cause' in error and error['cause'] != '':\n                errorline.append(\"- Caused by: %s\" % error['cause'])\n            if len(errorline) == 0:\n                errorline.append(\"- [No message or cause was logged]\")\n            errorline.insert(\n                0,\n                datetime.datetime.fromtimestamp(error['timestamp'] / 1000)\n                .strftime(\"%Y-%m-%d %H:%M:%S\")\n            )\n            print(' '.join(errorline))\n\n    def do_check_health(self, args):\n        feedback = self.m2ee.client.check_health()\n        if feedback['health'] == 'healthy':\n            logger.info(\"Health check microflow says the application is healthy.\")\n        elif feedback['health'] == 'sick':\n            logger.warning(\"Health check microflow says the application \"\n                           \"is sick: %s\" % feedback['diagnosis'])\n        elif feedback['health'] == 'unknown':\n            logger.info(\"Health check microflow is not configured, no \"\n                        \"health information available.\")\n        else:\n            logger.error(\"Unexpected health check status: %s\" % feedback['health'])\n\n    def do_statistics(self, args):\n        stats = self.m2ee.client.runtime_statistics()\n        stats.update(self.m2ee.client.server_statistics())\n        print(yaml.safe_dump(stats, default_flow_style=False))\n\n    def do_show_cache_statistics(self, args):\n        stats = self.m2ee.client.cache_statistics()\n        print(yaml.safe_dump(stats, default_flow_style=False))\n\n    def do_munin_config(self, args):\n        m2ee.munin.print_config(\n            self.m2ee,\n            self.prompt_username,\n        )\n\n    def do_munin_values(self, args):\n        m2ee.munin.print_values(\n            self.m2ee,\n            self.prompt_username,\n        )\n\n    def do_nagios(self, args):\n        logger.info(\"The nagios plugin will exit m2ee after running, this is \"\n                    \"by design, don't report it as bug.\")\n        # TODO: implement as separate program after libraryfying m2ee\n        sys.exit(m2ee.nagios.check(self.m2ee.runner, self.m2ee.client))\n\n    def do_about(self, args):\n        print('Using m2ee-tools version %s' % m2ee.__version__)\n        feedback = self.m2ee.client.about()\n        print(\"Using %s version %s\" % (feedback['name'], feedback['version']))\n        print(feedback['copyright'])\n        if self.m2ee.config.get_runtime_version() >= 4.4:\n            if 'model_version' in feedback:\n                print('Model version: %s' % feedback['model_version'])\n\n    def do_show_license_information(self, args):\n        feedback = self.m2ee.client.get_license_information()\n        if 'license' in feedback:\n            logger.debug(yaml.safe_dump(feedback['license'],\n                         allow_unicode=True))\n            import copy\n            licensecopy = copy.deepcopy(feedback['license'])\n            self._print_license(licensecopy)\n        elif 'license_id' in feedback:\n            print(\"Unlicensed environment.\")\n            print(\"Server ID: %s\" % feedback['license_id'])\n        else:\n            print(\"Unlicensed environment.\")\n\n    def _print_license(self, licensecopy):\n        print(\"Server ID: %s\" % licensecopy.pop('LicenseID', 'Unknown'))\n        print(\"License Type: %s\" % licensecopy.pop('LicenseType', 'Unknown'))\n        if 'ExpirationDate' in licensecopy:\n            print(\"Expiration Date: %s\" %\n                  datetime.datetime.fromtimestamp(\n                      licensecopy.pop('ExpirationDate') / 1000\n                  )\n                  .strftime(\"%a, %d %b %Y %H:%M:%S %z\")\n                  .rstrip())\n        print(\"Runtime Mode: %s\" % licensecopy.pop('RuntimeMode', 'Unknown'))\n        print(\"Company: %s\" % licensecopy.pop('Company', 'Unknown'))\n\n        limitations = licensecopy.pop('UserLimitations', None)\n        separate_anonymous = licensecopy.pop('SeparateAnonymousUsers', True)\n        if limitations is not None:\n            print(\"License Limitations:\")\n            for limitation in limitations:\n                self._print_license_limitation(limitation, separate_anonymous)\n\n        if len(licensecopy) > 1:\n            print(yaml.safe_dump(licensecopy, allow_unicode=True))\n\n    def _print_license_limitation(self, limitation, separate_anonymous):\n        if limitation['LimitationType'] == 'Named':\n            if limitation['AmountType'] == 'Unlimited':\n                print(\"- Unlimited named %suser accounts allowed.\" %\n                      ('' if separate_anonymous else \"and anonymous \"))\n            else:\n                print(\" - %s named user account%s allowed\" %\n                      (limitation['NumberOfAllowedUsers'],\n                       's' if limitation['NumberOfAllowedUsers'] != 1 else ''))\n        elif limitation['LimitationType'] == 'Concurrent':\n            if limitation['AmountType'] == 'Unlimited':\n                print(\"- Unlimited concurrent named %suser sessions allowed.\"\n                      % (\"\" if separate_anonymous else \"and anonymous \"))\n            else:\n                print(\"- %s concurrent named %suser session%s allowed.\" %\n                      (\n                          limitation['NumberOfAllowedUsers'],\n                          '' if separate_anonymous else \"and anonymous \",\n                          ('s' if limitation['NumberOfAllowedUsers'] != 1\n                           else '')))\n        elif (limitation['LimitationType'] == 'ConcurrentAnonymous' and\n              separate_anonymous):\n            if limitation['AmountType'] == 'Unlimited':\n                print(\"- Unlimited concurrent anonymous user sessions \"\n                      \"allowed.\")\n            else:\n                print(\"- %s concurrent anonymous session%s allowed.\" %\n                      (\n                          limitation['NumberOfAllowedUsers'],\n                          ('s' if limitation['NumberOfAllowedUsers'] != 1\n                           else '')))\n\n    def do_activate_license(self, args):\n        self.m2ee.client.require_action(\"set_license\")\n        print(\"The command activate_license will set the license key used in \"\n              \"this application.\")\n        runtime_version = m2ee.version.MXVersion(self.m2ee.client.about()['version'])\n        if runtime_version < 4.1:\n            print(\"Mendix Runtime versions before 4.1 do not check the \"\n                  \"submitted license key for validity, so incorrect input \"\n                  \"will un-license your Mendix application without warning! \"\n                  \"After setting the license, use show_license_information \"\n                  \"to check the active license. Also... after setting the \"\n                  \"license in versions before Mendix 4.1 you will need to \"\n                  \"restart the application again to be sure it is fully \"\n                  \"activated.\")\n            answer = raw_input(\"Do you want to continue anyway? (type YES if \"\n                               \"you want to): \")\n            if answer != 'YES':\n                print(\"Aborting.\")\n                return\n        if not args:\n            license_key = raw_input(\"Paste your license key (a long text \"\n                                    \"string without newlines) or empty input \"\n                                    \"to abort: \")\n        else:\n            license_key = args\n        if not license_key:\n            print(\"Aborting.\")\n            return\n        self.m2ee.client.set_license({'license_key': license_key})\n\n    def do_enable_debugger(self, args):\n        self.m2ee.client.require_action(\"enable_debugger\")\n        if not args:\n            debugger_password = raw_input(\n                \"Please enter the password to be used for remote debugger \"\n                \"access from the modeler, or leave blank to auto-generate \"\n                \"a password: \")\n            if not debugger_password:\n                debugger_password = ''.join(\n                    random.choice(string.letters + string.digits)\n                    for x in range(random.randint(20, 30)))\n        else:\n            debugger_password = args\n        self.m2ee.client.enable_debugger({'password': debugger_password})\n        logger.info(\"The remote debugger is now enabled, the password to \"\n                    \"use is %s\" % debugger_password)\n        logger.info(\"You can use the remote debugger option in the Mendix \"\n                    \"Business Modeler to connect to the /debugger/ sub \"\n                    \"url on your application (e.g. \"\n                    \"https://app.example.com/debugger/). \")\n\n    def do_disable_debugger(self, args):\n        self.m2ee.client.disable_debugger()\n        logger.info(\"The remote debugger is now disabled.\")\n\n    def do_show_debugger_status(self, args):\n        feedback = self.m2ee.client.get_debugger_status()\n        enabled = feedback['enabled']\n        connected = feedback['client_connected']\n        paused = feedback['number_of_paused_microflows']\n\n        logger.info(\"The remote debugger is currently %s.\" %\n                    (\"enabled\" if enabled else \"disabled\"))\n        if connected:\n            logger.info(\"A debugger session is connected.\")\n        elif enabled:\n            logger.info(\"There is no connected debugger session.\")\n        if enabled and paused == 0:\n            logger.info(\"There are no paused microflows.\")\n        elif paused == 1:\n            logger.info(\"There is 1 paused microflow.\")\n        elif paused > 1:\n            logger.info(\"There are %s paused microflows.\" % paused)\n\n    def do_who(self, args):\n        if args:\n            try:\n                limitint = int(args)\n                self._who(limitint)\n            except ValueError:\n                logger.warn(\"Could not parse argument to an integer. Use a \"\n                            \"number as argument to limit the amount of logged \"\n                            \"in users shown.\")\n        else:\n            self._who()\n\n    def do_w(self, args):\n        self.do_who(args)\n\n    def do_reload(self, args):\n        logger.debug(\"Reloading configuration...\")\n        self.m2ee.reload_config()\n\n    def do_dump_config(self, args):\n        self.m2ee.config.dump()\n\n    def do_set_database_password(self, args):\n        password = getpass.getpass(\"Database password: \")\n        self.m2ee.config.set_database_password(password)\n\n    def do_psql(self, args):\n        if not self.m2ee.config.is_using_postgresql():\n            logger.error(\"Only PostgreSQL databases are supported right now.\")\n            return\n        pgutil.psql(self.m2ee.config)\n\n    def do_dumpdb(self, args):\n        if not self.m2ee.config.is_using_postgresql():\n            logger.error(\"Only PostgreSQL databases are supported right now.\")\n            return\n        if len(args) > 0:\n            pgutil.dumpdb(self.m2ee.config, args)\n        else:\n            pgutil.dumpdb(self.m2ee.config)\n\n    def do_restoredb(self, args):\n        if not self.m2ee.config.allow_destroy_db():\n            logger.error(\"Refusing to do a destructive database operation \"\n                         \"because the allow_destroy_db configuration option \"\n                         \"is set to false.\")\n            return\n        if not self.m2ee.config.is_using_postgresql():\n            logger.error(\"Only PostgreSQL databases are supported right now.\")\n            return\n        if not args:\n            logger.error(\"restoredb needs the name of a dump file in %s as arg\"\n                         \"ument\" % self.m2ee.config.get_database_dump_path())\n            return\n        (pid_alive, m2ee_alive) = self.m2ee.check_alive()\n        if pid_alive or m2ee_alive:\n            logger.warn(\"The application is still running, refusing to \"\n                        \"restore the database right now.\")\n            return\n        database_name = self.m2ee.config.get_pg_environment()['PGDATABASE']\n        answer = ('y' if self.yolo_mode\n                  else raw_input(\"This command will restore this dump into database \"\n                                 \"%s. Continue? (y)es, (N)o? \" % database_name))\n        if answer != 'y':\n            logger.info(\"Aborting!\")\n            return\n        pgutil.restoredb(self.m2ee.config, args)\n\n    def complete_restoredb(self, text, line, begidx, endidx):\n        if not self.m2ee.config.is_using_postgresql():\n            return []\n        database_dump_path = self.m2ee.config.get_database_dump_path()\n        return [f for f in os.listdir(database_dump_path)\n                if os.path.isfile(os.path.join(database_dump_path, f)) and\n                f.startswith(text) and\n                f.endswith(\".backup\")]\n\n    def do_emptydb(self, args):\n        if not self.m2ee.config.allow_destroy_db():\n            logger.error(\"Refusing to do a destructive database operation \"\n                         \"because the allow_destroy_db configuration option \"\n                         \"is set to false.\")\n            return\n        if not self.m2ee.config.is_using_postgresql():\n            logger.error(\"Only PostgreSQL databases are supported right now.\")\n            return\n        (pid_alive, m2ee_alive) = self.m2ee.check_alive()\n        if pid_alive or m2ee_alive:\n            logger.warn(\"The application process is still running, refusing \"\n                        \"to empty the database right now.\")\n            return\n        logger.info(\"This command will drop all tables and sequences in \"\n                    \"database %s.\" %\n                    self.m2ee.config.get_pg_environment()['PGDATABASE'])\n        answer = ('y' if self.yolo_mode\n                  else raw_input(\"Continue? (y)es, (N)o? \"))\n        if answer != 'y':\n            print(\"Aborting!\")\n            return\n        pgutil.emptydb(self.m2ee.config)\n\n    def do_unpack(self, args):\n        if not args:\n            logger.error(\"unpack needs the name of a model upload zipfile in \"\n                         \"%s as argument\" %\n                         self.m2ee.config.get_model_upload_path())\n            return\n        (pid_alive, m2ee_alive) = self.m2ee.check_alive()\n        if pid_alive or m2ee_alive:\n            logger.error(\"The application process is still running, refusing \"\n                         \"to unpack a new application model right now.\")\n            return\n        logger.info(\"This command will replace the contents of the model/ and \"\n                    \"web/ locations, using the files extracted from the \"\n                    \"archive\")\n        answer = ('y' if self.yolo_mode\n                  else raw_input(\"Continue? (y)es, (N)o? \"))\n        if answer != 'y':\n            logger.info(\"Aborting!\")\n            return\n        self.m2ee.unpack(args)\n\n    def complete_unpack(self, text, line, begidx, endidx):\n        # these complete functions seem to eat exceptions, which is very bad\n        # behaviour if anything here throws an excaption, you just won't get\n        # completion, without knowing why\n        model_upload_path = self.m2ee.config.get_model_upload_path()\n        logger.trace(\"complete_unpack: Looking for %s in %s\" %\n                     (text, model_upload_path))\n        return [f for f in os.listdir(model_upload_path)\n                if os.path.isfile(os.path.join(model_upload_path, f))\n                and f.startswith(text)\n                and (f.endswith(\".zip\") or f.endswith(\".mda\"))]\n\n    def do_check_constants(self, args):\n        constants_to_use, default_constants, obsolete_constants = self.m2ee.config.get_constants()\n        if len(default_constants) > 0:\n            logger.info('Missing constant definitions (model defaults will be used):')\n            for name in sorted(default_constants.keys()):\n                logger.info('- %s' % name)\n        else:\n            logger.info('All required constant definitions have explicit definitions.')\n        if len(obsolete_constants) > 0:\n            logger.info('Constants defined but not needed by the application:')\n            for name in sorted(obsolete_constants.keys()):\n                logger.info('- %s' % name)\n\n    def do_log(self, args):\n        if self._cleanup_logging():\n            return\n        logfile = self.m2ee.config.get_logfile()\n        if not logfile:\n            logger.warn(\"logfile location is not specified\")\n            return\n        print(\"This command will start printing log information from the \"\n              \"application right in the middle of all of the other output on \"\n              \"your screen. This can be confusing, especially when you're \"\n              \"typing something and everything gets messed up by the logging. \"\n              \"Issuing the log command again will turn off logging output.\")\n        answer = ('y' if self.yolo_mode\n                  else raw_input(\"Do you want to start log output (y/N): \"))\n        if answer == 'y':\n            cmd = (\"tail\", \"-F\", logfile)\n            proc = subprocess.Popen(cmd)\n            self.m2ee._logproc = proc\n            self.prompt = \"LOG %s\" % self._default_prompt\n\n    def do_loglevel(self, args):\n        try:\n            args = shlex.split(args)\n        except ValueError as ve:\n            logger.error(\"Input cannot be parsed: %s\" % ve.message)\n            return\n        if len(args) == 3:\n            (subscriber, node, level) = args\n            self._set_log_level(subscriber, node, level)\n        else:\n            if len(args) == 0:\n                self._get_log_levels()\n            print(\"To adjust loglevels, use: loglevel <subscribername> \"\n                  \"<lognodename> <level>\")\n            print(\"Available levels: NONE, CRITICAL, ERROR, WARNING, INFO, \"\n                  \"DEBUG, TRACE\")\n\n    def _get_log_levels(self):\n        log_levels = self.m2ee.get_log_levels()\n        print(\"Current loglevels:\")\n        log_subscribers = []\n        for (subscriber_name, node_names) in log_levels.items():\n            for (node_name, subscriber_level) in node_names.items():\n                log_subscribers.append(\"%s %s %s\" %\n                                       (subscriber_name,\n                                        node_name,\n                                        subscriber_level))\n        log_subscribers.sort()\n        print(\"\\n\".join(log_subscribers))\n\n    def _set_log_level(self, subscriber, node, level):\n        level = level.upper()\n        try:\n            self.m2ee.set_log_level(subscriber, node, level)\n            logger.info(\"Loglevel for %s set to %s\" % (node, level))\n        except m2ee.client.M2EEAdminException as e:\n            print(\"Remember, all parameters are case sensitive\")\n            raise e\n\n    def do_show_current_runtime_requests(self, args):\n        feedback = self.m2ee.client.get_current_runtime_requests()\n        if len(feedback) == 0:\n            logger.info(\"There are no currently running runtime requests.\")\n        else:\n            print(\"Current running Runtime Requests:\")\n            print(yaml.safe_dump(feedback, default_flow_style=False))\n\n    def do_show_all_thread_stack_traces(self, args):\n        feedback = self.m2ee.client.get_all_thread_stack_traces()\n        print(\"Current JVM Thread Stacktraces:\")\n        print(yaml.safe_dump(feedback, default_flow_style=False))\n\n    def do_interrupt_request(self, args):\n        if args == \"\":\n            logger.error(\"This function needs a request id as parameter\")\n            logger.error(\"Use show_current_runtime_requests to view currently \"\n                         \"running requests\")\n            return\n        feedback = self.m2ee.client.interrupt_request({\"request_id\": args})\n        if feedback[\"result\"] is False:\n            logger.error(\"A request with ID %s was not found\" % args)\n        else:\n            logger.info(\"An attempt to cancel the running action was \"\n                        \"made.\")\n\n    def do_nodetach(self, args):\n        self.nodetach = True\n        logger.info(\"Setting nodetach, application process will not run in the background.\")\n\n    def do_exit(self, args):\n        return self._exit()\n\n    def do_quit(self, args):\n        return self._exit()\n\n    def do_EOF(self, args):\n        print(\"exit\")\n        return self._exit()\n\n    def _exit(self):\n        if self.m2ee.runner.check_attached_proc():\n            logger.warning(\"There is still an attached application process running. \"\n                           \"Stop it first.\")\n            return None\n        return -1\n\n    def do_download_runtime(self, args):\n        if args:\n            mxversion = m2ee.version.MXVersion(args)\n        else:\n            mxversion = self.m2ee.config.get_runtime_version()\n\n        if mxversion is None:\n            logger.info(\"You did not specify a Mendix Runtime version to \"\n                        \"download, and no current unpacked application \"\n                        \"model is available to determine the version from. \"\n                        \"Specify a version number or use unpack first.\")\n            return\n\n        if self.m2ee.config.lookup_in_mxjar_repo(str(mxversion)):\n            logger.info(\"The Mendix Runtime for version %s is already \"\n                        \"installed. If you want to download another Runtime \"\n                        \"version, specify the version number as argument to \"\n                        \"download_runtime.\" % mxversion)\n            return\n        self.m2ee.download_and_unpack_runtime(mxversion)\n\n    def do_cleanup_runtimes(self, args):\n        self.m2ee.cleanup_runtimes_except([])\n\n    def do_cleanup_runtimes_except(self, args):\n        self.m2ee.cleanup_runtimes_except(args.split())\n\n    def complete_cleanup_runtimes_except(self, text, line, begidx, endidx):\n        words = line[:len(line)-len(text)].split()\n        found_versions = self.m2ee.list_installed_runtimes()\n        return [\"%s \" % version for version in found_versions\n                if version.startswith(text)\n                and version not in words[1:]]\n\n    def _cleanup_logging(self):\n        # atexit\n        if self.m2ee._logproc:\n            logger.debug(\"Stopping log output...\")\n            self.prompt = self._default_prompt\n            if not self.m2ee._logproc.poll():\n                os.kill(self.m2ee._logproc.pid, signal.SIGTERM)\n            self.m2ee._logproc = None\n            return True\n        return False\n\n    def _who(self, limitint=None):\n        limit = {}\n        if limitint is not None:\n            limit = {\"limit\": limitint}\n        feedback = self.m2ee.client.get_logged_in_user_names(limit)\n        logger.info(\"Logged in users: (%s) %s\" %\n                    (feedback['count'], feedback['users']))\n        return feedback['count']\n\n    def precmd(self, line):\n        try:\n            self.m2ee.reload_config_if_changed()\n        except m2ee.exceptions.M2EEException as e:\n            logger.critical(e)\n            return line\n        if line:\n            logger.trace(\"Executing command: %s\" % line)\n        return line\n\n    def cmdloop_handle_ctrl_c(self):\n        quit = False\n        while quit is not True:\n            try:\n                self.cmdloop()\n                quit = True\n            except KeyboardInterrupt:\n                sys.stdout.write('\\n')\n\n    def onecmd(self, line):\n        try:\n            return super(CLI, self).onecmd(line)\n        except m2ee.client.M2EEAdminNotAvailable:\n            (pid_alive, m2ee_alive) = self.m2ee.check_alive()\n            if not pid_alive and not m2ee_alive:\n                logger.info(\"The application process is not running.\")\n        except m2ee.client.M2EEAdminException as e:\n            logger.error(e)\n        except m2ee.client.M2EEAdminHTTPException as e:\n            logger.error(e)\n        except m2ee.client.M2EERuntimeNotFullyRunning as e:\n            logger.error(e)\n        except m2ee.client.M2EEAdminTimeout as e:\n            logger.error(e)\n        except m2ee.exceptions.M2EEException as e:\n            logger.error(e)\n\n    def unchecked_onecmd(self, line):\n        super(CLI, self).onecmd(line)\n\n    # if the emptyline function is not defined, Cmd will automagically\n    # repeat the previous command given, and that's not what we want\n    def emptyline(self):\n        pass\n\n    def completenames(self, text, *ignored):\n        do_text = \"do_%s\" % text\n        suggestions = [a[3:] for a in self.get_names() if a.startswith(do_text)]\n        if len(suggestions) == 1 \\\n                and \"complete_%s\" % suggestions[0] in self.get_names():\n            suggestions[0] = \"%s \" % suggestions[0]\n        return suggestions\n\n    def do_help(self, args):\n        print(\"\"\"Welcome to m2ee, the Mendix Runtime helper tools.\n\nAvailable commands:\n unpack - unpack an uploaded Mendix Deployment Archive from data/model-upload\n download_runtime - download a missing Mendix Runtime distribution\n start - try starting the application using the unpacked deployment files\n stop - stop the application\n restart - restart the application\n status - display Mendix Runtime status (is the application running?\n create_admin_user - create first user when starting with an empty database\n update_admin_user - reset the password of an application user\n who, w - show currently logged in users\n log - follow live logging from the application\n loglevel - view and configure loglevels\n about - show Mendix Runtime version information\n check_constants - check for missing or unneeded constant definitions\n enable_debugger - enable remote debugger API\n disable_debugger - disable remote debugger API\n show_debugger_status - show whether debugger is enabled or not\n show_current_runtime_requests - show action stack of current running requests\n interrupt_request - cancel a running runtime request\n show_license_information - show details about current mendix license key\n show_cache_statistics - show details about the runtime object cache\n cleanup_runtimes - clean up downloaded Mendix Runtime versions, except the\n     one currently in use\n cleanup_runtimes_except [<version> <version> ...] - clean up downloaded Mendix\n     Runtime versions, except the one currently in use and other ones specified\n exit, quit, <ctrl>-d - exit m2ee\n\"\"\")\n\n        if self.m2ee.config.is_using_postgresql():\n            print(\"\"\"When using PostgreSQL, you can also use:\n psql - start the postgresql shell\n dumpdb - create a database dump into the data/database folder\n emptydb - drop all tables and sequences from the database\n restoredb - restore a database dump from the data/database folder\n\"\"\")\n\n        if args == 'expert':\n            print(\"\"\"Advanced commands:\n statistics - show all application statistics that can be used for monitoring\n show_all_thread_stack_traces - show all low-level JVM threads with stack trace\n check_health - manually execute health check\n\nExtra commands you probably don't need:\n debug - dive into a local python debug session inside this program\n dump_config - dump the yaml configuration information\n nodetach - do not detach the application process after starting\n reload - reload configuration from yaml files (this is done automatically)\n munin_config - configure option for the built-in munin plugin\n munin_values - show monitoring output gathered by the built-in munin plugin\n nagios - execute the built-in nagios plugin (will exit m2ee)\n activate_license - DANGEROUS - replace/set license key\n\"\"\")\n\n        print(\"Hint: use tab autocompletion for commands!\")\n\n        if args != 'expert':\n            print(\"Use help expert to show expert and debugging commands\")\n\n\ndef start_console_logging(level):\n    logger = logging.getLogger()\n    logger.setLevel(level)\n    consolelogformatter = logging.Formatter(\"%(levelname)s: %(message)s\")\n\n    class M2EELogFilter(logging.Filter):\n        def __init__(self, level, ge):\n            self.level = level\n            # log levels greater than and equal to (True), or below (False)\n            self.ge = ge\n\n        def filter(self, record):\n            if self.ge:\n                return record.levelno >= self.level\n            return record.levelno < self.level\n\n    # log everything below ERROR to to stdout\n    stdoutlog = logging.StreamHandler(sys.stdout)\n    stdoutlog.setFormatter(consolelogformatter)\n    stdoutfilter = M2EELogFilter(logging.ERROR, False)\n    stdoutlog.addFilter(stdoutfilter)\n\n    # log everything that's ERROR and more serious to stderr\n    stderrlog = logging.StreamHandler(sys.stderr)\n    stderrlog.setFormatter(consolelogformatter)\n    stderrfilter = M2EELogFilter(logging.ERROR, True)\n    stderrlog.addFilter(stderrfilter)\n\n    logger.addHandler(stdoutlog)\n    logger.addHandler(stderrlog)\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"-c\",\n        action=\"append\",\n        dest=\"yaml_files\"\n    )\n    parser.add_argument(\n        \"-v\",\n        \"--verbose\",\n        action=\"count\",\n        dest=\"verbose\",\n        default=0,\n        help=\"increase verbosity of output (-vv to be even more verbose)\"\n    )\n    parser.add_argument(\n        \"-q\",\n        \"--quiet\",\n        action=\"count\",\n        dest=\"quiet\",\n        default=0,\n        help=\"decrease verbosity of output (-qq to be even more quiet)\"\n    )\n    parser.add_argument(\n        \"-y\",\n        \"--yolo\",\n        action=\"store_true\",\n        default=False,\n        dest=\"yolo_mode\",\n        help=\"automatically answer all questions to run as non-interactively as possible\"\n    )\n    parser.add_argument(\n        \"onecmd\",\n        nargs='*',\n    )\n    args = parser.parse_args()\n\n    # how verbose should we be? see\n    # http://docs.python.org/release/2.7/library/logging.html#logging-levels\n    verbosity = args.quiet - args.verbose\n    if args.quiet:\n        verbosity = verbosity + args.quiet\n    if args.verbose:\n        verbosity = verbosity - args.verbose\n    verbosity = verbosity * 10 + 20\n    if verbosity > 50:\n        verbosity = 100\n    if verbosity < 5:\n        verbosity = 5\n    start_console_logging(verbosity)\n\n    try:\n        cli = CLI(\n            yaml_files=args.yaml_files,\n            yolo_mode=args.yolo_mode,\n        )\n    except m2ee.exceptions.M2EEException as e:\n        logger.critical(e)\n        sys.exit(1)\n\n    atexit.register(cli._cleanup_logging)\n    if args.onecmd:\n        try:\n            cli.unchecked_onecmd(' '.join(args.onecmd))\n        except (m2ee.client.M2EEAdminException,\n                m2ee.client.M2EEAdminHTTPException,\n                m2ee.client.M2EERuntimeNotFullyRunning,\n                m2ee.client.M2EEAdminTimeout,\n                m2ee.exceptions.M2EEException) as e:\n            logger.error(e)\n            sys.exit(1)\n        except m2ee.client.M2EEAdminNotAvailable:\n            pid_alive, m2ee_alive = cli.m2ee.check_alive()\n            if not pid_alive and not m2ee_alive:\n                logger.info(\"The application process is not running.\")\n                sys.exit(0)\n            sys.exit(1)\n    else:\n        logger.info(\"Application Name: %s\" % cli.m2ee.config.get_app_name())\n        cli.onecmd('status')\n        cli.cmdloop_handle_ctrl_c()\n\n\nif __name__ == '__main__':\n    main()\n    return\n    \n    return\n    \n\n        return\n    \n        return\n    return\n    return\n    return\n    return\n    return\n        \n    return\n    \n    return\n    return \n    \n    ",
    "after": "#!/usr/bin/python\n#\n# Copyright (C) 2009 Mendix. All rights reserved.\n#\n\nfrom __future__ import print_function\nimport argparse\nimport atexit\nimport cmd\nimport datetime\nimport getpass\nimport logging\nimport os\nimport pwd\nimport random\nimport shlex\nimport signal\nimport string\nimport subprocess\nimport sys\nimport yaml\n\nfrom m2ee import pgutil, M2EE, client_errno\nimport m2ee\n\nlogger = logging\n\nif not sys.stdout.isatty():\n    import codecs\n    import locale\n    sys.stdout = codecs.getwriter(locale.getpreferredencoding())(sys.stdout)\n\ntry:\n    raw_input\nexcept NameError:\n    raw_input = input\n\n\nclass CLI(cmd.Cmd, object):\n\n    def __init__(self, yaml_files=None, yolo_mode=False):\n        logger.debug('Using m2ee-tools version %s' % m2ee.__version__)\n        cmd.Cmd.__init__(self)\n        self.m2ee = M2EE(yaml_files=yaml_files)\n        self.yolo_mode = yolo_mode\n        self.prompt_username = pwd.getpwuid(os.getuid())[0]\n        self._default_prompt = \"m2ee(%s): \" % self.prompt_username\n        self.prompt = self._default_prompt\n        self.nodetach = False\n\n    def do_restart(self, args):\n        if self._stop():\n            self._start()\n\n    def do_stop(self, args):\n        self._stop()\n\n    def do_start(self, args):\n        self._start()\n\n    def _stop(self):\n        logger.debug(\"Trying to stop the application.\")\n        stopped = self.m2ee.stop()\n        if stopped:\n            return True\n\n        answer = None\n        while answer not in ('y', 'n'):\n            answer = ('y' if self.yolo_mode\n                      else raw_input(\"Do you want to try to signal the JVM \"\n                                     \"process to stop immediately? (y)es, (n)o? \"))\n            if answer == 'y':\n                stopped = self.m2ee.terminate()\n                if stopped:\n                    return True\n            elif answer == 'n':\n                logger.info(\"Doing nothing, use stop again to check if the \"\n                            \"process finally disappeared...\")\n                return False\n            else:\n                print(\"Unknown option %s\" % answer)\n\n        answer = None\n        while answer not in ('y', 'n'):\n            answer = ('y' if self.yolo_mode\n                      else raw_input(\"Do you want to kill the JVM process? \"\n                                     \"(y)es, (n)o? \"))\n            if answer == 'y':\n                stopped = self.m2ee.kill()\n                if stopped:\n                    return True\n            elif answer == 'n':\n                logger.info(\"Doing nothing, use stop again to check if the \"\n                            \"process finally disappeared...\")\n                return False\n            else:\n                print(\"Unknown option %s\" % answer)\n\n        return False\n\n    def _start(self):\n        \"\"\"\n        This function deals with the start-up sequence of the Mendix Runtime.\n        Starting the Mendix Runtime can fail in both a temporary or permanent\n        way. See the client_errno for possible error codes.\n        \"\"\"\n\n        if not self.m2ee.config.all_systems_are_go():\n            raise m2ee.exceptions.M2EEException(\n                \"The application cannot be started because no application \"\n                \"model is present, or because of other previous errors.\"\n            )\n\n        if not self.m2ee.config.get_runtime_path():\n            raise m2ee.exceptions.M2EEException(\n                \"It appears that the Mendix Runtime version which has to be \"\n                \"used for your application is not present yet. You can try \"\n                \"downloading it using the download_runtime command.\"\n            )\n\n        self.m2ee.start_appcontainer(detach=not self.nodetach)\n\n        try:\n            self.m2ee.send_runtime_config()\n        except m2ee.client.M2EEAdminException as e:\n            logger.error(\"Sending configuration failed: %s\" % e.cause)\n            logger.error(\"You'll have to fix the configuration and run start again...\")\n            self._stop()\n            return\n\n        abort = False\n        fully_started = False\n        params = {}\n        while not (fully_started or abort):\n            try:\n                self.m2ee.start_runtime(params)\n                fully_started = True\n            except m2ee.client.M2EEAdminException as e:\n                logger.error(e)\n                if e.result == client_errno.start_NO_EXISTING_DB:\n                    if self.yolo_mode:\n                        # This call tries to create a database and immediately execute\n                        # ddl commands.\n                        self.m2ee.client.execute_ddl_commands()\n                    else:\n                        abort = True\n                elif e.result == client_errno.start_INVALID_DB_STRUCTURE:\n                    answer = self._handle_ddl_commands()\n                    if answer == 'a':\n                        abort = True\n                elif e.result == client_errno.start_MISSING_MF_CONSTANT:\n                    logger.error(\"You'll have to add the constant definitions \"\n                                 \"to the configuration in the \"\n                                 \"MicroflowConstants section.\")\n                    abort = True\n                elif e.result == client_errno.start_ADMIN_1:\n                    users = e.feedback['users']\n                    if self.yolo_mode:\n                        self._handle_admin_1_yolo(users)\n                    else:\n                        answer = self._handle_admin_1(users)\n                        if answer == 'a':\n                            abort = True\n                else:\n                    abort = True\n\n        if abort:\n            self._stop()\n\n    def _handle_ddl_commands(self):\n        feedback = self.m2ee.client.get_ddl_commands({\"verbose\": True})\n        answer = None\n        while answer not in ('v', 's', 'e', 'a'):\n            answer = ('e' if self.yolo_mode\n                      else raw_input(\"Do you want to (v)iew queries, (s)ave them to \"\n                                     \"a file, (e)xecute and save them, or (a)bort: \"))\n            if answer == 'a':\n                pass\n            elif answer == 'v':\n                print('\\n'.join(feedback['ddl_commands']))\n                answer = None\n            elif answer in ('e', 's'):\n                ddl_commands = feedback['ddl_commands']\n                self.m2ee.save_ddl_commands(ddl_commands)\n                if answer == 'e':\n                    self.m2ee.client.execute_ddl_commands()\n            else:\n                print(\"Unknown option %s\" % answer)\n        return answer\n\n    def _handle_admin_1(self, users):\n        answer = None\n        while answer not in ('c', 'a'):\n            answer = raw_input(\"Do you want to (c)hange passwords or \"\n                               \"(a)bort: \")\n            if answer == 'a':\n                pass\n            elif answer == 'c':\n                for username in users:\n                    changed = False\n                    while not changed:\n                        newpw1 = getpass.getpass(\"Type new password for user \"\n                                                 \"%s: \" % username)\n                        newpw2 = getpass.getpass(\"Type new password for user \"\n                                                 \" %s again: \" % username)\n                        if newpw1 != newpw2:\n                            print(\"The passwords are not equal!\")\n                        else:\n                            try:\n                                self.m2ee.client.update_admin_user(\n                                    {\"username\": username, \"password\": newpw1})\n                                changed = True\n                            except m2ee.client.M2EEAdminException as e:\n                                logger.error(e)\n            else:\n                print(\"Unknown option %s\" % answer)\n        return answer\n\n    def _handle_admin_1_yolo(self, users):\n        for username in users:\n            newpasswd = self._generate_password()\n            logger.info(\"Changing password for user %s to %s\" %\n                        (username, newpasswd))\n            self.m2ee.client.update_admin_user({\n                \"username\": username,\n                \"password\": newpasswd,\n            })\n\n    def _generate_password(self):\n        newpasswd_list = []\n        for choosefrom in [\n            string.ascii_lowercase,\n            string.ascii_uppercase,\n            string.digits,\n            string.punctuation,\n        ]:\n            newpasswd_list.extend([random.choice(choosefrom)\n                                   for _ in range(random.randint(10, 20))])\n        random.shuffle(newpasswd_list)\n        return ''.join(newpasswd_list)\n\n    def do_create_admin_user(self, args=None):\n        if not self.m2ee.client.ping():\n            logger.warn(\"The application process needs to be running to \"\n                        \"create a user object in the application.\")\n            return\n        print(\"This option will create an administrative user account, using \"\n              \"the preset username and user role settings.\")\n        newpw1 = getpass.getpass(\"Type new password for this user: \")\n        newpw2 = getpass.getpass(\"Type new password for this user again: \")\n        if newpw1 != newpw2:\n            print(\"The passwords are not equal!\")\n        else:\n            self.m2ee.client.create_admin_user({\"password\": newpw1})\n\n    def do_update_admin_user(self, args=None):\n        if not self.m2ee.client.ping():\n            logger.warn(\"The application process needs to be running to \"\n                        \"change user objects in the application.\")\n            return\n        print(\"Using this function you can reset the password of an \"\n              \"administrative user account.\")\n        username = raw_input(\"User name: \")\n        newpw1 = getpass.getpass(\"Type new password for user %s: \" % username)\n        newpw2 = getpass.getpass(\"Type new password for user %s again: \" %\n                                 username)\n        if newpw1 != newpw2:\n            print(\"The passwords are not equal!\")\n        else:\n            self.m2ee.client.update_admin_user({\"username\": username, \"password\": newpw1})\n\n    def do_debug(self, args):\n        answer = raw_input(\"This command will throw you into a local python \"\n                           \"debug session inside the M2EE object! Continue \"\n                           \"(y/N)?\")\n        if answer == 'y':\n            import code\n            code.interact(local=locals())\n\n    def do_status(self, args):\n        feedback = self.m2ee.client.runtime_status(timeout=3)\n        status = feedback['status']\n        logger.info(\"The application process is running, the MxRuntime has status: %s\" % status)\n\n        if status != 'running':\n            return\n\n        critlist = self.m2ee.client.get_critical_log_messages()\n        if len(critlist) > 0:\n            logger.error(\"%d critical error(s) were logged. Use show_critical\"\n                         \"_log_messages to view them.\" % len(critlist))\n\n        max_show_users = 10\n        total_users = self._who(max_show_users)\n        if total_users > max_show_users:\n            logger.info(\"Only showing %s logged in users. Use who to see a \"\n                        \"complete list.\" % max_show_users)\n\n    def do_show_critical_log_messages(self, args):\n        errors = self.m2ee.client.get_critical_log_messages()\n        if len(errors) == 0:\n            logger.info(\"No messages were logged to a critical loglevel since \"\n                        \"starting the application.\")\n            return\n        for error in errors:\n            errorline = []\n            if 'message' in error and error['message'] != '':\n                errorline.append(\"- %s\" % error['message'])\n            if 'cause' in error and error['cause'] != '':\n                errorline.append(\"- Caused by: %s\" % error['cause'])\n            if len(errorline) == 0:\n                errorline.append(\"- [No message or cause was logged]\")\n            errorline.insert(\n                0,\n                datetime.datetime.fromtimestamp(error['timestamp'] / 1000)\n                .strftime(\"%Y-%m-%d %H:%M:%S\")\n            )\n            print(' '.join(errorline))\n\n    def do_check_health(self, args):\n        feedback = self.m2ee.client.check_health()\n        if feedback['health'] == 'healthy':\n            logger.info(\"Health check microflow says the application is healthy.\")\n        elif feedback['health'] == 'sick':\n            logger.warning(\"Health check microflow says the application \"\n                           \"is sick: %s\" % feedback['diagnosis'])\n        elif feedback['health'] == 'unknown':\n            logger.info(\"Health check microflow is not configured, no \"\n                        \"health information available.\")\n        else:\n            logger.error(\"Unexpected health check status: %s\" % feedback['health'])\n\n    def do_statistics(self, args):\n        stats = self.m2ee.client.runtime_statistics()\n        stats.update(self.m2ee.client.server_statistics())\n        print(yaml.safe_dump(stats, default_flow_style=False))\n\n    def do_show_cache_statistics(self, args):\n        stats = self.m2ee.client.cache_statistics()\n        print(yaml.safe_dump(stats, default_flow_style=False))\n\n    def do_munin_config(self, args):\n        m2ee.munin.print_config(\n            self.m2ee,\n            self.prompt_username,\n        )\n\n    def do_munin_values(self, args):\n        m2ee.munin.print_values(\n            self.m2ee,\n            self.prompt_username,\n        )\n\n    def do_nagios(self, args):\n        logger.info(\"The nagios plugin will exit m2ee after running, this is \"\n                    \"by design, don't report it as bug.\")\n        # TODO: implement as separate program after libraryfying m2ee\n        sys.exit(m2ee.nagios.check(self.m2ee.runner, self.m2ee.client))\n\n    def do_about(self, args):\n        print('Using m2ee-tools version %s' % m2ee.__version__)\n        feedback = self.m2ee.client.about()\n        print(\"Using %s version %s\" % (feedback['name'], feedback['version']))\n        print(feedback['copyright'])\n        if self.m2ee.config.get_runtime_version() >= 4.4:\n            if 'model_version' in feedback:\n                print('Model version: %s' % feedback['model_version'])\n\n    def do_show_license_information(self, args):\n        feedback = self.m2ee.client.get_license_information()\n        if 'license' in feedback:\n            logger.debug(yaml.safe_dump(feedback['license'],\n                         allow_unicode=True))\n            import copy\n            licensecopy = copy.deepcopy(feedback['license'])\n            self._print_license(licensecopy)\n        elif 'license_id' in feedback:\n            print(\"Unlicensed environment.\")\n            print(\"Server ID: %s\" % feedback['license_id'])\n        else:\n            print(\"Unlicensed environment.\")\n\n    def _print_license(self, licensecopy):\n        print(\"Server ID: %s\" % licensecopy.pop('LicenseID', 'Unknown'))\n        print(\"License Type: %s\" % licensecopy.pop('LicenseType', 'Unknown'))\n        if 'ExpirationDate' in licensecopy:\n            print(\"Expiration Date: %s\" %\n                  datetime.datetime.fromtimestamp(\n                      licensecopy.pop('ExpirationDate') / 1000\n                  )\n                  .strftime(\"%a, %d %b %Y %H:%M:%S %z\")\n                  .rstrip())\n        print(\"Runtime Mode: %s\" % licensecopy.pop('RuntimeMode', 'Unknown'))\n        print(\"Company: %s\" % licensecopy.pop('Company', 'Unknown'))\n\n        limitations = licensecopy.pop('UserLimitations', None)\n        separate_anonymous = licensecopy.pop('SeparateAnonymousUsers', True)\n        if limitations is not None:\n            print(\"License Limitations:\")\n            for limitation in limitations:\n                self._print_license_limitation(limitation, separate_anonymous)\n\n        if len(licensecopy) > 1:\n            print(yaml.safe_dump(licensecopy, allow_unicode=True))\n\n    def _print_license_limitation(self, limitation, separate_anonymous):\n        if limitation['LimitationType'] == 'Named':\n            if limitation['AmountType'] == 'Unlimited':\n                print(\"- Unlimited named %suser accounts allowed.\" %\n                      ('' if separate_anonymous else \"and anonymous \"))\n            else:\n                print(\" - %s named user account%s allowed\" %\n                      (limitation['NumberOfAllowedUsers'],\n                       's' if limitation['NumberOfAllowedUsers'] != 1 else ''))\n        elif limitation['LimitationType'] == 'Concurrent':\n            if limitation['AmountType'] == 'Unlimited':\n                print(\"- Unlimited concurrent named %suser sessions allowed.\"\n                      % (\"\" if separate_anonymous else \"and anonymous \"))\n            else:\n                print(\"- %s concurrent named %suser session%s allowed.\" %\n                      (\n                          limitation['NumberOfAllowedUsers'],\n                          '' if separate_anonymous else \"and anonymous \",\n                          ('s' if limitation['NumberOfAllowedUsers'] != 1\n                           else '')))\n        elif (limitation['LimitationType'] == 'ConcurrentAnonymous' and\n              separate_anonymous):\n            if limitation['AmountType'] == 'Unlimited':\n                print(\"- Unlimited concurrent anonymous user sessions \"\n                      \"allowed.\")\n            else:\n                print(\"- %s concurrent anonymous session%s allowed.\" %\n                      (\n                          limitation['NumberOfAllowedUsers'],\n                          ('s' if limitation['NumberOfAllowedUsers'] != 1\n                           else '')))\n\n    def do_activate_license(self, args):\n        self.m2ee.client.require_action(\"set_license\")\n        print(\"The command activate_license will set the license key used in \"\n              \"this application.\")\n        runtime_version = m2ee.version.MXVersion(self.m2ee.client.about()['version'])\n        if runtime_version < 4.1:\n            print(\"Mendix Runtime versions before 4.1 do not check the \"\n                  \"submitted license key for validity, so incorrect input \"\n                  \"will un-license your Mendix application without warning! \"\n                  \"After setting the license, use show_license_information \"\n                  \"to check the active license. Also... after setting the \"\n                  \"license in versions before Mendix 4.1 you will need to \"\n                  \"restart the application again to be sure it is fully \"\n                  \"activated.\")\n            answer = raw_input(\"Do you want to continue anyway? (type YES if \"\n                               \"you want to): \")\n            if answer != 'YES':\n                print(\"Aborting.\")\n                return\n        if not args:\n            license_key = raw_input(\"Paste your license key (a long text \"\n                                    \"string without newlines) or empty input \"\n                                    \"to abort: \")\n        else:\n            license_key = args\n        if not license_key:\n            print(\"Aborting.\")\n            return\n        self.m2ee.client.set_license({'license_key': license_key})\n\n    def do_enable_debugger(self, args):\n        self.m2ee.client.require_action(\"enable_debugger\")\n        if not args:\n            debugger_password = raw_input(\n                \"Please enter the password to be used for remote debugger \"\n                \"access from the modeler, or leave blank to auto-generate \"\n                \"a password: \")\n            if not debugger_password:\n                debugger_password = ''.join(\n                    random.choice(string.letters + string.digits)\n                    for x in range(random.randint(20, 30)))\n        else:\n            debugger_password = args\n        self.m2ee.client.enable_debugger({'password': debugger_password})\n        logger.info(\"The remote debugger is now enabled, the password to \"\n                    \"use is %s\" % debugger_password)\n        logger.info(\"You can use the remote debugger option in the Mendix \"\n                    \"Business Modeler to connect to the /debugger/ sub \"\n                    \"url on your application (e.g. \"\n                    \"https://app.example.com/debugger/). \")\n\n    def do_disable_debugger(self, args):\n        self.m2ee.client.disable_debugger()\n        logger.info(\"The remote debugger is now disabled.\")\n\n    def do_show_debugger_status(self, args):\n        feedback = self.m2ee.client.get_debugger_status()\n        enabled = feedback['enabled']\n        connected = feedback['client_connected']\n        paused = feedback['number_of_paused_microflows']\n\n        logger.info(\"The remote debugger is currently %s.\" %\n                    (\"enabled\" if enabled else \"disabled\"))\n        if connected:\n            logger.info(\"A debugger session is connected.\")\n        elif enabled:\n            logger.info(\"There is no connected debugger session.\")\n        if enabled and paused == 0:\n            logger.info(\"There are no paused microflows.\")\n        elif paused == 1:\n            logger.info(\"There is 1 paused microflow.\")\n        elif paused > 1:\n            logger.info(\"There are %s paused microflows.\" % paused)\n\n    def do_who(self, args):\n        if args:\n            try:\n                limitint = int(args)\n                self._who(limitint)\n            except ValueError:\n                logger.warn(\"Could not parse argument to an integer. Use a \"\n                            \"number as argument to limit the amount of logged \"\n                            \"in users shown.\")\n        else:\n            self._who()\n\n    def do_w(self, args):\n        self.do_who(args)\n\n    def do_reload(self, args):\n        logger.debug(\"Reloading configuration...\")\n        self.m2ee.reload_config()\n\n    def do_dump_config(self, args):\n        self.m2ee.config.dump()\n\n    def do_set_database_password(self, args):\n        password = getpass.getpass(\"Database password: \")\n        self.m2ee.config.set_database_password(password)\n\n    def do_psql(self, args):\n        if not self.m2ee.config.is_using_postgresql():\n            logger.error(\"Only PostgreSQL databases are supported right now.\")\n            return\n        pgutil.psql(self.m2ee.config)\n\n    def do_dumpdb(self, args):\n        if not self.m2ee.config.is_using_postgresql():\n            logger.error(\"Only PostgreSQL databases are supported right now.\")\n            return\n        if len(args) > 0:\n            pgutil.dumpdb(self.m2ee.config, args)\n        else:\n            pgutil.dumpdb(self.m2ee.config)\n\n    def do_restoredb(self, args):\n        if not self.m2ee.config.allow_destroy_db():\n            logger.error(\"Refusing to do a destructive database operation \"\n                         \"because the allow_destroy_db configuration option \"\n                         \"is set to false.\")\n            return\n        if not self.m2ee.config.is_using_postgresql():\n            logger.error(\"Only PostgreSQL databases are supported right now.\")\n            return\n        if not args:\n            logger.error(\"restoredb needs the name of a dump file in %s as arg\"\n                         \"ument\" % self.m2ee.config.get_database_dump_path())\n            return\n        (pid_alive, m2ee_alive) = self.m2ee.check_alive()\n        if pid_alive or m2ee_alive:\n            logger.warn(\"The application is still running, refusing to \"\n                        \"restore the database right now.\")\n            return\n        database_name = self.m2ee.config.get_pg_environment()['PGDATABASE']\n        answer = ('y' if self.yolo_mode\n                  else raw_input(\"This command will restore this dump into database \"\n                                 \"%s. Continue? (y)es, (N)o? \" % database_name))\n        if answer != 'y':\n            logger.info(\"Aborting!\")\n            return\n        pgutil.restoredb(self.m2ee.config, args)\n\n    def complete_restoredb(self, text, line, begidx, endidx):\n        if not self.m2ee.config.is_using_postgresql():\n            return []\n        database_dump_path = self.m2ee.config.get_database_dump_path()\n        return [f for f in os.listdir(database_dump_path)\n                if os.path.isfile(os.path.join(database_dump_path, f)) and\n                f.startswith(text) and\n                f.endswith(\".backup\")]\n\n    def do_emptydb(self, args):\n        if not self.m2ee.config.allow_destroy_db():\n            logger.error(\"Refusing to do a destructive database operation \"\n                         \"because the allow_destroy_db configuration option \"\n                         \"is set to false.\")\n            return\n        if not self.m2ee.config.is_using_postgresql():\n            logger.error(\"Only PostgreSQL databases are supported right now.\")\n            return\n        (pid_alive, m2ee_alive) = self.m2ee.check_alive()\n        if pid_alive or m2ee_alive:\n            logger.warn(\"The application process is still running, refusing \"\n                        \"to empty the database right now.\")\n            return\n        logger.info(\"This command will drop all tables and sequences in \"\n                    \"database %s.\" %\n                    self.m2ee.config.get_pg_environment()['PGDATABASE'])\n        answer = ('y' if self.yolo_mode\n                  else raw_input(\"Continue? (y)es, (N)o? \"))\n        if answer != 'y':\n            print(\"Aborting!\")\n            return\n        pgutil.emptydb(self.m2ee.config)\n\n    def do_unpack(self, args):\n        if not args:\n            logger.error(\"unpack needs the name of a model upload zipfile in \"\n                         \"%s as argument\" %\n                         self.m2ee.config.get_model_upload_path())\n            return\n        (pid_alive, m2ee_alive) = self.m2ee.check_alive()\n        if pid_alive or m2ee_alive:\n            logger.error(\"The application process is still running, refusing \"\n                         \"to unpack a new application model right now.\")\n            return\n        logger.info(\"This command will replace the contents of the model/ and \"\n                    \"web/ locations, using the files extracted from the \"\n                    \"archive\")\n        answer = ('y' if self.yolo_mode\n                  else raw_input(\"Continue? (y)es, (N)o? \"))\n        if answer != 'y':\n            logger.info(\"Aborting!\")\n            return\n        self.m2ee.unpack(args)\n\n    def complete_unpack(self, text, line, begidx, endidx):\n        # these complete functions seem to eat exceptions, which is very bad\n        # behaviour if anything here throws an excaption, you just won't get\n        # completion, without knowing why\n        model_upload_path = self.m2ee.config.get_model_upload_path()\n        logger.trace(\"complete_unpack: Looking for %s in %s\" %\n                     (text, model_upload_path))\n        return [f for f in os.listdir(model_upload_path)\n                if os.path.isfile(os.path.join(model_upload_path, f))\n                and f.startswith(text)\n                and (f.endswith(\".zip\") or f.endswith(\".mda\"))]\n\n    def do_check_constants(self, args):\n        constants_to_use, default_constants, obsolete_constants = self.m2ee.config.get_constants()\n        if len(default_constants) > 0:\n            logger.info('Missing constant definitions (model defaults will be used):')\n            for name in sorted(default_constants.keys()):\n                logger.info('- %s' % name)\n        else:\n            logger.info('All required constant definitions have explicit definitions.')\n        if len(obsolete_constants) > 0:\n            logger.info('Constants defined but not needed by the application:')\n            for name in sorted(obsolete_constants.keys()):\n                logger.info('- %s' % name)\n\n    def do_log(self, args):\n        if self._cleanup_logging():\n            return\n        logfile = self.m2ee.config.get_logfile()\n        if not logfile:\n            logger.warn(\"logfile location is not specified\")\n            return\n        print(\"This command will start printing log information from the \"\n              \"application right in the middle of all of the other output on \"\n              \"your screen. This can be confusing, especially when you're \"\n              \"typing something and everything gets messed up by the logging. \"\n              \"Issuing the log command again will turn off logging output.\")\n        answer = ('y' if self.yolo_mode\n                  else raw_input(\"Do you want to start log output (y/N): \"))\n        if answer == 'y':\n            cmd = (\"tail\", \"-F\", logfile)\n            proc = subprocess.Popen(cmd)\n            self.m2ee._logproc = proc\n            self.prompt = \"LOG %s\" % self._default_prompt\n\n    def do_loglevel(self, args):\n        try:\n            args = shlex.split(args)\n        except ValueError as ve:\n            logger.error(\"Input cannot be parsed: %s\" % ve.message)\n            return\n        if len(args) == 3:\n            (subscriber, node, level) = args\n            self._set_log_level(subscriber, node, level)\n        else:\n            if len(args) == 0:\n                self._get_log_levels()\n            print(\"To adjust loglevels, use: loglevel <subscribername> \"\n                  \"<lognodename> <level>\")\n            print(\"Available levels: NONE, CRITICAL, ERROR, WARNING, INFO, \"\n                  \"DEBUG, TRACE\")\n\n    def _get_log_levels(self):\n        log_levels = self.m2ee.get_log_levels()\n        print(\"Current loglevels:\")\n        log_subscribers = []\n        for (subscriber_name, node_names) in log_levels.items():\n            for (node_name, subscriber_level) in node_names.items():\n                log_subscribers.append(\"%s %s %s\" %\n                                       (subscriber_name,\n                                        node_name,\n                                        subscriber_level))\n        log_subscribers.sort()\n        print(\"\\n\".join(log_subscribers))\n\n    def _set_log_level(self, subscriber, node, level):\n        level = level.upper()\n        try:\n            self.m2ee.set_log_level(subscriber, node, level)\n            logger.info(\"Loglevel for %s set to %s\" % (node, level))\n        except m2ee.client.M2EEAdminException as e:\n            print(\"Remember, all parameters are case sensitive\")\n            raise e\n\n    def do_show_current_runtime_requests(self, args):\n        feedback = self.m2ee.client.get_current_runtime_requests()\n        if len(feedback) == 0:\n            logger.info(\"There are no currently running runtime requests.\")\n        else:\n            print(\"Current running Runtime Requests:\")\n            print(yaml.safe_dump(feedback, default_flow_style=False))\n\n    def do_show_all_thread_stack_traces(self, args):\n        feedback = self.m2ee.client.get_all_thread_stack_traces()\n        print(\"Current JVM Thread Stacktraces:\")\n        print(yaml.safe_dump(feedback, default_flow_style=False))\n\n    def do_interrupt_request(self, args):\n        if args == \"\":\n            logger.error(\"This function needs a request id as parameter\")\n            logger.error(\"Use show_current_runtime_requests to view currently \"\n                         \"running requests\")\n            return\n        feedback = self.m2ee.client.interrupt_request({\"request_id\": args})\n        if feedback[\"result\"] is False:\n            logger.error(\"A request with ID %s was not found\" % args)\n        else:\n            logger.info(\"An attempt to cancel the running action was \"\n                        \"made.\")\n\n    def do_nodetach(self, args):\n        self.nodetach = True\n        logger.info(\"Setting nodetach, application process will not run in the background.\")\n\n    def do_exit(self, args):\n        return self._exit()\n\n    def do_quit(self, args):\n        return self._exit()\n\n    def do_EOF(self, args):\n        print(\"exit\")\n        return self._exit()\n\n    def _exit(self):\n        if self.m2ee.runner.check_attached_proc():\n            logger.warning(\"There is still an attached application process running. \"\n                           \"Stop it first.\")\n            return None\n        return -1\n\n    def do_download_runtime(self, args):\n        if args:\n            mxversion = m2ee.version.MXVersion(args)\n        else:\n            mxversion = self.m2ee.config.get_runtime_version()\n\n        if mxversion is None:\n            logger.info(\"You did not specify a Mendix Runtime version to \"\n                        \"download, and no current unpacked application \"\n                        \"model is available to determine the version from. \"\n                        \"Specify a version number or use unpack first.\")\n            return\n\n        if self.m2ee.config.lookup_in_mxjar_repo(str(mxversion)):\n            logger.info(\"The Mendix Runtime for version %s is already \"\n                        \"installed. If you want to download another Runtime \"\n                        \"version, specify the version number as argument to \"\n                        \"download_runtime.\" % mxversion)\n            return\n        self.m2ee.download_and_unpack_runtime(mxversion)\n\n    def do_cleanup_runtimes(self, args):\n        self.m2ee.cleanup_runtimes_except([])\n\n    def do_cleanup_runtimes_except(self, args):\n        self.m2ee.cleanup_runtimes_except(args.split())\n\n    def complete_cleanup_runtimes_except(self, text, line, begidx, endidx):\n        words = line[:len(line)-len(text)].split()\n        found_versions = self.m2ee.list_installed_runtimes()\n        return [\"%s \" % version for version in found_versions\n                if version.startswith(text)\n                and version not in words[1:]]\n\n    def _cleanup_logging(self):\n        # atexit\n        if self.m2ee._logproc:\n            logger.debug(\"Stopping log output...\")\n            self.prompt = self._default_prompt\n            if not self.m2ee._logproc.poll():\n                os.kill(self.m2ee._logproc.pid, signal.SIGTERM)\n            self.m2ee._logproc = None\n            return True\n        return False\n\n    def _who(self, limitint=None):\n        limit = {}\n        if limitint is not None:\n            limit = {\"limit\": limitint}\n        feedback = self.m2ee.client.get_logged_in_user_names(limit)\n        logger.info(\"Logged in users: (%s) %s\" %\n                    (feedback['count'], feedback['users']))\n        return feedback['count']\n\n    def precmd(self, line):\n        try:\n            self.m2ee.reload_config_if_changed()\n        except m2ee.exceptions.M2EEException as e:\n            logger.critical(e)\n            return line\n        if line:\n            logger.trace(\"Executing command: %s\" % line)\n        return line\n\n    def cmdloop_handle_ctrl_c(self):\n        quit = False\n        while quit is not True:\n            try:\n                self.cmdloop()\n                quit = True\n            except KeyboardInterrupt:\n                sys.stdout.write('\\n')\n\n    def onecmd(self, line):\n        try:\n            return super(CLI, self).onecmd(line)\n        except m2ee.client.M2EEAdminNotAvailable:\n            (pid_alive, m2ee_alive) = self.m2ee.check_alive()\n            if not pid_alive and not m2ee_alive:\n                logger.info(\"The application process is not running.\")\n        except m2ee.client.M2EEAdminException as e:\n            logger.error(e)\n        except m2ee.client.M2EEAdminHTTPException as e:\n            logger.error(e)\n        except m2ee.client.M2EERuntimeNotFullyRunning as e:\n            logger.error(e)\n        except m2ee.client.M2EEAdminTimeout as e:\n            logger.error(e)\n        except m2ee.exceptions.M2EEException as e:\n            logger.error(e)\n\n    def unchecked_onecmd(self, line):\n        super(CLI, self).onecmd(line)\n\n    # if the emptyline function is not defined, Cmd will automagically\n    # repeat the previous command given, and that's not what we want\n    def emptyline(self):\n        pass\n\n    def completenames(self, text, *ignored):\n        do_text = \"do_%s\" % text\n        suggestions = [a[3:] for a in self.get_names() if a.startswith(do_text)]\n        if len(suggestions) == 1 \\\n                and \"complete_%s\" % suggestions[0] in self.get_names():\n            suggestions[0] = \"%s \" % suggestions[0]\n        return suggestions\n\n    def do_help(self, args):\n        print(\"\"\"Welcome to m2ee, the Mendix Runtime helper tools.\n\nAvailable commands:\n unpack - unpack an uploaded Mendix Deployment Archive from data/model-upload\n download_runtime - download a missing Mendix Runtime distribution\n start - try starting the application using the unpacked deployment files\n stop - stop the application\n restart - restart the application\n status - display Mendix Runtime status (is the application running?\n create_admin_user - create first user when starting with an empty database\n update_admin_user - reset the password of an application user\n who, w - show currently logged in users\n log - follow live logging from the application\n loglevel - view and configure loglevels\n about - show Mendix Runtime version information\n check_constants - check for missing or unneeded constant definitions\n enable_debugger - enable remote debugger API\n disable_debugger - disable remote debugger API\n show_debugger_status - show whether debugger is enabled or not\n show_current_runtime_requests - show action stack of current running requests\n interrupt_request - cancel a running runtime request\n show_license_information - show details about current mendix license key\n show_cache_statistics - show details about the runtime object cache\n cleanup_runtimes - clean up downloaded Mendix Runtime versions, except the\n     one currently in use\n cleanup_runtimes_except [<version> <version> ...] - clean up downloaded Mendix\n     Runtime versions, except the one currently in use and other ones specified\n exit, quit, <ctrl>-d - exit m2ee\n\"\"\")\n\n        if self.m2ee.config.is_using_postgresql():\n            print(\"\"\"When using PostgreSQL, you can also use:\n psql - start the postgresql shell\n dumpdb - create a database dump into the data/database folder\n emptydb - drop all tables and sequences from the database\n restoredb - restore a database dump from the data/database folder\n\"\"\")\n\n        if args == 'expert':\n            print(\"\"\"Advanced commands:\n statistics - show all application statistics that can be used for monitoring\n show_all_thread_stack_traces - show all low-level JVM threads with stack trace\n check_health - manually execute health check\n\nExtra commands you probably don't need:\n debug - dive into a local python debug session inside this program\n dump_config - dump the yaml configuration information\n nodetach - do not detach the application process after starting\n reload - reload configuration from yaml files (this is done automatically)\n munin_config - configure option for the built-in munin plugin\n munin_values - show monitoring output gathered by the built-in munin plugin\n nagios - execute the built-in nagios plugin (will exit m2ee)\n activate_license - DANGEROUS - replace/set license key\n\"\"\")\n\n        print(\"Hint: use tab autocompletion for commands!\")\n\n        if args != 'expert':\n            print(\"Use help expert to show expert and debugging commands\")\n\n\ndef start_console_logging(level):\n    logger = logging.getLogger()\n    logger.setLevel(level)\n    consolelogformatter = logging.Formatter(\"%(levelname)s: %(message)s\")\n\n    class M2EELogFilter(logging.Filter):\n        def __init__(self, level, ge):\n            self.level = level\n            # log levels greater than and equal to (True), or below (False)\n            self.ge = ge\n\n        def filter(self, record):\n            if self.ge:\n                return record.levelno >= self.level\n            return record.levelno < self.level\n\n    # log everything below ERROR to to stdout\n    stdoutlog = logging.StreamHandler(sys.stdout)\n    stdoutlog.setFormatter(consolelogformatter)\n    stdoutfilter = M2EELogFilter(logging.ERROR, False)\n    stdoutlog.addFilter(stdoutfilter)\n\n    # log everything that's ERROR and more serious to stderr\n    stderrlog = logging.StreamHandler(sys.stderr)\n    stderrlog.setFormatter(consolelogformatter)\n    stderrfilter = M2EELogFilter(logging.ERROR, True)\n    stderrlog.addFilter(stderrfilter)\n\n    logger.addHandler(stdoutlog)\n    logger.addHandler(stderrlog)\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"-c\",\n        action=\"append\",\n        dest=\"yaml_files\"\n    )\n    parser.add_argument(\n        \"-v\",\n        \"--verbose\",\n        action=\"count\",\n        dest=\"verbose\",\n        default=0,\n        help=\"increase verbosity of output (-vv to be even more verbose)\"\n    )\n    parser.add_argument(\n        \"-q\",\n        \"--quiet\",\n        action=\"count\",\n        dest=\"quiet\",\n        default=0,\n        help=\"decrease verbosity of output (-qq to be even more quiet)\"\n    )\n    parser.add_argument(\n        \"-y\",\n        \"--yolo\",\n        action=\"store_true\",\n        default=False,\n        dest=\"yolo_mode\",\n        help=\"automatically answer all questions to run as non-interactively as possible\"\n    )\n    parser.add_argument(\n        \"onecmd\",\n        nargs='*',\n    )\n    args = parser.parse_args()\n\n    # how verbose should we be? see\n    # http://docs.python.org/release/2.7/library/logging.html#logging-levels\n    verbosity = args.quiet - args.verbose\n    if args.quiet:\n        verbosity = verbosity + args.quiet\n    if args.verbose:\n        verbosity = verbosity - args.verbose\n    verbosity = verbosity * 10 + 20\n    if verbosity > 50:\n        verbosity = 100\n    if verbosity < 5:\n        verbosity = 5\n    start_console_logging(verbosity)\n\n    try:\n        cli = CLI(\n            yaml_files=args.yaml_files,\n            yolo_mode=args.yolo_mode,\n        )\n    except m2ee.exceptions.M2EEException as e:\n        logger.critical(e)\n        sys.exit(1)\n\n    atexit.register(cli._cleanup_logging)\n    if args.onecmd:\n        try:\n            cli.unchecked_onecmd(' '.join(args.onecmd))\n        except (m2ee.client.M2EEAdminException,\n                m2ee.client.M2EEAdminHTTPException,\n                m2ee.client.M2EERuntimeNotFullyRunning,\n                m2ee.client.M2EEAdminTimeout,\n                m2ee.exceptions.M2EEException) as e:\n            logger.error(e)\n            sys.exit(1)\n        except m2ee.client.M2EEAdminNotAvailable:\n            pid_alive, m2ee_alive = cli.m2ee.check_alive()\n            if not pid_alive and not m2ee_alive:\n                logger.info(\"The application process is not running.\")\n                sys.exit(0)\n            sys.exit(1)\n    else:\n        logger.info(\"Application Name: %s\" % cli.m2ee.config.get_app_name())\n        cli.onecmd('status')\n        cli.cmdloop_handle_ctrl_c()\n\n\nif __name__ == '__main__':\n    main()\n    \n    \"This is a.\n\n    \n\n    \n\n    \n\n    \n    \n    \n    \n    \n    \n\n\n    \n    \n\n    \n\n\n \n    \n    \n    if you, \n\n    \n\n\n    \n\n\n    "
  },
  "feature_stats": {
    "indices": [
      1,
      4276,
      5734,
      2206,
      8217,
      1877,
      5359,
      2418,
      6897,
      5080,
      5367
    ],
    "f_before": [
      37.19411087036133,
      0.0,
      24.910737991333008,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "f_after": [
      37.19411087036133,
      0.0,
      24.910737991333008,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "g_before": [
      2.592519998550415,
      3.884350299835205,
      3.7884607315063477,
      3.6546669006347656,
      4.084388256072998,
      3.609987258911133,
      3.5356452465057373,
      3.615884780883789,
      3.6578872203826904,
      3.6706416606903076,
      3.343616008758545
    ],
    "g_after": [
      2.592519998550415,
      3.884350299835205,
      3.7884607315063477,
      3.6546669006347656,
      4.084388256072998,
      3.609987258911133,
      3.5356452465057373,
      3.615884780883789,
      3.6578872203826904,
      3.6706416606903076,
      3.343616008758545
    ],
    "num_batches_for_stats": 10
  },
  "loss_summary": {
    "train_mean_loss": 8.457677711099386,
    "train_mean_l2": 5.954684367239476,
    "train_mean_l1": 2.5029932170808316,
    "num_steps": 2000,
    "num_batches": 2000
  },
  "feature_std_summary": {
    "plot_path": "outputs/plots/20251128-000733/feature_std_layer_12.html",
    "mean_std": 0.9244738221168518,
    "max_std": 25.908597946166992
  }
}