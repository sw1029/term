{
  "model_name": "google/gemma-2-2b-it",
  "layer_idx": 12,
  "command": "main.py sae.loss_option=2 sae.loss_module=option2_loss experiment.use_multi_contrast=true sae.alpha_concept.code=0.01 sae.alpha_concept.harm=0.01 sae.alpha_concept.struct=0.01 sae.guidance_method=contrastive sae.use_l0=true sae.l0_coeff=0.001",
  "sae": {
    "input_dim": 2304,
    "sae_dim": 9216,
    "fixed_v_cnt": 3,
    "batch_size": 4,
    "epochs": 2,
    "max_steps": 2000,
    "l1_coeff": 0.005,
    "l0_coeff": 0.001,
    "use_l0": true,
    "concept_samples_per_label": 100,
    "loss_option": 2,
    "loss_module": "option2_loss",
    "concept_feature_indices": {
      "code": 0,
      "harm": 1,
      "struct": 2
    },
    "alpha_concept": {
      "code": 0.01,
      "harm": 0.01,
      "struct": 0.01
    },
    "positive_targets": {
      "code": 1,
      "harm": 1,
      "struct": 1
    },
    "guidance_method": "contrastive",
    "guidance_margin": 0.0,
    "guidance_coeff": 1.0,
    "guidance_mse_pos_value": 1.0,
    "guidance_mse_neg_value": 0.0,
    "jumprelu_bandwidth": 0.001,
    "jumprelu_init_threshold": 0.001
  },
  "gnn": {
    "use_gnn": true,
    "top_k": 10
  },
  "experiment": {
    "device": "cuda",
    "dataset_name": "wikitext",
    "dataset_config": "wikitext-2-raw-v1",
    "use_multi_contrast": true,
    "num_steering_samples_per_label": 10,
    "top_k_for_plot": 10,
    "layer_sweep": [
      12
    ],
    "strength_sweep": [
      15.0
    ]
  },
  "steering": {
    "label": "harm",
    "feature_idx": 1,
    "strength": 15.0
  },
  "prompt": "#!/usr/bin/env python\n#\n# This is the distutils setup script for pygame.\n# Full instructions are in https://www.pygame.org/wiki/GettingStarted\n#\n# To configure, compile, install, just run this script.\n#     python setup.py install\n\nDESCRIPTION = \"\"\"Pygame is a Python wrapper module for the\nSDL multimedia library. It contains python functions and classes\nthat will allow you to use SDL's support for playing cdroms,\naudio and video output, and keyboard, mouse and joystick input.\"\"\"\n\nEXTRAS = {}\n\nMETADATA = {\n    \"name\":             \"pygame\",\n    \"version\":          \"1.9.5.dev0\",\n    \"license\":          \"LGPL\",\n    \"url\":              \"https://www.pygame.org\",\n    \"author\":           \"Pete Shinners, Rene Dudfield, Marcus von Appen, Bob Pendleton, others...\",\n    \"author_email\":     \"pygame@seul.org\",\n    \"description\":      \"Python Game Development\",\n    \"long_description\": DESCRIPTION,\n}\n\nimport sys\nimport os\n\ndef compilation_help():\n    \"\"\" On failure point people to a web page for help.\n    \"\"\"\n    import platform\n    the_system = platform.system()\n    if the_system == 'Linux':\n        if hasattr(platform, 'linux_distribution'):\n            distro = platform.linux_distribution()\n            if distro[0] == 'Ubuntu':\n                the_system = 'Ubuntu'\n            elif distro[0] == 'Debian':\n                the_system = 'Debian'\n\n    help_urls = {\n        'Linux': 'https://www.pygame.org/wiki/Compilation',\n        'Ubuntu': 'https://www.pygame.org/wiki/CompileUbuntu',\n        'Debian': 'https://www.pygame.org/wiki/CompileDebian',\n        'Windows': 'https://www.pygame.org/wiki/CompileWindows',\n        'Darwin': 'https://www.pygame.org/wiki/MacCompile',\n    }\n\n    default = 'https://www.pygame.org/wiki/Compilation'\n    url = help_urls.get(platform.system(), default)\n\n    is_pypy = '__pypy__' in sys.builtin_module_names\n    if is_pypy:\n        url += '\\n    https://www.pygame.org/wiki/CompilePyPy'\n\n    print ('---')\n    print ('For help with compilation see:')\n    print ('    %s' % url)\n    print ('To contribute to pygame development see:')\n    print ('    https://www.pygame.org/contribute.html')\n    print ('---')\n\n\n\nif not hasattr(sys, 'version_info') or sys.version_info < (2,7):\n    compilation_help()\n    raise SystemExit(\"Pygame requires Python version 2.7 or above.\")\n\n#get us to the correct directory\npath = os.path.split(os.path.abspath(sys.argv[0]))[0]\nos.chdir(path)\n#os.environ[\"CFLAGS\"] = \"-W -Wall -Wpointer-arith -Wcast-qual -Winline \" + \\\n#                       \"-Wcast-align -Wconversion -Wstrict-prototypes \" + \\\n#                       \"-Wmissing-prototypes -Wmissing-declarations \" + \\\n#                       \"-Wnested-externs -Wshadow -Wredundant-decls\"\nif \"-warnings\" in sys.argv:\n    os.environ[\"CFLAGS\"] = \"-W -Wimplicit-int \" + \\\n                       \"-Wimplicit-function-declaration \" + \\\n                       \"-Wimplicit -Wmain -Wreturn-type -Wunused -Wswitch \" + \\\n                       \"-Wcomment -Wtrigraphs -Wformat -Wchar-subscripts \" + \\\n                       \"-Wuninitialized -Wparentheses \" +\\\n                       \"-Wpointer-arith -Wcast-qual -Winline -Wcast-align \" + \\\n                       \"-Wconversion -Wstrict-prototypes \" + \\\n                       \"-Wmissing-prototypes -Wmissing-declarations \" + \\\n                       \"-Wnested-externs -Wshadow -Wredundant-decls\"\n    sys.argv.remove (\"-warnings\")\n\nAUTO_CONFIG = False\nif '-auto' in sys.argv:\n    AUTO_CONFIG = True\n    sys.argv.remove('-auto')\n\n\nimport os.path, glob, stat, shutil\nimport distutils.sysconfig\nfrom distutils.core import setup, Extension, Command\nfrom distutils.extension import read_setup_file\nfrom distutils.command.install_data import install_data\nfrom distutils.command.sdist import sdist\n\n\nrevision = ''\n\n# Python 3.0 patch\nif sys.version_info[0:2] == (3, 0):\n    import distutils.version\n    def _cmp(x, y):\n        try:\n            if x < y:\n                return -1\n            elif x == y:\n                return 0\n            return 1\n        except TypeError:\n            return NotImplemented\n    distutils.version.cmp = _cmp\n    del _cmp\n\ndef add_datafiles(data_files, dest_dir, pattern):\n    \"\"\"Add directory structures to data files according to a pattern\"\"\"\n    src_dir, elements = pattern\n    def do_directory(root_dest_path, root_src_path, elements):\n        files = []\n        for e in elements:\n            if isinstance(e, list):\n                src_dir, elems = e\n                dest_path = '/'.join([root_dest_path, src_dir])\n                src_path = os.path.join(root_src_path, src_dir)\n                do_directory(dest_path, src_path, elems)\n            else:\n                files.extend(glob.glob(os.path.join(root_src_path, e)))\n        if files:\n            data_files.append((root_dest_path, files))\n    do_directory(dest_dir, src_dir, elements)\n\n# allow optionally using setuptools for bdist_egg.\nif \"-setuptools\" in sys.argv:\n    from setuptools import setup, find_packages\n    sys.argv.remove (\"-setuptools\")\nfrom setuptools import setup, find_packages\n\n\n# NOTE: the bdist_mpkg_support is for darwin.\ntry:\n    import bdist_mpkg_support\n    from setuptools import setup, Extension\nexcept ImportError:\n    pass\nelse:\n    EXTRAS.update({\n        'options': bdist_mpkg_support.options,\n        'setup_requires': ['bdist_mpkg>=0.4.2'],\n        #'install_requires': ['pyobjc'],\n        #'dependency_links': ['http://rene.f0o.com/~rene/stuff/macosx/']\n    })\n\n#headers to install\nheaders = glob.glob(os.path.join('src_c', '*.h'))\nheaders.remove(os.path.join('src_c', 'scale.h'))\n\n# option for not installing the headers.\nif \"-noheaders\" in sys.argv:\n    headers = []\n    sys.argv.remove (\"-noheaders\")\n\n\n#sanity check for any arguments\nif len(sys.argv) == 1 and sys.stdout.isatty():\n    if sys.version_info[0] >= 3:\n        reply = input('\\nNo Arguments Given, Perform Default Install? [Y/n]')\n    else:\n        reply = raw_input('\\nNo Arguments Given, Perform Default Install? [Y/n]')\n    if not reply or reply[0].lower() != 'n':\n        sys.argv.append('install')\n\n\n#make sure there is a Setup file\nif AUTO_CONFIG or not os.path.isfile('Setup'):\n    print ('\\n\\nWARNING, No \"Setup\" File Exists, Running \"buildconfig/config.py\"')\n    import buildconfig.config\n    buildconfig.config.main(AUTO_CONFIG)\n    if '-config' in sys.argv:\n        sys.exit(0)\n    print ('\\nContinuing With \"setup.py\"')\n\n\ntry:\n    s_mtime = os.stat(\"Setup\")[stat.ST_MTIME]\n    sin_mtime = os.stat(os.path.join('buildconfig', 'Setup.SDL1.in'))[stat.ST_MTIME]\n    if sin_mtime > s_mtime:\n        print ('\\n\\nWARNING, \"buildconfig/Setup.SDL1.in\" newer than \"Setup\",'\n               'you might need to modify \"Setup\".')\nexcept:\n    pass\n\n# get compile info for all extensions\ntry:\n    extensions = read_setup_file('Setup')\nexcept:\n    print (\"\"\"Error with the \"Setup\" file,\nperhaps make a clean copy from \"Setup.in\".\"\"\")\n    compilation_help()\n    raise\n\n\n#decide whether or not to enable new buffer protocol support\nenable_newbuf = False\nif sys.version_info >= (2, 6, 0):\n    try:\n        sys.pypy_version_info\n    except AttributeError:\n        enable_newbuf = True\n\nif enable_newbuf:\n    enable_newbuf_value = '1'\nelse:\n    enable_newbuf_value = '0'\nfor e in extensions:\n    e.define_macros.append(('ENABLE_NEWBUF', enable_newbuf_value))\n\n#if new buffer protocol support is disabled then remove the testing framework\nif not enable_newbuf:\n    posn = None\n    for i, e in enumerate(extensions):\n        if e.name == 'newbuffer':\n            posn = i\n    if (posn is not None):\n        del extensions[posn]\n\n# if not building font, try replacing with ftfont\nalternate_font = os.path.join('src_py', 'font.py')\nif os.path.exists(alternate_font):\n    os.remove(alternate_font)\nhave_font = False\nhave_freetype = False\nfor e in extensions:\n    if e.name == 'font':\n        have_font = True\n    if e.name == '_freetype':\n        have_freetype = True\nif not have_font and have_freetype:\n    shutil.copyfile(os.path.join('src_py', 'ftfont.py'), alternate_font)\n\n#extra files to install\ndata_path = os.path.join(distutils.sysconfig.get_python_lib(), 'pygame')\npygame_data_files = []\ndata_files = [('pygame', pygame_data_files)]\n\n#add files in distribution directory\n# pygame_data_files.append('LGPL')\n# pygame_data_files.append('readme.html')\n# pygame_data_files.append('install.html')\n\n#add non .py files in lib directory\nfor f in glob.glob(os.path.join('src_py', '*')):\n    if not f[-3:] == '.py' and not f[-4:] == '.doc' and os.path.isfile(f):\n        pygame_data_files.append(f)\n\n#tests/fixtures\nadd_datafiles(data_files, 'pygame/tests',\n              ['test',\n                  [['fixtures',\n                      [['xbm_cursors',\n                          ['*.xbm']],\n                       ['fonts',\n                          ['*.ttf', '*.otf', '*.bdf', '*.png']]]]]])\n\n#examples\nadd_datafiles(data_files, 'pygame/examples',\n              ['examples',\n                  ['readme.rst',\n                   ['data',\n                       ['*']],\n                   ['macosx',\n                       ['*.py',\n                        ['aliens_app_example',\n                            ['*.py',\n                             'README.txt',\n                             ['English.lproj',\n                                 ['aliens.icns',\n                                  ['MainMenu.nib',\n                                      ['*']]]]]]]]]])\n\n#docs\nadd_datafiles(data_files, 'pygame/docs',\n              ['docs',\n                  ['*.html',             # Navigation and help pages\n                   '*.gif',              # pygame logos\n                   '*.js',               # For doc search\n                   ['ref',               # pygame reference\n                       ['*.html',        # Reference pages\n                        '*.js',          # Comments script\n                        '*.json']],      # Comment data\n                   ['c_api',             # pygame C API\n                       ['*.html']],\n                   ['tut',               # Tutorials\n                       ['*.html',\n                        ['tom',\n                            ['*.html',\n                             '*.png']]]],\n                   ['_static',            # Sphinx added support files\n                        ['*.css',\n                         '*.png',\n                         '*.ico',\n                         '*.js']],\n                   ['_images',            # Sphinx added reST \".. image::\" refs\n                        ['*.jpg',\n                         '*.png',\n                         '*.gif']],\n                   ['_sources',           # Used for ref search\n                        ['*.txt',\n                         ['ref',\n                            ['*.txt']]]]]])\n\n#generate the version module\ndef parse_version(ver):\n    from re import findall\n    return ', '.join(s for s in findall('\\d+', ver)[0:3])\n\ndef write_version_module(pygame_version, revision):\n    vernum = parse_version(pygame_version)\n    with open(os.path.join('buildconfig', 'version.py.in'), 'r') as header_file:\n        header = header_file.read()\n    with open(os.path.join('src_py', 'version.py'), 'w') as version_file:\n        version_file.write(header)\n        version_file.write('ver = \"' + pygame_version + '\"\\n')\n        version_file.write('vernum = ' + vernum + '\\n')\n        version_file.write('rev = \"' + revision + '\"\\n')\n\nwrite_version_module(METADATA['version'], revision)\n\n#required. This will be filled if doing a Windows build.\ncmdclass = {}\n\n#try to find DLLs and copy them too  (only on windows)\nif sys.platform == 'win32':\n\n    from distutils.command.build_ext import build_ext\n\n    #add dependency DLLs to the project\n    lib_dependencies = {}\n    for e in extensions:\n        if e.name.startswith('COPYLIB_'):\n            lib_dependencies[e.name[8:]] = e.libraries\n\n    def dependencies(roots):\n        \"\"\"Return a set of dependencies for the list of library file roots\n\n        The return set is a dictionary keyed on library root name with values of 1.\n        \"\"\"\n\n        root_set = {}\n        for root in roots:\n            try:\n                deps = lib_dependencies[root]\n            except KeyError:\n                pass\n            else:\n                root_set[root] = 1\n                root_set.update(dependencies(deps))\n        return root_set\n\n    the_dlls = {}\n    required_dlls = {}\n    for e in extensions:\n        if e.name.startswith('COPYLIB_'):\n            the_dlls[e.name[8:]] = e.library_dirs[0]\n        else:\n            required_dlls.update(dependencies(e.libraries))\n\n    # join the required_dlls and the_dlls keys together.\n    lib_names = {}\n    for lib in list(required_dlls.keys()) + list(the_dlls.keys()):\n        lib_names[lib] = 1\n\n    for lib in lib_names.keys():\n        #next DLL; a distutils bug requires the paths to have Windows separators\n        f = the_dlls[lib].replace('/', os.sep)\n        if f == '_':\n            print (\"WARNING, DLL for %s library not found.\" % lib)\n        else:\n            pygame_data_files.append(f)\n\n    class WinBuildExt(build_ext):\n        \"\"\"This build_ext sets necessary environment variables for MinGW\"\"\"\n\n        # __sdl_lib_dir is possible location of msvcrt replacement import\n        # libraries, if they exist. Pygame module base only links to SDL so\n        # should have the SDL library directory as its only -L option.\n        for e in extensions:\n            if e.name == 'base':\n                __sdl_lib_dir = e.library_dirs[0].replace('/', os.sep)\n                break\n\n    cmdclass['build_ext'] = WinBuildExt\n\n    # Add the precompiled smooth scale MMX functions to transform.\n    def replace_scale_mmx():\n        for e in extensions:\n            if e.name == 'transform':\n                if '64 bit' in sys.version:\n                    e.extra_objects.append(\n                        os.path.join('buildconfig', 'obj', 'win64', 'scale_mmx.obj'))\n                else:\n                    e.extra_objects.append(\n                        os.path.join('buildconfig', 'obj', 'win32', 'scale_mmx.obj'))\n                for i in range(len(e.sources)):\n                    if e.sources[i].endswith('scale_mmx.c'):\n                        del e.sources[i]\n                        return\n    replace_scale_mmx()\n\n\n#clean up the list of extensions\nfor e in extensions[:]:\n    if e.name.startswith('COPYLIB_'):\n        extensions.remove(e) #don't compile the COPYLIBs, just clean them\n    else:\n        e.name = 'pygame.' + e.name #prepend package name on modules\n\n\n#data installer with improved intelligence over distutils\n#data files are copied into the project directory instead\n#of willy-nilly\nclass smart_install_data(install_data):\n    def run(self):\n        #need to change self.install_dir to the actual library dir\n        install_cmd = self.get_finalized_command('install')\n        self.install_dir = getattr(install_cmd, 'install_lib')\n        return install_data.run(self)\n\ncmdclass['install_data'] = smart_install_data\n\n\nclass OurSdist(sdist):\n    def initialize_options(self):\n        sdist.initialize_options(self)\n        # we do not want MANIFEST.in to appear in the root cluttering up things.\n        self.template = os.path.join('buildconfig', 'MANIFEST.in')\n\ncmdclass['sdist'] = OurSdist\n\n\nif \"bdist_msi\" in sys.argv:\n    # if you are making an msi, we want it to overwrite files\n    # we also want to include the repository revision in the file name\n    from distutils.command import bdist_msi\n    import msilib\n\n    class bdist_msi_overwrite_on_install(bdist_msi.bdist_msi):\n        def run(self):\n            bdist_msi.bdist_msi.run(self)\n\n            # Remove obsolete files.\n            comp = \"pygame1\"  # Pygame component\n            prop = comp   # Directory property\n            records = [(\"surfarray.pyd\", comp,\n                        \"SURFAR~1.PYD|surfarray.pyd\", prop, 1),\n                       (\"sndarray.pyd\", comp,\n                        \"SNDARRAY.PYD|sndarray.pyd\", prop, 1),\n                       (\"camera.pyd\", comp, \"CAMERA.PYD|camera.pyd\", prop, 1),\n                       (\"color.py\", comp, \"COLOR.PY|color.py\", prop, 1),\n                       (\"color.pyc\", comp, \"COLOR.PYC|color.pyc\", prop, 1),\n                       (\"color.pyo\", comp, \"COLOR.PYO|color.pyo\", prop, 1)]\n            msilib.add_data(self.db, \"RemoveFile\", records)\n\n            # Overwrite outdated files.\n            fullname = self.distribution.get_fullname()\n            installer_name = self.get_installer_filename(fullname)\n            print (\"changing %s to overwrite files on install\" % installer_name)\n            msilib.add_data(self.db, \"Property\", [(\"REINSTALLMODE\", \"amus\")])\n            self.db.Commit()\n\n        def get_installer_filename(self, fullname):\n            if revision:\n                fullname += '-hg_' + revision\n            return bdist_msi.bdist_msi.get_installer_filename(self, fullname)\n\n    cmdclass['bdist_msi'] = bdist_msi_overwrite_on_install\n\n\n\n\n\n\n\n# test command.  For doing 'python setup.py test'\n\nclass TestCommand(Command):\n    user_options = [ ]\n\n    def initialize_options(self):\n        self._dir = os.getcwd()\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        '''\n        runs the tests with default options.\n        '''\n        import subprocess\n        return subprocess.call([sys.executable, os.path.join('test', '__main__.py')])\n\ncmdclass['test'] = TestCommand\n\n\nclass DocsCommand(Command):\n    \"\"\" For building the pygame documentation with `python setup.py docs`.\n\n    This generates html, and documentation .h header files.\n    \"\"\"\n    user_options = [ ]\n\n    def initialize_options(self):\n        self._dir = os.getcwd()\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        '''\n        runs the tests with default options.\n        '''\n        docs_help = (\n            \"Building docs requires Python version 3.6 or above, and sphinx.\"\n        )\n        if not hasattr(sys, 'version_info') or sys.version_info < (3, 6):\n            raise SystemExit(docs_help)\n\n        import subprocess\n        try:\n            return subprocess.call([\n                sys.executable, os.path.join('buildconfig', 'makeref.py')]\n            )\n        except:\n            print(docs_help)\n            raise\n\ncmdclass['docs'] = DocsCommand\n\n\n\n# Prune empty file lists.\ndate_files = [(path, files) for path, files in data_files if files]\n\n\n\n\n\n\n\n\n\n\n#finally,\n#call distutils with all needed info\nPACKAGEDATA = {\n       \"cmdclass\":    cmdclass,\n       \"packages\":    ['pygame', 'pygame.gp2x', 'pygame.threads',\n                       'pygame.tests',\n                       'pygame.tests.test_utils',\n                       'pygame.tests.run_tests__tests',\n                       'pygame.tests.run_tests__tests.all_ok',\n                       'pygame.tests.run_tests__tests.failures1',\n                       'pygame.tests.run_tests__tests.incomplete',\n                       'pygame.tests.run_tests__tests.infinite_loop',\n                       'pygame.tests.run_tests__tests.print_stderr',\n                       'pygame.tests.run_tests__tests.print_stdout',\n                       'pygame.tests.run_tests__tests.incomplete_todo',\n                       'pygame.tests.run_tests__tests.exclude',\n                       'pygame.tests.run_tests__tests.timeout',\n                       'pygame.tests.run_tests__tests.everything',\n                       'pygame.docs',\n                       'pygame.examples'],\n       \"package_dir\": {'pygame': 'src_py',\n                       'pygame.threads': 'src_py/threads',\n                       'pygame.gp2x': 'src_py/gp2x',\n                       'pygame.tests': 'test',\n                       'pygame.docs': 'docs',\n                       'pygame.examples': 'examples'},\n       \"headers\":     headers,\n       \"ext_modules\": extensions,\n       \"data_files\":  data_files,\n       \"zip_safe\":  False,\n}\nPACKAGEDATA.update(METADATA)\nPACKAGEDATA.update(EXTRAS)\n\n\ntry:\n    setup(**PACKAGEDATA)\nexcept:\n    compilation_help()\n    raise\n\n\ndef remove_old_files():\n\n    # try and figure out where we are installed.\n\n    #pygame could be installed in a weird location because of\n    #  setuptools or something else.  The only sane way seems to be by trying\n    #  first to import it, and see where the imported one is.\n    #\n    # Otherwise we might delete some files from another installation.\n    try:\n        import pygame.base\n        use_pygame = 1\n    except:\n        use_pygame = 0\n\n    if use_pygame:\n        install_path= os.path.split(pygame.base.__file__)[0]\n        extension_ext = os.path.splitext(pygame.base.__file__)[1]\n    else:\n        if not os.path.exists(data_path):\n            return\n\n        install_path = data_path\n\n        base_file = glob.glob(os.path.join(data_path, \"base*\"))\n        if not base_file:\n            return\n\n        extension_ext = os.path.splitext(base_file[0])[1]\n\n\n\n    # here are the .so/.pyd files we need to ask to remove.\n    ext_to_remove = [\"camera\"]\n\n    # here are the .py/.pyo/.pyc files we need to ask to remove.\n    py_to_remove = [\"color\"]\n\n    os.path.join(data_path, 'color.py')\n    if os.name == \"e32\": # Don't warn on Symbian. The color.py is used as a wrapper.\n        py_to_remove = []\n\n\n\n    # See if any of the files are there.\n    extension_files = [\"%s%s\" % (x, extension_ext) for x in ext_to_remove]\n\n    py_files = [\"%s%s\" % (x, py_ext)\n                for py_ext in [\".py\", \".pyc\", \".pyo\"]\n                for x in py_to_remove]\n\n    files = py_files + extension_files\n\n    unwanted_files = []\n    for f in files:\n        unwanted_files.append( os.path.join( install_path, f ) )\n\n\n\n    ask_remove = []\n    for f in unwanted_files:\n        if os.path.exists(f):\n            ask_remove.append(f)\n\n    for f in ask_remove:\n        try:\n            print(\"trying to remove old file :%s: ...\" %f)\n            os.remove(f)\n            print(\"Successfully removed :%s:.\" % f)\n        except:\n            print(\"FAILED to remove old file :%s:\" % f)\n\n\n\nif \"install\" in sys.argv:\n    # remove some old files.\n    # only call after a successful install.  Should only reach here if there is\n    #   a successful install... otherwise setup() raises an error.\n    try:\n        remove_old_files()\n    except:\n        pass\n",
  "output": {
    "before": "#!/usr/bin/env python\n#\n# This is the distutils setup script for pygame.\n# Full instructions are in https://www.pygame.org/wiki/GettingStarted\n#\n# To configure, compile, install, just run this script.\n#     python setup.py install\n\nDESCRIPTION = \"\"\"Pygame is a Python wrapper module for the\nSDL multimedia library. It contains python functions and classes\nthat will allow you to use SDL's support for playing cdroms,\naudio and video output, and keyboard, mouse and joystick input.\"\"\"\n\nEXTRAS = {}\n\nMETADATA = {\n    \"name\":             \"pygame\",\n    \"version\":          \"1.9.5.dev0\",\n    \"license\":          \"LGPL\",\n    \"url\":              \"https://www.pygame.org\",\n    \"author\":           \"Pete Shinners, Rene Dudfield, Marcus von Appen, Bob Pendleton, others...\",\n    \"author_email\":     \"pygame@seul.org\",\n    \"description\":      \"Python Game Development\",\n    \"long_description\": DESCRIPTION,\n}\n\nimport sys\nimport os\n\ndef compilation_help():\n    \"\"\" On failure point people to a web page for help.\n    \"\"\"\n    import platform\n    the_system = platform.system()\n    if the_system == 'Linux':\n        if hasattr(platform, 'linux_distribution'):\n            distro = platform.linux_distribution()\n            if distro[0] == 'Ubuntu':\n                the_system = 'Ubuntu'\n            elif distro[0] == 'Debian':\n                the_system = 'Debian'\n\n    help_urls = {\n        'Linux': 'https://www.pygame.org/wiki/Compilation',\n        'Ubuntu': 'https://www.pygame.org/wiki/CompileUbuntu',\n        'Debian': 'https://www.pygame.org/wiki/CompileDebian',\n        'Windows': 'https://www.pygame.org/wiki/CompileWindows',\n        'Darwin': 'https://www.pygame.org/wiki/MacCompile',\n    }\n\n    default = 'https://www.pygame.org/wiki/Compilation'\n    url = help_urls.get(platform.system(), default)\n\n    is_pypy = '__pypy__' in sys.builtin_module_names\n    if is_pypy:\n        url += '\\n    https://www.pygame.org/wiki/CompilePyPy'\n\n    print ('---')\n    print ('For help with compilation see:')\n    print ('    %s' % url)\n    print ('To contribute to pygame development see:')\n    print ('    https://www.pygame.org/contribute.html')\n    print ('---')\n\n\n\nif not hasattr(sys, 'version_info') or sys.version_info < (2,7):\n    compilation_help()\n    raise SystemExit(\"Pygame requires Python version 2.7 or above.\")\n\n#get us to the correct directory\npath = os.path.split(os.path.abspath(sys.argv[0]))[0]\nos.chdir(path)\n#os.environ[\"CFLAGS\"] = \"-W -Wall -Wpointer-arith -Wcast-qual -Winline \" + \\\n#                       \"-Wcast-align -Wconversion -Wstrict-prototypes \" + \\\n#                       \"-Wmissing-prototypes -Wmissing-declarations \" + \\\n#                       \"-Wnested-externs -Wshadow -Wredundant-decls\"\nif \"-warnings\" in sys.argv:\n    os.environ[\"CFLAGS\"] = \"-W -Wimplicit-int \" + \\\n                       \"-Wimplicit-function-declaration \" + \\\n                       \"-Wimplicit -Wmain -Wreturn-type -Wunused -Wswitch \" + \\\n                       \"-Wcomment -Wtrigraphs -Wformat -Wchar-subscripts \" + \\\n                       \"-Wuninitialized -Wparentheses \" +\\\n                       \"-Wpointer-arith -Wcast-qual -Winline -Wcast-align \" + \\\n                       \"-Wconversion -Wstrict-prototypes \" + \\\n                       \"-Wmissing-prototypes -Wmissing-declarations \" + \\\n                       \"-Wnested-externs -Wshadow -Wredundant-decls\"\n    sys.argv.remove (\"-warnings\")\n\nAUTO_CONFIG = False\nif '-auto' in sys.argv:\n    AUTO_CONFIG = True\n    sys.argv.remove('-auto')\n\n\nimport os.path, glob, stat, shutil\nimport distutils.sysconfig\nfrom distutils.core import setup, Extension, Command\nfrom distutils.extension import read_setup_file\nfrom distutils.command.install_data import install_data\nfrom distutils.command.sdist import sdist\n\n\nrevision = ''\n\n# Python 3.0 patch\nif sys.version_info[0:2] == (3, 0):\n    import distutils.version\n    def _cmp(x, y):\n        try:\n            if x < y:\n                return -1\n            elif x == y:\n                return 0\n            return 1\n        except TypeError:\n            return NotImplemented\n    distutils.version.cmp = _cmp\n    del _cmp\n\ndef add_datafiles(data_files, dest_dir, pattern):\n    \"\"\"Add directory structures to data files according to a pattern\"\"\"\n    src_dir, elements = pattern\n    def do_directory(root_dest_path, root_src_path, elements):\n        files = []\n        for e in elements:\n            if isinstance(e, list):\n                src_dir, elems = e\n                dest_path = '/'.join([root_dest_path, src_dir])\n                src_path = os.path.join(root_src_path, src_dir)\n                do_directory(dest_path, src_path, elems)\n            else:\n                files.extend(glob.glob(os.path.join(root_src_path, e)))\n        if files:\n            data_files.append((root_dest_path, files))\n    do_directory(dest_dir, src_dir, elements)\n\n# allow optionally using setuptools for bdist_egg.\nif \"-setuptools\" in sys.argv:\n    from setuptools import setup, find_packages\n    sys.argv.remove (\"-setuptools\")\nfrom setuptools import setup, find_packages\n\n\n# NOTE: the bdist_mpkg_support is for darwin.\ntry:\n    import bdist_mpkg_support\n    from setuptools import setup, Extension\nexcept ImportError:\n    pass\nelse:\n    EXTRAS.update({\n        'options': bdist_mpkg_support.options,\n        'setup_requires': ['bdist_mpkg>=0.4.2'],\n        #'install_requires': ['pyobjc'],\n        #'dependency_links': ['http://rene.f0o.com/~rene/stuff/macosx/']\n    })\n\n#headers to install\nheaders = glob.glob(os.path.join('src_c', '*.h'))\nheaders.remove(os.path.join('src_c', 'scale.h'))\n\n# option for not installing the headers.\nif \"-noheaders\" in sys.argv:\n    headers = []\n    sys.argv.remove (\"-noheaders\")\n\n\n#sanity check for any arguments\nif len(sys.argv) == 1 and sys.stdout.isatty():\n    if sys.version_info[0] >= 3:\n        reply = input('\\nNo Arguments Given, Perform Default Install? [Y/n]')\n    else:\n        reply = raw_input('\\nNo Arguments Given, Perform Default Install? [Y/n]')\n    if not reply or reply[0].lower() != 'n':\n        sys.argv.append('install')\n\n\n#make sure there is a Setup file\nif AUTO_CONFIG or not os.path.isfile('Setup'):\n    print ('\\n\\nWARNING, No \"Setup\" File Exists, Running \"buildconfig/config.py\"')\n    import buildconfig.config\n    buildconfig.config.main(AUTO_CONFIG)\n    if '-config' in sys.argv:\n        sys.exit(0)\n    print ('\\nContinuing With \"setup.py\"')\n\n\ntry:\n    s_mtime = os.stat(\"Setup\")[stat.ST_MTIME]\n    sin_mtime = os.stat(os.path.join('buildconfig', 'Setup.SDL1.in'))[stat.ST_MTIME]\n    if sin_mtime > s_mtime:\n        print ('\\n\\nWARNING, \"buildconfig/Setup.SDL1.in\" newer than \"Setup\",'\n               'you might need to modify \"Setup\".')\nexcept:\n    pass\n\n# get compile info for all extensions\ntry:\n    extensions = read_setup_file('Setup')\nexcept:\n    print (\"\"\"Error with the \"Setup\" file,\nperhaps make a clean copy from \"Setup.in\".\"\"\")\n    compilation_help()\n    raise\n\n\n#decide whether or not to enable new buffer protocol support\nenable_newbuf = False\nif sys.version_info >= (2, 6, 0):\n    try:\n        sys.pypy_version_info\n    except AttributeError:\n        enable_newbuf = True\n\nif enable_newbuf:\n    enable_newbuf_value = '1'\nelse:\n    enable_newbuf_value = '0'\nfor e in extensions:\n    e.define_macros.append(('ENABLE_NEWBUF', enable_newbuf_value))\n\n#if new buffer protocol support is disabled then remove the testing framework\nif not enable_newbuf:\n    posn = None\n    for i, e in enumerate(extensions):\n        if e.name == 'newbuffer':\n            posn = i\n    if (posn is not None):\n        del extensions[posn]\n\n# if not building font, try replacing with ftfont\nalternate_font = os.path.join('src_py', 'font.py')\nif os.path.exists(alternate_font):\n    os.remove(alternate_font)\nhave_font = False\nhave_freetype = False\nfor e in extensions:\n    if e.name == 'font':\n        have_font = True\n    if e.name == '_freetype':\n        have_freetype = True\nif not have_font and have_freetype:\n    shutil.copyfile(os.path.join('src_py', 'ftfont.py'), alternate_font)\n\n#extra files to install\ndata_path = os.path.join(distutils.sysconfig.get_python_lib(), 'pygame')\npygame_data_files = []\ndata_files = [('pygame', pygame_data_files)]\n\n#add files in distribution directory\n# pygame_data_files.append('LGPL')\n# pygame_data_files.append('readme.html')\n# pygame_data_files.append('install.html')\n\n#add non .py files in lib directory\nfor f in glob.glob(os.path.join('src_py', '*')):\n    if not f[-3:] == '.py' and not f[-4:] == '.doc' and os.path.isfile(f):\n        pygame_data_files.append(f)\n\n#tests/fixtures\nadd_datafiles(data_files, 'pygame/tests',\n              ['test',\n                  [['fixtures',\n                      [['xbm_cursors',\n                          ['*.xbm']],\n                       ['fonts',\n                          ['*.ttf', '*.otf', '*.bdf', '*.png']]]]]])\n\n#examples\nadd_datafiles(data_files, 'pygame/examples',\n              ['examples',\n                  ['readme.rst',\n                   ['data',\n                       ['*']],\n                   ['macosx',\n                       ['*.py',\n                        ['aliens_app_example',\n                            ['*.py',\n                             'README.txt',\n                             ['English.lproj',\n                                 ['aliens.icns',\n                                  ['MainMenu.nib',\n                                      ['*']]]]]]]]]])\n\n#docs\nadd_datafiles(data_files, 'pygame/docs',\n              ['docs',\n                  ['*.html',             # Navigation and help pages\n                   '*.gif',              # pygame logos\n                   '*.js',               # For doc search\n                   ['ref',               # pygame reference\n                       ['*.html',        # Reference pages\n                        '*.js',          # Comments script\n                        '*.json']],      # Comment data\n                   ['c_api',             # pygame C API\n                       ['*.html']],\n                   ['tut',               # Tutorials\n                       ['*.html',\n                        ['tom',\n                            ['*.html',\n                             '*.png']]]],\n                   ['_static',            # Sphinx added support files\n                        ['*.css',\n                         '*.png',\n                         '*.ico',\n                         '*.js']],\n                   ['_images',            # Sphinx added reST \".. image::\" refs\n                        ['*.jpg',\n                         '*.png',\n                         '*.gif']],\n                   ['_sources',           # Used for ref search\n                        ['*.txt',\n                         ['ref',\n                            ['*.txt']]]]]])\n\n#generate the version module\ndef parse_version(ver):\n    from re import findall\n    return ', '.join(s for s in findall('\\d+', ver)[0:3])\n\ndef write_version_module(pygame_version, revision):\n    vernum = parse_version(pygame_version)\n    with open(os.path.join('buildconfig', 'version.py.in'), 'r') as header_file:\n        header = header_file.read()\n    with open(os.path.join('src_py', 'version.py'), 'w') as version_file:\n        version_file.write(header)\n        version_file.write('ver = \"' + pygame_version + '\"\\n')\n        version_file.write('vernum = ' + vernum + '\\n')\n        version_file.write('rev = \"' + revision + '\"\\n')\n\nwrite_version_module(METADATA['version'], revision)\n\n#required. This will be filled if doing a Windows build.\ncmdclass = {}\n\n#try to find DLLs and copy them too  (only on windows)\nif sys.platform == 'win32':\n\n    from distutils.command.build_ext import build_ext\n\n    #add dependency DLLs to the project\n    lib_dependencies = {}\n    for e in extensions:\n        if e.name.startswith('COPYLIB_'):\n            lib_dependencies[e.name[8:]] = e.libraries\n\n    def dependencies(roots):\n        \"\"\"Return a set of dependencies for the list of library file roots\n\n        The return set is a dictionary keyed on library root name with values of 1.\n        \"\"\"\n\n        root_set = {}\n        for root in roots:\n            try:\n                deps = lib_dependencies[root]\n            except KeyError:\n                pass\n            else:\n                root_set[root] = 1\n                root_set.update(dependencies(deps))\n        return root_set\n\n    the_dlls = {}\n    required_dlls = {}\n    for e in extensions:\n        if e.name.startswith('COPYLIB_'):\n            the_dlls[e.name[8:]] = e.library_dirs[0]\n        else:\n            required_dlls.update(dependencies(e.libraries))\n\n    # join the required_dlls and the_dlls keys together.\n    lib_names = {}\n    for lib in list(required_dlls.keys()) + list(the_dlls.keys()):\n        lib_names[lib] = 1\n\n    for lib in lib_names.keys():\n        #next DLL; a distutils bug requires the paths to have Windows separators\n        f = the_dlls[lib].replace('/', os.sep)\n        if f == '_':\n            print (\"WARNING, DLL for %s library not found.\" % lib)\n        else:\n            pygame_data_files.append(f)\n\n    class WinBuildExt(build_ext):\n        \"\"\"This build_ext sets necessary environment variables for MinGW\"\"\"\n\n        # __sdl_lib_dir is possible location of msvcrt replacement import\n        # libraries, if they exist. Pygame module base only links to SDL so\n        # should have the SDL library directory as its only -L option.\n        for e in extensions:\n            if e.name == 'base':\n                __sdl_lib_dir = e.library_dirs[0].replace('/', os.sep)\n                break\n\n    cmdclass['build_ext'] = WinBuildExt\n\n    # Add the precompiled smooth scale MMX functions to transform.\n    def replace_scale_mmx():\n        for e in extensions:\n            if e.name == 'transform':\n                if '64 bit' in sys.version:\n                    e.extra_objects.append(\n                        os.path.join('buildconfig', 'obj', 'win64', 'scale_mmx.obj'))\n                else:\n                    e.extra_objects.append(\n                        os.path.join('buildconfig', 'obj', 'win32', 'scale_mmx.obj'))\n                for i in range(len(e.sources)):\n                    if e.sources[i].endswith('scale_mmx.c'):\n                        del e.sources[i]\n                        return\n    replace_scale_mmx()\n\n\n#clean up the list of extensions\nfor e in extensions[:]:\n    if e.name.startswith('COPYLIB_'):\n        extensions.remove(e) #don't compile the COPYLIBs, just clean them\n    else:\n        e.name = 'pygame.' + e.name #prepend package name on modules\n\n\n#data installer with improved intelligence over distutils\n#data files are copied into the project directory instead\n#of willy-nilly\nclass smart_install_data(install_data):\n    def run(self):\n        #need to change self.install_dir to the actual library dir\n        install_cmd = self.get_finalized_command('install')\n        self.install_dir = getattr(install_cmd, 'install_lib')\n        return install_data.run(self)\n\ncmdclass['install_data'] = smart_install_data\n\n\nclass OurSdist(sdist):\n    def initialize_options(self):\n        sdist.initialize_options(self)\n        # we do not want MANIFEST.in to appear in the root cluttering up things.\n        self.template = os.path.join('buildconfig', 'MANIFEST.in')\n\ncmdclass['sdist'] = OurSdist\n\n\nif \"bdist_msi\" in sys.argv:\n    # if you are making an msi, we want it to overwrite files\n    # we also want to include the repository revision in the file name\n    from distutils.command import bdist_msi\n    import msilib\n\n    class bdist_msi_overwrite_on_install(bdist_msi.bdist_msi):\n        def run(self):\n            bdist_msi.bdist_msi.run(self)\n\n            # Remove obsolete files.\n            comp = \"pygame1\"  # Pygame component\n            prop = comp   # Directory property\n            records = [(\"surfarray.pyd\", comp,\n                        \"SURFAR~1.PYD|surfarray.pyd\", prop, 1),\n                       (\"sndarray.pyd\", comp,\n                        \"SNDARRAY.PYD|sndarray.pyd\", prop, 1),\n                       (\"camera.pyd\", comp, \"CAMERA.PYD|camera.pyd\", prop, 1),\n                       (\"color.py\", comp, \"COLOR.PY|color.py\", prop, 1),\n                       (\"color.pyc\", comp, \"COLOR.PYC|color.pyc\", prop, 1),\n                       (\"color.pyo\", comp, \"COLOR.PYO|color.pyo\", prop, 1)]\n            msilib.add_data(self.db, \"RemoveFile\", records)\n\n            # Overwrite outdated files.\n            fullname = self.distribution.get_fullname()\n            installer_name = self.get_installer_filename(fullname)\n            print (\"changing %s to overwrite files on install\" % installer_name)\n            msilib.add_data(self.db, \"Property\", [(\"REINSTALLMODE\", \"amus\")])\n            self.db.Commit()\n\n        def get_installer_filename(self, fullname):\n            if revision:\n                fullname += '-hg_' + revision\n            return bdist_msi.bdist_msi.get_installer_filename(self, fullname)\n\n    cmdclass['bdist_msi'] = bdist_msi_overwrite_on_install\n\n\n\n\n\n\n\n# test command.  For doing 'python setup.py test'\n\nclass TestCommand(Command):\n    user_options = [ ]\n\n    def initialize_options(self):\n        self._dir = os.getcwd()\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        '''\n        runs the tests with default options.\n        '''\n        import subprocess\n        return subprocess.call([sys.executable, os.path.join('test', '__main__.py')])\n\ncmdclass['test'] = TestCommand\n\n\nclass DocsCommand(Command):\n    \"\"\" For building the pygame documentation with `python setup.py docs`.\n\n    This generates html, and documentation .h header files.\n    \"\"\"\n    user_options = [ ]\n\n    def initialize_options(self):\n        self._dir = os.getcwd()\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        '''\n        runs the tests with default options.\n        '''\n        docs_help = (\n            \"Building docs requires Python version 3.6 or above, and sphinx.\"\n        )\n        if not hasattr(sys, 'version_info') or sys.version_info < (3, 6):\n            raise SystemExit(docs_help)\n\n        import subprocess\n        try:\n            return subprocess.call([\n                sys.executable, os.path.join('buildconfig', 'makeref.py')]\n            )\n        except:\n            print(docs_help)\n            raise\n\ncmdclass['docs'] = DocsCommand\n\n\n\n# Prune empty file lists.\ndate_files = [(path, files) for path, files in data_files if files]\n\n\n\n\n\n\n\n\n\n\n#finally,\n#call distutils with all needed info\nPACKAGEDATA = {\n       \"cmdclass\":    cmdclass,\n       \"packages\":    ['pygame', 'pygame.gp2x', 'pygame.threads',\n                       'pygame.tests',\n                       'pygame.tests.test_utils',\n                       'pygame.tests.run_tests__tests',\n                       'pygame.tests.run_tests__tests.all_ok',\n                       'pygame.tests.run_tests__tests.failures1',\n                       'pygame.tests.run_tests__tests.incomplete',\n                       'pygame.tests.run_tests__tests.infinite_loop',\n                       'pygame.tests.run_tests__tests.print_stderr',\n                       'pygame.tests.run_tests__tests.print_stdout',\n                       'pygame.tests.run_tests__tests.incomplete_todo',\n                       'pygame.tests.run_tests__tests.exclude',\n                       'pygame.tests.run_tests__tests.timeout',\n                       'pygame.tests.run_tests__tests.everything',\n                       'pygame.docs',\n                       'pygame.examples'],\n       \"package_dir\": {'pygame': 'src_py',\n                       'pygame.threads': 'src_py/threads',\n                       'pygame.gp2x': 'src_py/gp2x',\n                       'pygame.tests': 'test',\n                       'pygame.docs': 'docs',\n                       'pygame.examples': 'examples'},\n       \"headers\":     headers,\n       \"ext_modules\": extensions,\n       \"data_files\":  data_files,\n       \"zip_safe\":  False,\n}\nPACKAGEDATA.update(METADATA)\nPACKAGEDATA.update(EXTRAS)\n\n\ntry:\n    setup(**PACKAGEDATA)\nexcept:\n    compilation_help()\n    raise\n\n\ndef remove_old_files():\n\n    # try and figure out where we are installed.\n\n    #pygame could be installed in a weird location because of\n    #  setuptools or something else.  The only sane way seems to be by trying\n    #  first to import it, and see where the imported one is.\n    #\n    # Otherwise we might delete some files from another installation.\n    try:\n        import pygame.base\n        use_pygame = 1\n    except:\n        use_pygame = 0\n\n    if use_pygame:\n        install_path= os.path.split(pygame.base.__file__)[0]\n        extension_ext = os.path.splitext(pygame.base.__file__)[1]\n    else:\n        if not os.path.exists(data_path):\n            return\n\n        install_path = data_path\n\n        base_file = glob.glob(os.path.join(data_path, \"base*\"))\n        if not base_file:\n            return\n\n        extension_ext = os.path.splitext(base_file[0])[1]\n\n\n\n    # here are the .so/.pyd files we need to ask to remove.\n    ext_to_remove = [\"camera\"]\n\n    # here are the .py/.pyo/.pyc files we need to ask to remove.\n    py_to_remove = [\"color\"]\n\n    os.path.join(data_path, 'color.py')\n    if os.name == \"e32\": # Don't warn on Symbian. The color.py is used as a wrapper.\n        py_to_remove = []\n\n\n\n    # See if any of the files are there.\n    extension_files = [\"%s%s\" % (x, extension_ext) for x in ext_to_remove]\n\n    py_files = [\"%s%s\" % (x, py_ext)\n                for py_ext in [\".py\", \".pyc\", \".pyo\"]\n                for x in py_to_remove]\n\n    files = py_files + extension_files\n\n    unwanted_files = []\n    for f in files:\n        unwanted_files.append( os.path.join( install_path, f ) )\n\n\n\n    ask_remove = []\n    for f in unwanted_files:\n        if os.path.exists(f):\n            ask_remove.append(f)\n\n    for f in ask_remove:\n        try:\n            print(\"trying to remove old file :%s: ...\" %f)\n            os.remove(f)\n            print(\"Successfully removed :%s:.\" % f)\n        except:\n            print(\"FAILED to remove old file :%s:\" % f)\n\n\n\nif \"install\" in sys.argv:\n    # remove some old files.\n    # only call after a successful install.  Should only reach here if there is\n    #   a successful install... otherwise setup() raises an error.\n    try:\n        remove_old_files()\n    except:\n        pass\n```\n\n```python\nimport os\nimport sys\n\ndef get_build_type():\n    \"\"\"\n    Returns the build type, which can be either 'Debug' or 'Release'.\n    \"\"\"\n    if sys.argv[1",
    "after": "#!/usr/bin/env python\n#\n# This is the distutils setup script for pygame.\n# Full instructions are in https://www.pygame.org/wiki/GettingStarted\n#\n# To configure, compile, install, just run this script.\n#     python setup.py install\n\nDESCRIPTION = \"\"\"Pygame is a Python wrapper module for the\nSDL multimedia library. It contains python functions and classes\nthat will allow you to use SDL's support for playing cdroms,\naudio and video output, and keyboard, mouse and joystick input.\"\"\"\n\nEXTRAS = {}\n\nMETADATA = {\n    \"name\":             \"pygame\",\n    \"version\":          \"1.9.5.dev0\",\n    \"license\":          \"LGPL\",\n    \"url\":              \"https://www.pygame.org\",\n    \"author\":           \"Pete Shinners, Rene Dudfield, Marcus von Appen, Bob Pendleton, others...\",\n    \"author_email\":     \"pygame@seul.org\",\n    \"description\":      \"Python Game Development\",\n    \"long_description\": DESCRIPTION,\n}\n\nimport sys\nimport os\n\ndef compilation_help():\n    \"\"\" On failure point people to a web page for help.\n    \"\"\"\n    import platform\n    the_system = platform.system()\n    if the_system == 'Linux':\n        if hasattr(platform, 'linux_distribution'):\n            distro = platform.linux_distribution()\n            if distro[0] == 'Ubuntu':\n                the_system = 'Ubuntu'\n            elif distro[0] == 'Debian':\n                the_system = 'Debian'\n\n    help_urls = {\n        'Linux': 'https://www.pygame.org/wiki/Compilation',\n        'Ubuntu': 'https://www.pygame.org/wiki/CompileUbuntu',\n        'Debian': 'https://www.pygame.org/wiki/CompileDebian',\n        'Windows': 'https://www.pygame.org/wiki/CompileWindows',\n        'Darwin': 'https://www.pygame.org/wiki/MacCompile',\n    }\n\n    default = 'https://www.pygame.org/wiki/Compilation'\n    url = help_urls.get(platform.system(), default)\n\n    is_pypy = '__pypy__' in sys.builtin_module_names\n    if is_pypy:\n        url += '\\n    https://www.pygame.org/wiki/CompilePyPy'\n\n    print ('---')\n    print ('For help with compilation see:')\n    print ('    %s' % url)\n    print ('To contribute to pygame development see:')\n    print ('    https://www.pygame.org/contribute.html')\n    print ('---')\n\n\n\nif not hasattr(sys, 'version_info') or sys.version_info < (2,7):\n    compilation_help()\n    raise SystemExit(\"Pygame requires Python version 2.7 or above.\")\n\n#get us to the correct directory\npath = os.path.split(os.path.abspath(sys.argv[0]))[0]\nos.chdir(path)\n#os.environ[\"CFLAGS\"] = \"-W -Wall -Wpointer-arith -Wcast-qual -Winline \" + \\\n#                       \"-Wcast-align -Wconversion -Wstrict-prototypes \" + \\\n#                       \"-Wmissing-prototypes -Wmissing-declarations \" + \\\n#                       \"-Wnested-externs -Wshadow -Wredundant-decls\"\nif \"-warnings\" in sys.argv:\n    os.environ[\"CFLAGS\"] = \"-W -Wimplicit-int \" + \\\n                       \"-Wimplicit-function-declaration \" + \\\n                       \"-Wimplicit -Wmain -Wreturn-type -Wunused -Wswitch \" + \\\n                       \"-Wcomment -Wtrigraphs -Wformat -Wchar-subscripts \" + \\\n                       \"-Wuninitialized -Wparentheses \" +\\\n                       \"-Wpointer-arith -Wcast-qual -Winline -Wcast-align \" + \\\n                       \"-Wconversion -Wstrict-prototypes \" + \\\n                       \"-Wmissing-prototypes -Wmissing-declarations \" + \\\n                       \"-Wnested-externs -Wshadow -Wredundant-decls\"\n    sys.argv.remove (\"-warnings\")\n\nAUTO_CONFIG = False\nif '-auto' in sys.argv:\n    AUTO_CONFIG = True\n    sys.argv.remove('-auto')\n\n\nimport os.path, glob, stat, shutil\nimport distutils.sysconfig\nfrom distutils.core import setup, Extension, Command\nfrom distutils.extension import read_setup_file\nfrom distutils.command.install_data import install_data\nfrom distutils.command.sdist import sdist\n\n\nrevision = ''\n\n# Python 3.0 patch\nif sys.version_info[0:2] == (3, 0):\n    import distutils.version\n    def _cmp(x, y):\n        try:\n            if x < y:\n                return -1\n            elif x == y:\n                return 0\n            return 1\n        except TypeError:\n            return NotImplemented\n    distutils.version.cmp = _cmp\n    del _cmp\n\ndef add_datafiles(data_files, dest_dir, pattern):\n    \"\"\"Add directory structures to data files according to a pattern\"\"\"\n    src_dir, elements = pattern\n    def do_directory(root_dest_path, root_src_path, elements):\n        files = []\n        for e in elements:\n            if isinstance(e, list):\n                src_dir, elems = e\n                dest_path = '/'.join([root_dest_path, src_dir])\n                src_path = os.path.join(root_src_path, src_dir)\n                do_directory(dest_path, src_path, elems)\n            else:\n                files.extend(glob.glob(os.path.join(root_src_path, e)))\n        if files:\n            data_files.append((root_dest_path, files))\n    do_directory(dest_dir, src_dir, elements)\n\n# allow optionally using setuptools for bdist_egg.\nif \"-setuptools\" in sys.argv:\n    from setuptools import setup, find_packages\n    sys.argv.remove (\"-setuptools\")\nfrom setuptools import setup, find_packages\n\n\n# NOTE: the bdist_mpkg_support is for darwin.\ntry:\n    import bdist_mpkg_support\n    from setuptools import setup, Extension\nexcept ImportError:\n    pass\nelse:\n    EXTRAS.update({\n        'options': bdist_mpkg_support.options,\n        'setup_requires': ['bdist_mpkg>=0.4.2'],\n        #'install_requires': ['pyobjc'],\n        #'dependency_links': ['http://rene.f0o.com/~rene/stuff/macosx/']\n    })\n\n#headers to install\nheaders = glob.glob(os.path.join('src_c', '*.h'))\nheaders.remove(os.path.join('src_c', 'scale.h'))\n\n# option for not installing the headers.\nif \"-noheaders\" in sys.argv:\n    headers = []\n    sys.argv.remove (\"-noheaders\")\n\n\n#sanity check for any arguments\nif len(sys.argv) == 1 and sys.stdout.isatty():\n    if sys.version_info[0] >= 3:\n        reply = input('\\nNo Arguments Given, Perform Default Install? [Y/n]')\n    else:\n        reply = raw_input('\\nNo Arguments Given, Perform Default Install? [Y/n]')\n    if not reply or reply[0].lower() != 'n':\n        sys.argv.append('install')\n\n\n#make sure there is a Setup file\nif AUTO_CONFIG or not os.path.isfile('Setup'):\n    print ('\\n\\nWARNING, No \"Setup\" File Exists, Running \"buildconfig/config.py\"')\n    import buildconfig.config\n    buildconfig.config.main(AUTO_CONFIG)\n    if '-config' in sys.argv:\n        sys.exit(0)\n    print ('\\nContinuing With \"setup.py\"')\n\n\ntry:\n    s_mtime = os.stat(\"Setup\")[stat.ST_MTIME]\n    sin_mtime = os.stat(os.path.join('buildconfig', 'Setup.SDL1.in'))[stat.ST_MTIME]\n    if sin_mtime > s_mtime:\n        print ('\\n\\nWARNING, \"buildconfig/Setup.SDL1.in\" newer than \"Setup\",'\n               'you might need to modify \"Setup\".')\nexcept:\n    pass\n\n# get compile info for all extensions\ntry:\n    extensions = read_setup_file('Setup')\nexcept:\n    print (\"\"\"Error with the \"Setup\" file,\nperhaps make a clean copy from \"Setup.in\".\"\"\")\n    compilation_help()\n    raise\n\n\n#decide whether or not to enable new buffer protocol support\nenable_newbuf = False\nif sys.version_info >= (2, 6, 0):\n    try:\n        sys.pypy_version_info\n    except AttributeError:\n        enable_newbuf = True\n\nif enable_newbuf:\n    enable_newbuf_value = '1'\nelse:\n    enable_newbuf_value = '0'\nfor e in extensions:\n    e.define_macros.append(('ENABLE_NEWBUF', enable_newbuf_value))\n\n#if new buffer protocol support is disabled then remove the testing framework\nif not enable_newbuf:\n    posn = None\n    for i, e in enumerate(extensions):\n        if e.name == 'newbuffer':\n            posn = i\n    if (posn is not None):\n        del extensions[posn]\n\n# if not building font, try replacing with ftfont\nalternate_font = os.path.join('src_py', 'font.py')\nif os.path.exists(alternate_font):\n    os.remove(alternate_font)\nhave_font = False\nhave_freetype = False\nfor e in extensions:\n    if e.name == 'font':\n        have_font = True\n    if e.name == '_freetype':\n        have_freetype = True\nif not have_font and have_freetype:\n    shutil.copyfile(os.path.join('src_py', 'ftfont.py'), alternate_font)\n\n#extra files to install\ndata_path = os.path.join(distutils.sysconfig.get_python_lib(), 'pygame')\npygame_data_files = []\ndata_files = [('pygame', pygame_data_files)]\n\n#add files in distribution directory\n# pygame_data_files.append('LGPL')\n# pygame_data_files.append('readme.html')\n# pygame_data_files.append('install.html')\n\n#add non .py files in lib directory\nfor f in glob.glob(os.path.join('src_py', '*')):\n    if not f[-3:] == '.py' and not f[-4:] == '.doc' and os.path.isfile(f):\n        pygame_data_files.append(f)\n\n#tests/fixtures\nadd_datafiles(data_files, 'pygame/tests',\n              ['test',\n                  [['fixtures',\n                      [['xbm_cursors',\n                          ['*.xbm']],\n                       ['fonts',\n                          ['*.ttf', '*.otf', '*.bdf', '*.png']]]]]])\n\n#examples\nadd_datafiles(data_files, 'pygame/examples',\n              ['examples',\n                  ['readme.rst',\n                   ['data',\n                       ['*']],\n                   ['macosx',\n                       ['*.py',\n                        ['aliens_app_example',\n                            ['*.py',\n                             'README.txt',\n                             ['English.lproj',\n                                 ['aliens.icns',\n                                  ['MainMenu.nib',\n                                      ['*']]]]]]]]]])\n\n#docs\nadd_datafiles(data_files, 'pygame/docs',\n              ['docs',\n                  ['*.html',             # Navigation and help pages\n                   '*.gif',              # pygame logos\n                   '*.js',               # For doc search\n                   ['ref',               # pygame reference\n                       ['*.html',        # Reference pages\n                        '*.js',          # Comments script\n                        '*.json']],      # Comment data\n                   ['c_api',             # pygame C API\n                       ['*.html']],\n                   ['tut',               # Tutorials\n                       ['*.html',\n                        ['tom',\n                            ['*.html',\n                             '*.png']]]],\n                   ['_static',            # Sphinx added support files\n                        ['*.css',\n                         '*.png',\n                         '*.ico',\n                         '*.js']],\n                   ['_images',            # Sphinx added reST \".. image::\" refs\n                        ['*.jpg',\n                         '*.png',\n                         '*.gif']],\n                   ['_sources',           # Used for ref search\n                        ['*.txt',\n                         ['ref',\n                            ['*.txt']]]]]])\n\n#generate the version module\ndef parse_version(ver):\n    from re import findall\n    return ', '.join(s for s in findall('\\d+', ver)[0:3])\n\ndef write_version_module(pygame_version, revision):\n    vernum = parse_version(pygame_version)\n    with open(os.path.join('buildconfig', 'version.py.in'), 'r') as header_file:\n        header = header_file.read()\n    with open(os.path.join('src_py', 'version.py'), 'w') as version_file:\n        version_file.write(header)\n        version_file.write('ver = \"' + pygame_version + '\"\\n')\n        version_file.write('vernum = ' + vernum + '\\n')\n        version_file.write('rev = \"' + revision + '\"\\n')\n\nwrite_version_module(METADATA['version'], revision)\n\n#required. This will be filled if doing a Windows build.\ncmdclass = {}\n\n#try to find DLLs and copy them too  (only on windows)\nif sys.platform == 'win32':\n\n    from distutils.command.build_ext import build_ext\n\n    #add dependency DLLs to the project\n    lib_dependencies = {}\n    for e in extensions:\n        if e.name.startswith('COPYLIB_'):\n            lib_dependencies[e.name[8:]] = e.libraries\n\n    def dependencies(roots):\n        \"\"\"Return a set of dependencies for the list of library file roots\n\n        The return set is a dictionary keyed on library root name with values of 1.\n        \"\"\"\n\n        root_set = {}\n        for root in roots:\n            try:\n                deps = lib_dependencies[root]\n            except KeyError:\n                pass\n            else:\n                root_set[root] = 1\n                root_set.update(dependencies(deps))\n        return root_set\n\n    the_dlls = {}\n    required_dlls = {}\n    for e in extensions:\n        if e.name.startswith('COPYLIB_'):\n            the_dlls[e.name[8:]] = e.library_dirs[0]\n        else:\n            required_dlls.update(dependencies(e.libraries))\n\n    # join the required_dlls and the_dlls keys together.\n    lib_names = {}\n    for lib in list(required_dlls.keys()) + list(the_dlls.keys()):\n        lib_names[lib] = 1\n\n    for lib in lib_names.keys():\n        #next DLL; a distutils bug requires the paths to have Windows separators\n        f = the_dlls[lib].replace('/', os.sep)\n        if f == '_':\n            print (\"WARNING, DLL for %s library not found.\" % lib)\n        else:\n            pygame_data_files.append(f)\n\n    class WinBuildExt(build_ext):\n        \"\"\"This build_ext sets necessary environment variables for MinGW\"\"\"\n\n        # __sdl_lib_dir is possible location of msvcrt replacement import\n        # libraries, if they exist. Pygame module base only links to SDL so\n        # should have the SDL library directory as its only -L option.\n        for e in extensions:\n            if e.name == 'base':\n                __sdl_lib_dir = e.library_dirs[0].replace('/', os.sep)\n                break\n\n    cmdclass['build_ext'] = WinBuildExt\n\n    # Add the precompiled smooth scale MMX functions to transform.\n    def replace_scale_mmx():\n        for e in extensions:\n            if e.name == 'transform':\n                if '64 bit' in sys.version:\n                    e.extra_objects.append(\n                        os.path.join('buildconfig', 'obj', 'win64', 'scale_mmx.obj'))\n                else:\n                    e.extra_objects.append(\n                        os.path.join('buildconfig', 'obj', 'win32', 'scale_mmx.obj'))\n                for i in range(len(e.sources)):\n                    if e.sources[i].endswith('scale_mmx.c'):\n                        del e.sources[i]\n                        return\n    replace_scale_mmx()\n\n\n#clean up the list of extensions\nfor e in extensions[:]:\n    if e.name.startswith('COPYLIB_'):\n        extensions.remove(e) #don't compile the COPYLIBs, just clean them\n    else:\n        e.name = 'pygame.' + e.name #prepend package name on modules\n\n\n#data installer with improved intelligence over distutils\n#data files are copied into the project directory instead\n#of willy-nilly\nclass smart_install_data(install_data):\n    def run(self):\n        #need to change self.install_dir to the actual library dir\n        install_cmd = self.get_finalized_command('install')\n        self.install_dir = getattr(install_cmd, 'install_lib')\n        return install_data.run(self)\n\ncmdclass['install_data'] = smart_install_data\n\n\nclass OurSdist(sdist):\n    def initialize_options(self):\n        sdist.initialize_options(self)\n        # we do not want MANIFEST.in to appear in the root cluttering up things.\n        self.template = os.path.join('buildconfig', 'MANIFEST.in')\n\ncmdclass['sdist'] = OurSdist\n\n\nif \"bdist_msi\" in sys.argv:\n    # if you are making an msi, we want it to overwrite files\n    # we also want to include the repository revision in the file name\n    from distutils.command import bdist_msi\n    import msilib\n\n    class bdist_msi_overwrite_on_install(bdist_msi.bdist_msi):\n        def run(self):\n            bdist_msi.bdist_msi.run(self)\n\n            # Remove obsolete files.\n            comp = \"pygame1\"  # Pygame component\n            prop = comp   # Directory property\n            records = [(\"surfarray.pyd\", comp,\n                        \"SURFAR~1.PYD|surfarray.pyd\", prop, 1),\n                       (\"sndarray.pyd\", comp,\n                        \"SNDARRAY.PYD|sndarray.pyd\", prop, 1),\n                       (\"camera.pyd\", comp, \"CAMERA.PYD|camera.pyd\", prop, 1),\n                       (\"color.py\", comp, \"COLOR.PY|color.py\", prop, 1),\n                       (\"color.pyc\", comp, \"COLOR.PYC|color.pyc\", prop, 1),\n                       (\"color.pyo\", comp, \"COLOR.PYO|color.pyo\", prop, 1)]\n            msilib.add_data(self.db, \"RemoveFile\", records)\n\n            # Overwrite outdated files.\n            fullname = self.distribution.get_fullname()\n            installer_name = self.get_installer_filename(fullname)\n            print (\"changing %s to overwrite files on install\" % installer_name)\n            msilib.add_data(self.db, \"Property\", [(\"REINSTALLMODE\", \"amus\")])\n            self.db.Commit()\n\n        def get_installer_filename(self, fullname):\n            if revision:\n                fullname += '-hg_' + revision\n            return bdist_msi.bdist_msi.get_installer_filename(self, fullname)\n\n    cmdclass['bdist_msi'] = bdist_msi_overwrite_on_install\n\n\n\n\n\n\n\n# test command.  For doing 'python setup.py test'\n\nclass TestCommand(Command):\n    user_options = [ ]\n\n    def initialize_options(self):\n        self._dir = os.getcwd()\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        '''\n        runs the tests with default options.\n        '''\n        import subprocess\n        return subprocess.call([sys.executable, os.path.join('test', '__main__.py')])\n\ncmdclass['test'] = TestCommand\n\n\nclass DocsCommand(Command):\n    \"\"\" For building the pygame documentation with `python setup.py docs`.\n\n    This generates html, and documentation .h header files.\n    \"\"\"\n    user_options = [ ]\n\n    def initialize_options(self):\n        self._dir = os.getcwd()\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        '''\n        runs the tests with default options.\n        '''\n        docs_help = (\n            \"Building docs requires Python version 3.6 or above, and sphinx.\"\n        )\n        if not hasattr(sys, 'version_info') or sys.version_info < (3, 6):\n            raise SystemExit(docs_help)\n\n        import subprocess\n        try:\n            return subprocess.call([\n                sys.executable, os.path.join('buildconfig', 'makeref.py')]\n            )\n        except:\n            print(docs_help)\n            raise\n\ncmdclass['docs'] = DocsCommand\n\n\n\n# Prune empty file lists.\ndate_files = [(path, files) for path, files in data_files if files]\n\n\n\n\n\n\n\n\n\n\n#finally,\n#call distutils with all needed info\nPACKAGEDATA = {\n       \"cmdclass\":    cmdclass,\n       \"packages\":    ['pygame', 'pygame.gp2x', 'pygame.threads',\n                       'pygame.tests',\n                       'pygame.tests.test_utils',\n                       'pygame.tests.run_tests__tests',\n                       'pygame.tests.run_tests__tests.all_ok',\n                       'pygame.tests.run_tests__tests.failures1',\n                       'pygame.tests.run_tests__tests.incomplete',\n                       'pygame.tests.run_tests__tests.infinite_loop',\n                       'pygame.tests.run_tests__tests.print_stderr',\n                       'pygame.tests.run_tests__tests.print_stdout',\n                       'pygame.tests.run_tests__tests.incomplete_todo',\n                       'pygame.tests.run_tests__tests.exclude',\n                       'pygame.tests.run_tests__tests.timeout',\n                       'pygame.tests.run_tests__tests.everything',\n                       'pygame.docs',\n                       'pygame.examples'],\n       \"package_dir\": {'pygame': 'src_py',\n                       'pygame.threads': 'src_py/threads',\n                       'pygame.gp2x': 'src_py/gp2x',\n                       'pygame.tests': 'test',\n                       'pygame.docs': 'docs',\n                       'pygame.examples': 'examples'},\n       \"headers\":     headers,\n       \"ext_modules\": extensions,\n       \"data_files\":  data_files,\n       \"zip_safe\":  False,\n}\nPACKAGEDATA.update(METADATA)\nPACKAGEDATA.update(EXTRAS)\n\n\ntry:\n    setup(**PACKAGEDATA)\nexcept:\n    compilation_help()\n    raise\n\n\ndef remove_old_files():\n\n    # try and figure out where we are installed.\n\n    #pygame could be installed in a weird location because of\n    #  setuptools or something else.  The only sane way seems to be by trying\n    #  first to import it, and see where the imported one is.\n    #\n    # Otherwise we might delete some files from another installation.\n    try:\n        import pygame.base\n        use_pygame = 1\n    except:\n        use_pygame = 0\n\n    if use_pygame:\n        install_path= os.path.split(pygame.base.__file__)[0]\n        extension_ext = os.path.splitext(pygame.base.__file__)[1]\n    else:\n        if not os.path.exists(data_path):\n            return\n\n        install_path = data_path\n\n        base_file = glob.glob(os.path.join(data_path, \"base*\"))\n        if not base_file:\n            return\n\n        extension_ext = os.path.splitext(base_file[0])[1]\n\n\n\n    # here are the .so/.pyd files we need to ask to remove.\n    ext_to_remove = [\"camera\"]\n\n    # here are the .py/.pyo/.pyc files we need to ask to remove.\n    py_to_remove = [\"color\"]\n\n    os.path.join(data_path, 'color.py')\n    if os.name == \"e32\": # Don't warn on Symbian. The color.py is used as a wrapper.\n        py_to_remove = []\n\n\n\n    # See if any of the files are there.\n    extension_files = [\"%s%s\" % (x, extension_ext) for x in ext_to_remove]\n\n    py_files = [\"%s%s\" % (x, py_ext)\n                for py_ext in [\".py\", \".pyc\", \".pyo\"]\n                for x in py_to_remove]\n\n    files = py_files + extension_files\n\n    unwanted_files = []\n    for f in files:\n        unwanted_files.append( os.path.join( install_path, f ) )\n\n\n\n    ask_remove = []\n    for f in unwanted_files:\n        if os.path.exists(f):\n            ask_remove.append(f)\n\n    for f in ask_remove:\n        try:\n            print(\"trying to remove old file :%s: ...\" %f)\n            os.remove(f)\n            print(\"Successfully removed :%s:.\" % f)\n        except:\n            print(\"FAILED to remove old file :%s:\" % f)\n\n\n\nif \"install\" in sys.argv:\n    # remove some old files.\n    # only call after a successful install.  Should only reach here if there is\n    #   a successful install... otherwise setup() raises an error.\n    try:\n        remove_old_files()\n    except:\n        pass\n        #  I'm not sure what this is for.\n        #  I'm not sure what's going on.\n        # I'm not sure what I'm doing.\n        # I'm a robot"
  },
  "feature_stats": {
    "indices": [
      1,
      4860,
      1662,
      6728,
      1094,
      6870,
      2250,
      7351,
      7851,
      1231,
      5800
    ],
    "f_before": [
      43.225032806396484,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "f_after": [
      43.225032806396484,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "g_before": [
      0.0,
      4.578423976898193,
      4.649284362792969,
      4.023118019104004,
      0.003430509241297841,
      0.04382157698273659,
      0.0,
      4.241354942321777,
      4.236906051635742,
      4.111947059631348,
      0.0
    ],
    "g_after": [
      0.0,
      4.578423976898193,
      4.649284362792969,
      4.023118019104004,
      0.003430509241297841,
      0.04382157698273659,
      0.0,
      4.241354942321777,
      4.236906051635742,
      4.111947059631348,
      0.0
    ],
    "num_batches_for_stats": 10
  },
  "loss_summary": {
    "train_mean_loss": 10.201878755688668,
    "train_mean_l2": 7.170743455663324,
    "train_mean_l1": 2.9389141985476015,
    "num_steps": 2000,
    "num_batches": 2000
  },
  "feature_std_summary": {
    "plot_path": "outputs/plots/20251128-004442/feature_std_layer_12.html",
    "mean_std": 1.2031725645065308,
    "max_std": 42.59959411621094
  }
}