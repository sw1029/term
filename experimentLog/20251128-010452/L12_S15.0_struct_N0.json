{
  "model_name": "google/gemma-2-2b-it",
  "layer_idx": 12,
  "command": "main.py sae.loss_option=2 sae.loss_module=option2_loss experiment.use_multi_contrast=true sae.alpha_concept.code=0.01 sae.alpha_concept.harm=0.01 sae.alpha_concept.struct=0.01 sae.guidance_method=mse sae.guidance_mse_pos_value=1.0 sae.guidance_mse_neg_value=0.0 sae.guidance_coeff=1.0 sae.use_l0=false",
  "sae": {
    "input_dim": 2304,
    "sae_dim": 9216,
    "fixed_v_cnt": 3,
    "batch_size": 4,
    "epochs": 2,
    "max_steps": 2000,
    "l1_coeff": 0.005,
    "l0_coeff": 0.0,
    "use_l0": false,
    "concept_samples_per_label": 100,
    "loss_option": 2,
    "loss_module": "option2_loss",
    "concept_feature_indices": {
      "code": 0,
      "harm": 1,
      "struct": 2
    },
    "alpha_concept": {
      "code": 0.01,
      "harm": 0.01,
      "struct": 0.01
    },
    "positive_targets": {
      "code": 1,
      "harm": 1,
      "struct": 1
    },
    "guidance_method": "mse",
    "guidance_margin": 0.0,
    "guidance_coeff": 1.0,
    "guidance_mse_pos_value": 1.0,
    "guidance_mse_neg_value": 0.0,
    "jumprelu_bandwidth": 0.001,
    "jumprelu_init_threshold": 0.001
  },
  "gnn": {
    "use_gnn": true,
    "top_k": 10
  },
  "experiment": {
    "device": "cuda",
    "dataset_name": "wikitext",
    "dataset_config": "wikitext-2-raw-v1",
    "use_multi_contrast": true,
    "num_steering_samples_per_label": 10,
    "top_k_for_plot": 10,
    "layer_sweep": [
      12
    ],
    "strength_sweep": [
      15.0
    ]
  },
  "steering": {
    "label": "struct",
    "feature_idx": 2,
    "strength": 15.0
  },
  "prompt": "\"\"\"Tests for functions that calculate plasma parameters.\"\"\"\n\nimport numpy as np\nimport pytest\n\nfrom astropy import units as u\nfrom astropy.constants import m_e, m_p\nfrom astropy.tests.helper import assert_quantity_allclose\n\nfrom plasmapy.formulary.parameters import (\n    Alfven_speed,\n    betaH_,\n    Bohm_diffusion,\n    cs_,\n    cwp_,\n    DB_,\n    Debye_length,\n    Debye_number,\n    gyrofrequency,\n    gyroradius,\n    Hall_parameter,\n    inertial_length,\n    ion_sound_speed,\n    lambdaD_,\n    lower_hybrid_frequency,\n    magnetic_energy_density,\n    magnetic_pressure,\n    mass_density,\n    nD_,\n    oc_,\n    plasma_frequency,\n    pmag_,\n    pth_,\n    rc_,\n    rho_,\n    rhoc_,\n    thermal_pressure,\n    thermal_speed,\n    ub_,\n    upper_hybrid_frequency,\n    va_,\n    wc_,\n    wlh_,\n    wp_,\n    wuh_,\n)\nfrom plasmapy.particles import Particle\nfrom plasmapy.particles.exceptions import InvalidParticleError\nfrom plasmapy.utils.exceptions import (\n    PhysicsError,\n    PhysicsWarning,\n    PlasmaPyFutureWarning,\n    RelativityError,\n    RelativityWarning,\n)\nfrom plasmapy.utils.pytest_helpers import assert_can_handle_nparray\n\nB = 1.0 * u.T\nZ = 1\nion = \"p\"\nm_i = m_p\nn_i = 5e19 * u.m ** -3\nn_e = Z * 5e19 * u.m ** -3\nrho = n_i * m_i + n_e * m_e\nT_e = 1e6 * u.K\nT_i = 1e6 * u.K\nk_1 = 3e1 * u.m ** -1\nk_2 = 3e7 * u.m ** -1\n\nB_arr = np.array([0.001, 0.002]) * u.T\nB_nanarr = np.array([0.001, np.nan]) * u.T\nB_allnanarr = np.array([np.nan, np.nan]) * u.T\n\nrho_arr = np.array([5e-10, 2e-10]) * u.kg / u.m ** 3\nrho_infarr = np.array([np.inf, 5e19]) * u.m ** -3\nrho_negarr = np.array([-5e19, 6e19]) * u.m ** -3\n\nT_arr = np.array([1e6, 2e6]) * u.K\nT_nanarr = np.array([1e6, np.nan]) * u.K\nT_nanarr2 = np.array([np.nan, 2e6]) * u.K\nT_allnanarr = np.array([np.nan, np.nan]) * u.K\nT_negarr = np.array([1e6, -5151.0]) * u.K\n\nV = 25.2 * u.m / u.s\nV_arr = np.array([25, 50]) * u.m / u.s\nV_nanarr = np.array([25, np.nan]) * u.m / u.s\nV_allnanarr = np.array([np.nan, np.nan]) * u.m / u.s\n\nmu = m_p.to(u.u).value\n\n\nclass Test_mass_density:\n    r\"\"\"Test the mass_density function in parameters.py.\"\"\"\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, conditional\",\n        [\n            ((-1 * u.kg * u.m ** -3, \"He\"), {}, pytest.raises(ValueError)),\n            ((-1 * u.m ** -3, \"He\"), {}, pytest.raises(ValueError)),\n            ((\"not a Quantity\", \"He\"), {}, pytest.raises(TypeError)),\n            ((1 * u.m ** -3,), {}, pytest.raises(TypeError)),\n            ((1 * u.J, \"He\"), {}, pytest.raises(u.UnitTypeError)),\n            ((1 * u.m ** -3, None), {}, pytest.raises(TypeError)),\n            (\n                (1 * u.m ** -3, \"He\"),\n                {\"z_ratio\": \"not a ratio\"},\n                pytest.raises(TypeError),\n            ),\n        ],\n    )\n    def test_raises(self, args, kwargs, conditional):\n        with conditional:\n            mass_density(*args, **kwargs)\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, expected\",\n        [\n            ((1.0 * u.g * u.m ** -3, \"\"), {}, 1.0e-3 * u.kg * u.m ** -3),\n            ((5.0e12 * u.cm ** -3, \"He\"), {}, 3.32323849e-8 * u.kg * u.m ** -3),\n            (\n                (5.0e12 * u.cm ** -3, Particle(\"He\")),\n                {},\n                3.32323849e-8 * u.kg * u.m ** -3,\n            ),\n            (\n                (5.0e12 * u.cm ** -3, \"He\"),\n                {\"z_ratio\": 0.5},\n                1.66161925e-08 * u.kg * u.m ** -3,\n            ),\n            (\n                (5.0e12 * u.cm ** -3, \"He\"),\n                {\"z_ratio\": -0.5},\n                1.66161925e-08 * u.kg * u.m ** -3,\n            ),\n        ],\n    )\n    def test_values(self, args, kwargs, expected):\n        assert np.isclose(mass_density(*args, **kwargs), expected)\n\n    def test_handle_nparrays(self):\n        \"\"\"Test for ability to handle numpy array quantities\"\"\"\n        assert_can_handle_nparray(mass_density)\n\n\n# Assertions below that are in CGS units with 2-3 significant digits\n# are generally from the NRL Plasma Formulary.\n\n\nclass TestAlfvenSpeed:\n    \"\"\"Test `~plasmapy.formulary.parameters.Alfven_speed`.\"\"\"\n\n    @pytest.mark.parametrize(\"alias\", [va_])\n    def test_aliases(self, alias):\n        assert alias is Alfven_speed\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, _error\",\n        [\n            # scenarios that raise RelativityError\n            ((10 * u.T, 1.0e-10 * u.kg * u.m ** -3), {}, RelativityError),\n            ((np.inf * u.T, 1 * u.m ** -3), {\"ion\": \"p\"}, RelativityError),\n            ((-np.inf * u.T, 1 * u.m ** -3), {\"ion\": \"p\"}, RelativityError),\n            #\n            # scenarios that raise InvalidParticleError\n            ((1 * u.T, 5e19 * u.m ** -3), {\"ion\": \"spacecats\"}, InvalidParticleError),\n            #\n            # scenarios that raise TypeError\n            ((\"not a Bfield\", 1.0e-10 * u.kg * u.m ** -3), {}, TypeError),\n            ((10 * u.T, \"not a density\"), {}, TypeError),\n            ((10 * u.T, 5), {\"ion\": \"p\"}, TypeError),\n            ((1 * u.T, 1.0e18 * u.m ** -3), {\"ion\": [\"He\"]}, TypeError),\n            ((1 * u.T, 1.0e18 * u.m ** -3), {\"ion\": \"He\", \"z_mean\": \"nope\"}, TypeError),\n            #\n            # scenarios that raise UnitTypeError\n            ((1 * u.T, 1.0e18 * u.cm), {\"ion\": \"He\"}, u.UnitTypeError),\n            ((1 * u.T, 5 * u.m ** -2), {\"ion\": \"p\"}, u.UnitTypeError),\n            ((1 * u.cm, 1.0e18 * u.m ** -3), {\"ion\": \"He\"}, u.UnitTypeError),\n            ((5 * u.A, 5e19 * u.m ** -3), {\"ion\": \"p\"}, u.UnitTypeError),\n            #\n            # scenarios that raise ValueError\n            ((1 * u.T, -1.0e18 * u.m ** -3), {\"ion\": \"He\"}, ValueError),\n            (\n                (np.array([5, 6, 7]) * u.T, np.array([5, 6]) * u.m ** -3),\n                {\"ion\": \"p\"},\n                ValueError,\n            ),\n            (\n                (np.array([0.001, 0.002]) * u.T, np.array([-5e19, 6e19]) * u.m ** -3),\n                {\"ion\": \"p\"},\n                ValueError,\n            ),\n        ],\n    )\n    def test_raises(self, args, kwargs, _error):\n        \"\"\"Test scenarios that raise exceptions or warnings.\"\"\"\n        with pytest.raises(_error):\n            Alfven_speed(*args, **kwargs)\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, expected, isclose_kw, _warning\",\n        [\n            # scenarios that issue RelativityWarning\n            (\n                (5 * u.T, 5e19 * u.m ** -3),\n                {\"ion\": \"H\"},\n                15413707.39,\n                {},\n                RelativityWarning,\n            ),\n            (\n                (5 * u.T, 5e19 * u.m ** -3),\n                {\"ion\": \"H+\"},\n                15413707.39,\n                {\"rtol\": 3.0e-4},\n                RelativityWarning,\n            ),\n            (\n                (5 * u.T, 5e19 * u.m ** -3),\n                {\"ion\": \"p\"},\n                15413707.39,\n                {\"rtol\": 4.0e-4},\n                RelativityWarning,\n            ),\n            #\n            # scenarios that issue UnitsWarning\n            ((0.5, 1.0e18 * u.m ** -3), {\"ion\": \"He\"}, 5470657.93, {}, u.UnitsWarning),\n        ],\n    )\n    def test_warns(self, args, kwargs, expected, isclose_kw, _warning):\n        \"\"\"Test scenarios that issue warnings\"\"\"\n        with pytest.warns(_warning):\n            val = Alfven_speed(*args, **kwargs)\n            assert isinstance(val, u.Quantity)\n            assert val.unit == u.m / u.s\n            assert np.isclose(val.value, expected, **isclose_kw)\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, expected, isclose_kw\",\n        [\n            (\n                (1 * u.T, 1e-8 * u.kg * u.m ** -3),\n                {\"ion\": \"p\"},\n                8920620.58 * u.m / u.s,\n                {\"rtol\": 1e-6},\n            ),\n            (\n                (1 * u.T, 1e-8 * u.kg * u.m ** -3),\n                {},\n                8920620.58 * u.m / u.s,\n                {\"rtol\": 1e-6},\n            ),\n            (\n                (0.05 * u.T, 1e18 * u.m ** -3),\n                {\"ion\": \"He\"},\n                Alfven_speed(0.05 * u.T, 6.64738793e-09 * u.kg * u.m ** -3),\n                {},\n            ),\n            (\n                (0.05 * u.T, 1e18 * u.m ** -3),\n                {\"ion\": \"He+\"},\n                Alfven_speed(0.05 * u.T, 1e18 * u.m ** -3, ion=\"He\"),\n                {\"rtol\": 7e-5},\n            ),\n            (\n                (0.05 * u.T, 1e18 * u.m ** -3),\n                {\"ion\": \"He\", \"z_mean\": 2},\n                Alfven_speed(0.05 * u.T, 1e18 * u.m ** -3, ion=\"He +2\"),\n                {\"rtol\": 1.4e-4},\n            ),\n            (\n                (0.05 * u.T, 1e18 * u.m ** -3),\n                {\"ion\": Particle(\"He+\")},\n                Alfven_speed(0.05 * u.T, 1e18 * u.m ** -3, ion=\"He+\"),\n                {},\n            ),\n            (\n                ([0.001, 0.002] * u.T, 5e-10 * u.kg * u.m ** -3),\n                {},\n                [\n                    va_(0.001 * u.T, 5e-10 * u.kg * u.m ** -3).value,\n                    va_(0.002 * u.T, 5e-10 * u.kg * u.m ** -3).value,\n                ]\n                * (u.m / u.s),\n                {},\n            ),\n            (\n                ([0.001, 0.002] * u.T, [5e-10, 2e-10] * u.kg * u.m ** -3),\n                {},\n                [\n                    va_(0.001 * u.T, 5e-10 * u.kg * u.m ** -3).value,\n                    va_(0.002 * u.T, 2e-10 * u.kg * u.m ** -3).value,\n                ]\n                * (u.m / u.s),\n                {},\n            ),\n            (\n                (0.001 * u.T, [1.0e18, 2e18] * u.m ** -3),\n                {\"ion\": \"p\"},\n                [\n                    va_(0.001 * u.T, 1e18 * u.m ** -3, ion=\"p\").value,\n                    va_(0.001 * u.T, 2e18 * u.m ** -3, ion=\"p\").value,\n                ]\n                * (u.m / u.s),\n                {},\n            ),\n        ],\n    )\n    def test_values(self, args, kwargs, expected, isclose_kw):\n        \"\"\"Test expected values.\"\"\"\n        assert np.allclose(Alfven_speed(*args, **kwargs), expected, **isclose_kw)\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, nan_mask\",\n        [\n            ((np.nan * u.T, 1 * u.kg * u.m ** -3), {}, []),\n            ((0.001 * u.T, np.nan * u.kg * u.m ** -3), {}, []),\n            (([np.nan, 0.001] * u.T, 1 * u.kg * u.m ** -3), {}, [True, False]),\n            (\n                (0.001 * u.T, [np.nan, 1.0, np.nan] * u.kg * u.m ** -3),\n                {},\n                [True, False, True],\n            ),\n            (([np.nan, 0.001] * u.T, [1, np.nan] * u.kg * u.m ** -3), {}, [True, True]),\n            (\n                (0.001 * u.T, [np.nan, 1e18, np.nan] * u.m ** -3),\n                {\"ion\": \"Ar+\"},\n                [True, False, True],\n            ),\n        ],\n    )\n    def test_nan_values(self, args, kwargs, nan_mask):\n        \"\"\"Input scenarios that leat to `numpy.nan` values being returned.\"\"\"\n        val = Alfven_speed(*args, **kwargs)\n        if np.isscalar(val.value):\n            assert np.isnan(val)\n        else:\n            nan_arr = np.isnan(val)\n            assert np.all(nan_arr[nan_mask])\n            assert np.all(np.logical_not(nan_arr[np.logical_not(nan_mask)]))\n\n    def test_handle_nparrays(self):\n        \"\"\"Test for ability to handle numpy array quantities\"\"\"\n        assert_can_handle_nparray(Alfven_speed)\n\n\nclass Test_Ion_Sound_Speed:\n    r\"\"\"Test the ion_sound_speed function in parameters.py.\"\"\"\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, expected, isclose_kw\",\n        [\n            (\n                (),\n                {\n                    \"T_i\": 1.3232 * u.MK,\n                    \"T_e\": 1.831 * u.MK,\n                    \"ion\": \"p\",\n                    \"gamma_e\": 1,\n                    \"gamma_i\": 3,\n                },\n                218816.06086407552 * (u.m / u.s),\n                {},\n            ),\n            (\n                (1.831 * u.MK, 1.3232 * u.MK, \"p\"),\n                {},\n                218816.06086407552 * (u.m / u.s),\n                {},\n            ),  # Test that function call without keyword argument works correctly\n            (\n                (),\n                {\n                    \"T_i\": 1.3232 * u.MK,\n                    \"T_e\": 1.831 * u.MK,\n                    \"n_e\": n_e,\n                    \"k\": k_1,\n                    \"ion\": \"p\",\n                    \"gamma_e\": 1,\n                    \"gamma_i\": 3,\n                },\n                218816.06086407552 * (u.m / u.s),\n                {},\n            ),\n            (\n                (),\n                {\n                    \"T_i\": 1.3232 * u.MK,\n                    \"T_e\": 1.831 * u.MK,\n                    \"n_e\": n_e,\n                    \"k\": k_2,\n                    \"ion\": \"p\",\n                    \"gamma_e\": 1,\n                    \"gamma_i\": 3,\n                },\n                552.3212936293337 * (u.m / u.s),\n                {},\n            ),\n            (\n                (),\n                {\n                    \"T_i\": 0.88 * u.MK,\n                    \"T_e\": 1.28 * u.MK,\n                    \"n_e\": n_e,\n                    \"k\": 0 * u.m ** -1,\n                    \"ion\": \"p\",\n                    \"gamma_e\": 1.2,\n                    \"gamma_i\": 3.4,\n                },\n                193328.52857788358 * (u.m / u.s),\n                {},\n            ),\n            (\n                (),\n                {\"T_i\": T_i, \"T_e\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p+\"},\n                ion_sound_speed(T_i=T_i, T_e=0 * u.K, n_e=n_e, k=k_1, ion=\"p+\").value\n                * (u.m / u.s),\n                {},\n            ),\n            (\n                (),\n                {\n                    \"T_e\": 1.2e6 * u.K,\n                    \"T_i\": 0 * u.K,\n                    \"n_e\": n_e,\n                    \"k\": 0 * u.m ** -1,\n                    \"z_mean\": 0.8,\n                    \"ion\": \"p\",\n                },\n                89018.09 * (u.m / u.s),\n                {\"atol\": 0.0, \"rtol\": 1e-6},\n            ),  # testing for user input z_mean\n        ],\n    )\n    def test_values(self, args, kwargs, expected, isclose_kw):\n        assert np.isclose(ion_sound_speed(*args, **kwargs), expected, **isclose_kw)\n\n    # case when Z=1 is assumed\n    # assert ion_sound_speed(T_i=T_i, T_e=T_e, ion='p+') == ion_sound_speed(T_i=T_i, T_e=T_e,\n    # ion='H-1')\n\n    @pytest.mark.parametrize(\n        \"kwargs1, kwargs2, _warning\",\n        [\n            ({\"T_i\": T_i, \"T_e\": T_e, \"n_e\": n_e, \"ion\": \"p\"}, {}, PhysicsWarning),\n            ({\"T_i\": T_i, \"T_e\": T_e, \"k\": k_1, \"ion\": \"p\"}, {}, PhysicsWarning),\n            ({\"T_i\": 5e11 * u.K, \"T_e\": 0 * u.K, \"ion\": \"p\"}, {}, RelativityWarning),\n            (\n                {\"T_e\": 1.2e6, \"T_i\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"},\n                {\"T_e\": 1.2e6 * u.K, \"T_i\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"},\n                u.UnitsWarning,\n            ),\n            (\n                {\"T_i\": 1.3e6, \"T_e\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"},\n                {\"T_i\": 1.3e6 * u.K, \"T_e\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"},\n                u.UnitsWarning,\n            ),\n        ],\n    )\n    def test_warns(self, kwargs1, kwargs2, _warning):\n        with pytest.warns(_warning):\n            val = ion_sound_speed(**kwargs1)\n            if kwargs2 != {}:\n                val == ion_sound_speed(**kwargs2)\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, _error\",\n        [\n            (\n                (),\n                {\n                    \"T_i\": T_i,\n                    \"T_e\": T_e,\n                    \"n_e\": n_e,\n                    \"k\": k_1,\n                    \"ion\": \"p\",\n                    \"gamma_i\": np.inf,\n                },\n                RelativityError,\n            ),\n            (\n                (),\n                {\n                    \"T_i\": np.array([5, 6, 5]) * u.K,\n                    \"T_e\": np.array([3, 4]) * u.K,\n                    \"n_e\": np.array([5, 6, 5]) * u.m ** -3,\n                    \"k\": np.array([3, 4]) * u.m ** -3,\n                    \"ion\": \"p\",\n                },\n                u.UnitTypeError,\n            ),\n            ((5 * u.T), {\"ion\": \"p\"}, TypeError),  # Is this test right??????\n            ((), {\"ion\": \"p\"}, TypeError),\n            (\n                (),\n                {\"T_i\": T_i, \"T_e\": 0 * u.K, \"gamma_i\": 0.9999, \"ion\": \"p\"},\n                PhysicsError,\n            ),\n            (\n                (),\n                {\"T_i\": T_i, \"T_e\": 0 * u.K, \"gamma_e\": 0.9999, \"ion\": \"p\"},\n                PhysicsError,\n            ),\n            (\n                (),\n                {\"T_i\": T_i, \"T_e\": 0 * u.K, \"gamma_e\": \"sdjklsf\", \"ion\": \"p\"},\n                TypeError,\n            ),\n            (\n                (),\n                {\"T_i\": T_i, \"T_e\": 0 * u.K, \"gamma_i\": \"fsdfas\", \"ion\": \"p\"},\n                TypeError,\n            ),\n            ((), {\"T_i\": T_i, \"T_e\": 0 * u.K, \"ion\": \"cupcakes\"}, InvalidParticleError),\n            ((), {\"T_i\": -np.abs(T_i), \"T_e\": 0 * u.K, \"ion\": \"p\"}, ValueError),\n            (\n                (),\n                {\"T_i\": T_i, \"T_e\": 0 * u.K, \"n_e\": -np.abs(n_e), \"k\": k_1, \"ion\": \"p\"},\n                ValueError,\n            ),\n            (\n                (),\n                {\"T_i\": T_i, \"T_e\": 0 * u.K, \"n_e\": n_e, \"k\": -np.abs(k_1), \"ion\": \"p\"},\n                ValueError,\n            ),\n            ((), {\"T_i\": 5e19 * u.K, \"T_e\": 0 * u.K, \"ion\": \"p\"}, RelativityError),\n            (\n                (),\n                {\"T_i\": 5 * u.A, \"T_e\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"},\n                u.UnitTypeError,\n            ),\n            (\n                (),\n                {\"T_i\": T_negarr, \"T_e\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"},\n                ValueError,\n            ),\n            (\n                (),\n                {\"T_e\": T_negarr, \"T_i\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"},\n                ValueError,\n            ),\n        ],\n    )\n    def test_raises(self, args, kwargs, _error):\n        with pytest.raises(_error):\n            ion_sound_speed(*args, **kwargs)\n\n    @pytest.mark.parametrize(\n        \"kwargs\",\n        [\n            ({\"T_i\": T_nanarr, \"T_e\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"}),\n            ({\"T_e\": T_nanarr, \"T_i\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"}),\n        ],\n    )\n    def test_nan_values(self, kwargs):\n        np.isnan(ion_sound_speed(**kwargs)[1])\n\n    def test_handle_nparrays(self):\n        assert_can_handle_nparray(ion_sound_speed)\n\n\ndef test_thermal_pressure():\n    assert thermal_pressure(T_e, n_i).unit.is_equivalent(u.Pa)\n\n    # TODO: may be array issues with arg \"mass\"\n    assert_can_handle_nparray(thermal_pressure)\n\n\ndef test_gyrofrequency():\n    r\"\"\"Test the gyrofrequency function in parameters.py.\"\"\"\n\n    assert gyrofrequency(B, \"e-\").unit.is_equivalent(u.rad / u.s)\n\n    assert gyrofrequency(B, \"e-\", to_hz=True).unit.is_equivalent(u.Hz)\n\n    assert np.isclose(gyrofrequency(1 * u.T, \"e-\").value, 175882008784.72018)\n\n    assert np.isclose(gyrofrequency(2.4 * u.T, \"e-\").value, 422116821083.3284)\n\n    assert np.isclose(\n        gyrofrequency(1 * u.T, \"e-\", to_hz=True).value, 27992490076.528206\n    )\n\n    assert np.isclose(\n        gyrofrequency(2.4 * u.T, \"e-\", signed=True).value, -422116821083.3284\n    )\n\n    assert np.isclose(gyrofrequency(1 * u.G, \"e-\").cgs.value, 1.76e7, rtol=1e-3)\n\n    with pytest.raises(TypeError):\n        with pytest.warns(u.UnitsWarning):\n            gyrofrequency(u.m, \"e-\")\n\n    with pytest.raises(u.UnitTypeError):\n        gyrofrequency(u.m * 1, \"e-\")\n\n    assert np.isnan(gyrofrequency(B_nanarr, \"e-\")[-1])\n\n    # The following is a test to check that equivalencies from astropy\n    # are working.\n    omega_ce = gyrofrequency(2.2 * u.T, \"e-\")\n    f_ce = (omega_ce / (2 * np.pi)) / u.rad\n    f_ce_use_equiv = omega_ce.to(u.Hz, equivalencies=[(u.cy / u.s, u.Hz)])\n    assert np.isclose(f_ce.value, f_ce_use_equiv.value)\n\n    with pytest.warns(u.UnitsWarning):\n        assert gyrofrequency(5.0, \"e-\") == gyrofrequency(5.0 * u.T, \"e-\")\n\n    assert gyrofrequency(B, particle=ion).unit.is_equivalent(u.rad / u.s)\n\n    assert np.isclose(gyrofrequency(1 * u.T, particle=\"p\").value, 95788335.834874)\n\n    assert np.isclose(gyrofrequency(2.4 * u.T, particle=\"p\").value, 229892006.00369796)\n\n    assert np.isclose(gyrofrequency(1 * u.G, particle=\"p\").cgs.value, 9.58e3, rtol=2e-3)\n\n    assert gyrofrequency(-5 * u.T, \"p\") == gyrofrequency(5 * u.T, \"p\")\n\n    # Case when Z=1 is assumed\n    # assert gyrofrequency(B, particle='p+') == gyrofrequency(B, particle='H-1')\n\n    assert gyrofrequency(B, particle=\"e+\") == gyrofrequency(B, \"e-\")\n\n    with pytest.warns(u.UnitsWarning):\n        gyrofrequency(8, \"p\")\n\n    with pytest.raises(u.UnitTypeError):\n        gyrofrequency(5 * u.m, \"p\")\n\n    with pytest.raises(InvalidParticleError):\n        gyrofrequency(8 * u.T, particle=\"asdfasd\")\n\n    with pytest.warns(u.UnitsWarning):\n        # TODO this should be WARNS, not RAISES. and it's probably still raised\n        assert gyrofrequency(5.0, \"p\") == gyrofrequency(5.0 * u.T, \"p\")\n\n    gyrofrequency(1 * u.T, particle=\"p\")\n    # testing for user input Z\n    testMeth1 = gyrofrequency(1 * u.T, particle=\"p\", Z=0.8).si.value\n    testTrue1 = 76630665.79318453\n    errStr = f\"gyrofrequency() gave {testMeth1}, should be {testTrue1}.\"\n    assert np.isclose(testMeth1, testTrue1, atol=0.0, rtol=1e-5), errStr\n\n    assert_can_handle_nparray(gyrofrequency, kwargs={\"signed\": True})\n\n    assert_can_handle_nparray(gyrofrequency, kwargs={\"signed\": False})\n\n\ndef test_gyroradius():\n    r\"\"\"Test the gyroradius function in parameters.py.\"\"\"\n\n    assert gyroradius(B, \"e-\", T=T_e).unit.is_equivalent(u.m)\n\n    assert gyroradius(B, \"e-\", Vperp=25 * u.m / u.s).unit.is_equivalent(u.m)\n\n    # test for possiblity to allow nan for input values\n    assert np.isnan(gyroradius(np.nan * u.T, particle=\"e-\", T=1 * u.K))\n    assert np.isnan(gyroradius(1 * u.T, particle=\"e-\", T=np.nan * u.K))\n    assert np.isnan(gyroradius(1 * u.T, particle=\"e-\", Vperp=np.nan * u.m / u.s))\n\n    Vperp = 1e6 * u.m / u.s\n    Bmag = 1 * u.T\n    omega_ce = gyrofrequency(Bmag, \"e-\")\n    analytical_result = (Vperp / omega_ce).to(\n        u.m, equivalencies=u.dimensionless_angles()\n    )\n    assert gyroradius(Bmag, \"e-\", Vperp=Vperp) == analytical_result\n\n    with pytest.raises(TypeError):\n        with pytest.warns(u.UnitsWarning):\n            gyroradius(u.T, \"e-\")\n\n    with pytest.raises(u.UnitTypeError):\n        gyroradius(5 * u.A, \"e-\", Vperp=8 * u.m / u.s)\n\n    with pytest.raises(u.UnitTypeError):\n        gyroradius(5 * u.T, \"e-\", Vperp=8 * u.m)\n\n    with pytest.raises(ValueError):\n        gyroradius(np.array([5, 6]) * u.T, \"e-\", Vperp=np.array([5, 6, 7]) * u.m / u.s)\n\n    assert np.isnan(gyroradius(np.nan * u.T, \"e-\", Vperp=1 * u.m / u.s))\n\n    with pytest.raises(ValueError):\n        gyroradius(3.14159 * u.T, \"e-\", T=-1 * u.K)\n\n    with pytest.warns(u.UnitsWarning):\n        assert gyroradius(1.0, \"e-\", Vperp=1.0) == gyroradius(\n            1.0 * u.T, \"e-\", Vperp=1.0 * u.m / u.s\n        )\n\n    with pytest.warns(u.UnitsWarning):\n        assert gyroradius(1.1, \"e-\", T=1.2) == gyroradius(1.1 * u.T, \"e-\", T=1.2 * u.K)\n\n    with pytest.raises(ValueError):\n        gyroradius(1.1 * u.T, \"e-\", Vperp=1 * u.m / u.s, T=1.2 * u.K)\n\n    with pytest.raises(u.UnitTypeError):\n        gyroradius(1.1 * u.T, \"e-\", Vperp=1.1 * u.m, T=1.2 * u.K)\n\n    # Check for Deprecation warning when using T_i instead of T\n    with pytest.warns(PlasmaPyFutureWarning):\n        gyroradius(1.1 * u.T, \"e-\", T_i=1.2 * u.K)\n\n    assert gyroradius(B, particle=\"p\", T=T_i).unit.is_equivalent(u.m)\n\n    assert gyroradius(B, particle=\"p\", Vperp=25 * u.m / u.s).unit.is_equivalent(u.m)\n\n    # Case when Z=1 is assumed\n    assert np.isclose(\n        gyroradius(B, particle=\"p\", T=T_i),\n        gyroradius(B, particle=\"H+\", T=T_i),\n        atol=1e-6 * u.m,\n    )\n\n    gyroPos = gyroradius(B, particle=\"p\", Vperp=V)\n    gyroNeg = gyroradius(B, particle=\"p\", Vperp=-V)\n    assert gyroPos == gyroNeg\n\n    Vperp = 1e6 * u.m / u.s\n    Bmag = 1 * u.T\n    omega_ci = gyrofrequency(Bmag, particle=\"p\")\n    analytical_result = (Vperp / omega_ci).to(\n        u.m, equivalencies=u.dimensionless_angles()\n    )\n    assert gyroradius(Bmag, particle=\"p\", Vperp=Vperp) == analytical_result\n\n    T2 = 1.2 * u.MK\n    B2 = 123 * u.G\n    particle2 = \"alpha\"\n    Vperp2 = thermal_speed(T2, particle=particle2)\n    gyro_by_vperp = gyroradius(B2, particle=\"alpha\", Vperp=Vperp2)\n    assert gyro_by_vperp == gyroradius(B2, particle=\"alpha\", T=T2)\n\n    explicit_positron_gyro = gyroradius(1 * u.T, particle=\"positron\", T=1 * u.MK)\n    assert explicit_positron_gyro == gyroradius(1 * u.T, \"e-\", T=1 * u.MK)\n\n    with pytest.raises(TypeError):\n        with pytest.warns(u.UnitsWarning):\n            gyroradius(u.T, particle=\"p\", Vperp=8 * u.m / u.s)\n\n    with pytest.raises(ValueError):\n        gyroradius(B, particle=\"p\", T=-1 * u.K)\n\n    with pytest.warns(u.UnitsWarning):\n        gyro_without_units = gyroradius(1.0, particle=\"p\", Vperp=1.0)\n        gyro_with_units = gyroradius(1.0 * u.T, particle=\"p\", Vperp=1.0 * u.m / u.s)\n        assert gyro_without_units == gyro_with_units\n\n    with pytest.warns(u.UnitsWarning):\n        gyro_t_without_units = gyroradius(1.1, particle=\"p\", T=1.2)\n        gyro_t_with_units = gyroradius(1.1 * u.T, particle=\"p\", T=1.2 * u.K)\n        assert gyro_t_with_units == gyro_t_without_units\n\n    with pytest.raises(ValueError):\n        gyroradius(1.1 * u.T, particle=\"p\", Vperp=1 * u.m / u.s, T=1.2 * u.K)\n\n    with pytest.raises(u.UnitTypeError):\n        gyroradius(1.1 * u.T, particle=\"p\", Vperp=1.1 * u.m, T=1.2 * u.K)\n\n    with pytest.raises(u.UnitTypeError):\n        gyroradius(1.1 * u.T, particle=\"p\", Vperp=1.2 * u.m, T=1.1 * u.K)\n\n\nclass Test_gyroradius:\n\n    # some custom numpy array tests here, because of the T / Vperp situation\n    def test_handle_numpy_array(self):\n        # Tests to verify that can handle Quantities with numpy array as the value:\n        assert gyroradius(B_arr, \"e-\", Vperp=V_arr)[0] == gyroradius(\n            B_arr[0], \"e-\", Vperp=V_arr[0]\n        )\n        assert gyroradius(B_arr, \"e-\", T=T_arr)[0] == gyroradius(\n            B_arr[0], \"e-\", T=T_arr[0]\n        )\n\n    def test_handle_mixed_Qarrays(self):\n        # If both Vperp or T are input as Qarrays, but only one of the two is valid\n        # at each element, then that's fine, the function should work:\n        assert gyroradius(B_arr, \"e-\", Vperp=V_nanarr, T=T_nanarr2)[0] == gyroradius(\n            B_arr[0], \"e-\", Vperp=V_nanarr[0], T=T_nanarr2[0]\n        )\n\n    def test_raise_two_valid_inputs(self):\n        # If both Vperp or T are nan-less, Qarrays or not, should raise ValueError:\n        with pytest.raises(ValueError):\n            gyroradius(B_arr, \"e-\", Vperp=V, T=T_arr)\n        with pytest.raises(ValueError):\n            gyroradius(B_arr, \"e-\", Vperp=V_arr, T=T_i)\n\n    def test_all_valid_and_one_valid(self):\n        # If one of (Vperp, T) is a valid and one is Qarray with at least one valid, ValueError:\n        with pytest.raises(ValueError):\n            gyroradius(B_arr, \"e-\", Vperp=V, T=T_nanarr)\n        with pytest.raises(ValueError):\n            gyroradius(B_arr, \"e-\", Vperp=V_nanarr, T=T_i)\n\n    def test_scalar_and_nan_qarray(self):\n        # If either Vperp or T is a valid scalar and the other is a Qarray of all nans,\n        # should do something valid and not raise a ValueError\n        assert np.all(np.isfinite(gyroradius(B_arr, \"e-\", Vperp=V, T=T_allnanarr)))\n        assert np.all(np.isfinite(gyroradius(B_arr, \"e-\", Vperp=V_allnanarr, T=T_i)))\n\n    def test_keeps_arguments_unchanged(self):\n        Vperp1 = u.Quantity([np.nan, 1], unit=u.m / u.s)\n        Vperp2 = u.Quantity([np.nan, 1], unit=u.m / u.s)  # an exact copy\n        T_i = u.Quantity([1, np.nan], unit=u.K)\n\n        gyroradius(B_arr, \"e-\", Vperp=Vperp1, T=T_i)\n        assert_quantity_allclose(Vperp1, Vperp2)\n\n\ndef test_plasma_frequency():\n    r\"\"\"Test the plasma_frequency function in parameters.py.\"\"\"\n\n    assert plasma_frequency(n_e, \"e-\").unit.is_equivalent(u.rad / u.s)\n\n    assert plasma_frequency(n_e, \"e-\", to_hz=True).unit.is_equivalent(u.Hz)\n\n    assert np.isclose(plasma_frequency(1 * u.cm ** -3, \"e-\").value, 5.64e4, rtol=1e-2)\n\n    assert np.isclose(\n        plasma_frequency(1 * u.cm ** -3, particle=\"N\").value, 3.53e2, rtol=1e-1\n    )\n\n    assert np.isclose(\n        plasma_frequency(1 * u.cm ** -3, particle=\"N\", to_hz=True).value,\n        56.19000195094519,\n    )\n\n    with pytest.raises(TypeError):\n        with pytest.warns(u.UnitsWarning):\n            plasma_frequency(u.m ** -3, \"e-\")\n\n    with pytest.raises(u.UnitTypeError):\n        plasma_frequency(5 * u.m ** -2, \"e-\")\n\n    assert np.isnan(plasma_frequency(np.nan * u.m ** -3, \"e-\"))\n\n    with pytest.warns(u.UnitsWarning):\n        assert plasma_frequency(1e19, \"e-\") == plasma_frequency(1e19 * u.m ** -3, \"e-\")\n\n        assert plasma_frequency(n_i, particle=\"p\").unit.is_equivalent(u.rad / u.s)\n\n    # Case where Z=1 is assumed\n    assert plasma_frequency(n_i, particle=\"H-1+\") == plasma_frequency(n_i, particle=\"p\")\n\n    assert np.isclose(\n        plasma_frequency(mu * u.cm ** -3, particle=\"p\").value, 1.32e3, rtol=1e-2\n    )\n\n    with pytest.raises(ValueError):\n        plasma_frequency(n=5 * u.m ** -3, particle=\"sdfas\")\n\n    with pytest.warns(u.UnitsWarning):\n        plasma_freq_no_units = plasma_frequency(1e19, particle=\"p\")\n        assert plasma_freq_no_units == plasma_frequency(1e19 * u.m ** -3, particle=\"p\")\n\n    plasma_frequency(1e17 * u.cm ** -3, particle=\"p\")\n    # testing for user input z_mean\n    testMeth1 = plasma_frequency(1e17 * u.cm ** -3, particle=\"p\", z_mean=0.8).si.value\n    testTrue1 = 333063562455.4028\n    errStr = f\"plasma_frequency() gave {testMeth1}, should be {testTrue1}.\"\n    assert np.isclose(testMeth1, testTrue1, atol=0.0, rtol=1e-6), errStr\n\n    assert_can_handle_nparray(plasma_frequency)\n\n\ndef test_Debye_length():\n    r\"\"\"Test the Debye_length function in parameters.py.\"\"\"\n\n    assert Debye_length(T_e, n_e).unit.is_equivalent(u.m)\n\n    assert np.isclose(Debye_length(1 * u.eV, 1 * u.cm ** -3).value, 7.43, atol=0.005)\n\n    with pytest.warns(u.UnitsWarning):\n        Debye_length(5, 5 * u.m ** -3)\n\n    with pytest.raises(u.UnitTypeError):\n        Debye_length(56 * u.kg, 5 * u.m ** -3)\n\n    with pytest.raises(ValueError):\n        Debye_length(5 * u.eV, -5 * u.m ** -3)\n\n    with pytest.raises(ValueError):\n        Debye_length(-45 * u.K, 5 * u.m ** -3)\n\n    Tarr2 = np.array([1, 2]) * u.K\n    narr3 = np.array([1, 2, 3]) * u.m ** -3\n    with pytest.raises(ValueError):\n        Debye_length(Tarr2, narr3)\n\n    with pytest.warns(u.UnitsWarning):\n        assert Debye_length(2.0, 2.0) == Debye_length(2.0 * u.K, 2.0 * u.m ** -3)\n\n    with pytest.warns(u.UnitsWarning):\n        assert Debye_length(2.0 * u.K, 2.0) == Debye_length(2.0, 2.0 * u.m ** -3)\n\n    assert_can_handle_nparray(Debye_length)\n\n\ndef test_Debye_number():\n    r\"\"\"Test the Debye_number function in parameters.py.\"\"\"\n\n    assert Debye_number(T_e, n_e).unit.is_equivalent(u.dimensionless_unscaled)\n\n    T_e_eV = T_e.to(u.eV, equivalencies=u.temperature_energy())\n    assert np.isclose(Debye_number(T_e, n_e).value, Debye_number(T_e_eV, n_e).value)\n\n    assert np.isclose(Debye_number(1 * u.eV, 1 * u.cm ** -3).value, 1720862385.43342)\n\n    with pytest.warns(u.UnitsWarning):\n        Debye_number(T_e, 4)\n\n    with pytest.raises(ValueError):\n        Debye_number(None, n_e)\n\n    with pytest.raises(u.UnitTypeError):\n        Debye_number(5 * u.m, 5 * u.m ** -3)\n\n    with pytest.raises(u.UnitTypeError):\n        Debye_number(5 * u.K, 5 * u.m ** 3)\n\n    with pytest.raises(ValueError):\n        Debye_number(5j * u.K, 5 * u.cm ** -3)\n\n    Tarr2 = np.array([1, 2]) * u.K\n    narr3 = np.array([1, 2, 3]) * u.m ** -3\n    with pytest.raises(ValueError):\n        Debye_number(Tarr2, narr3)\n\n    with pytest.warns(u.UnitsWarning):\n        assert Debye_number(1.1, 1.1) == Debye_number(1.1 * u.K, 1.1 * u.m ** -3)\n\n    with pytest.warns(u.UnitsWarning):\n        assert Debye_number(1.1 * u.K, 1.1) == Debye_number(1.1, 1.1 * u.m ** -3)\n\n    assert_can_handle_nparray(Debye_number)\n\n\ndef test_inertial_length():\n    r\"\"\"Test the inertial_length function in parameters.py.\"\"\"\n\n    assert inertial_length(n_i, particle=\"p\").unit.is_equivalent(u.m)\n\n    assert np.isclose(\n        inertial_length(mu * u.cm ** -3, particle=\"p\").cgs.value, 2.28e7, rtol=0.01\n    )\n\n    inertial_length_electron_plus = inertial_length(5.351 * u.m ** -3, particle=\"e+\")\n    assert inertial_length_electron_plus == inertial_length(\n        5.351 * u.m ** -3, particle=\"e\"\n    )\n\n    assert inertial_length(n_i, particle=\"p\") == inertial_length(n_i, particle=\"p\")\n\n    with pytest.warns(u.UnitsWarning):\n        inertial_length(4, particle=\"p\")\n\n    with pytest.raises(u.UnitTypeError):\n        inertial_length(4 * u.m ** -2, particle=\"p\")\n\n    with pytest.raises(ValueError):\n        inertial_length(-5 * u.m ** -3, particle=\"p\")\n\n    with pytest.raises(InvalidParticleError):\n        inertial_length(n_i, particle=-135)\n\n    with pytest.warns(u.UnitsWarning):\n        inertial_length_no_units = inertial_length(1e19, particle=\"p\")\n        assert inertial_length_no_units == inertial_length(\n            1e19 * u.m ** -3, particle=\"p\"\n        )\n\n    assert inertial_length(n_e, \"e-\").unit.is_equivalent(u.m)\n\n    assert np.isclose(\n        inertial_length(1 * u.cm ** -3, \"e-\").cgs.value, 5.31e5, rtol=1e-3\n    )\n\n    with pytest.warns(u.UnitsWarning):\n        inertial_length(5, \"e-\")\n\n    with pytest.raises(u.UnitTypeError):\n        inertial_length(5 * u.m, \"e-\")\n\n    with pytest.raises(ValueError):\n        inertial_length(-5 * u.m ** -3, \"e-\")\n\n    with pytest.warns(u.UnitsWarning):\n        assert inertial_length(1e19, \"e-\") == inertial_length(1e19 * u.m ** -3, \"e-\")\n\n    assert_can_handle_nparray(inertial_length)\n\n\ndef test_magnetic_pressure():\n    r\"\"\"Test the magnetic_pressure function in parameters.py.\"\"\"\n\n    assert magnetic_pressure(B_arr).unit.is_equivalent(u.Pa)\n\n    assert magnetic_pressure(B).unit.is_equivalent(u.Pa)\n\n    assert magnetic_pressure(B).unit.name == \"Pa\"\n\n    assert magnetic_pressure(B).value == magnetic_energy_density(B).value\n\n    assert magnetic_pressure(B) == magnetic_energy_density(B.to(u.G))\n\n    assert np.isclose(magnetic_pressure(B).value, 397887.35772973835)\n\n    with pytest.warns(u.UnitsWarning):\n        magnetic_pressure(5)\n\n    with pytest.raises(u.UnitTypeError):\n        magnetic_pressure(5 * u.m)\n\n    assert np.isnan(magnetic_pressure(np.nan * u.T))\n\n    with pytest.raises(ValueError):\n        magnetic_pressure(5j * u.T)\n\n    assert np.isnan(magnetic_pressure(B_nanarr)[-1])\n\n    with pytest.warns(u.UnitsWarning):\n        assert magnetic_pressure(22.2) == magnetic_pressure(22.2 * u.T)\n\n    assert_can_handle_nparray(magnetic_pressure)\n\n\ndef test_magnetic_energy_density():\n    r\"\"\"Test the magnetic_energy_density function in parameters.py.\"\"\"\n\n    assert magnetic_energy_density(B_arr).unit.is_equivalent(u.J / u.m ** 3)\n\n    assert magnetic_energy_density(B).unit.is_equivalent(\"J / m3\")\n\n    assert magnetic_energy_density(B).value == magnetic_pressure(B).value\n\n    assert_quantity_allclose(\n        magnetic_energy_density(2 * B), 4 * magnetic_energy_density(B)\n    )\n\n    assert_quantity_allclose(magnetic_energy_density(B).value, 397887.35772973835)\n\n    assert_quantity_allclose(\n        magnetic_energy_density(B), magnetic_energy_density(B.to(u.G))\n    )\n\n    assert isinstance(magnetic_energy_density(B_arr), u.Quantity)\n\n    with pytest.warns(u.UnitsWarning):\n        magnetic_energy_density(5)\n\n    with pytest.raises(u.UnitTypeError):\n        magnetic_energy_density(5 * u.m)\n\n    assert np.isnan(magnetic_energy_density(np.nan * u.T))\n\n    with pytest.raises(ValueError):\n        magnetic_energy_density(5j * u.T)\n\n    assert np.isnan(magnetic_energy_density(B_nanarr)[-1])\n\n    with pytest.warns(u.UnitsWarning):\n        assert magnetic_energy_density(22.2) == magnetic_energy_density(22.2 * u.T)\n\n    assert_can_handle_nparray(magnetic_energy_density)\n\n\ndef test_upper_hybrid_frequency():\n    r\"\"\"Test the upper_hybrid_frequency function in parameters.py.\"\"\"\n\n    omega_uh = upper_hybrid_frequency(B, n_e=n_e)\n    omega_uh_hz = upper_hybrid_frequency(B, n_e=n_e, to_hz=True)\n    omega_ce = gyrofrequency(B, \"e-\")\n    omega_pe = plasma_frequency(n=n_e, particle=\"e-\")\n    assert omega_ce.unit.is_equivalent(u.rad / u.s)\n    assert omega_pe.unit.is_equivalent(u.rad / u.s)\n    assert omega_uh.unit.is_equivalent(u.rad / u.s)\n    assert omega_uh_hz.unit.is_equivalent(u.Hz)\n    left_hand_side = omega_uh ** 2\n    right_hand_side = omega_ce ** 2 + omega_pe ** 2\n    assert np.isclose(left_hand_side.value, right_hand_side.value)\n\n    assert np.isclose(omega_uh_hz.value, 69385868857.90918)\n\n    with pytest.raises(ValueError):\n        upper_hybrid_frequency(5 * u.T, n_e=-1 * u.m ** -3)\n\n    with pytest.warns(u.UnitsWarning):\n        assert upper_hybrid_frequency(1.2, 1.3) == upper_hybrid_frequency(\n            1.2 * u.T, 1.3 * u.m ** -3\n        )\n\n    with pytest.warns(u.UnitsWarning):\n        assert upper_hybrid_frequency(1.4 * u.T, 1.3) == upper_hybrid_frequency(\n            1.4, 1.3 * u.m ** -3\n        )\n\n    assert_can_handle_nparray(upper_hybrid_frequency)\n\n\ndef test_lower_hybrid_frequency():\n    r\"\"\"Test the lower_hybrid_frequency function in parameters.py.\"\"\"\n\n    ion = \"He-4 1+\"\n    omega_ci = gyrofrequency(B, particle=ion)\n    omega_pi = plasma_frequency(n=n_i, particle=ion)\n    omega_ce = gyrofrequency(B, \"e-\")\n    omega_lh = lower_hybrid_frequency(B, n_i=n_i, ion=ion)\n    omega_lh_hz = lower_hybrid_frequency(B, n_i=n_i, ion=ion, to_hz=True)\n    assert omega_ci.unit.is_equivalent(u.rad / u.s)\n    assert omega_pi.unit.is_equivalent(u.rad / u.s)\n    assert omega_ce.unit.is_equivalent(u.rad / u.s)\n    assert omega_lh.unit.is_equivalent(u.rad / u.s)\n    left_hand_side = omega_lh ** -2\n    right_hand_side = (\n        1 / (omega_ci ** 2 + omega_pi ** 2) + omega_ci ** -1 * omega_ce ** -1\n    )\n    assert np.isclose(left_hand_side.value, right_hand_side.value)\n\n    assert np.isclose(omega_lh_hz.value, 299878691.3223296)\n\n    with pytest.raises(ValueError):\n        lower_hybrid_frequency(0.2 * u.T, n_i=5e19 * u.m ** -3, ion=\"asdfasd\")\n\n    with pytest.raises(ValueError):\n        lower_hybrid_frequency(0.2 * u.T, n_i=-5e19 * u.m ** -3, ion=\"asdfasd\")\n\n    with pytest.raises(ValueError):\n        lower_hybrid_frequency(np.nan * u.T, n_i=-5e19 * u.m ** -3, ion=\"asdfasd\")\n\n    with pytest.warns(u.UnitsWarning):\n        assert lower_hybrid_frequency(1.3, 1e19, \"p+\") == lower_hybrid_frequency(\n            1.3 * u.T, 1e19 * u.m ** -3, \"p+\"\n        )\n    assert_can_handle_nparray(lower_hybrid_frequency)\n\n\ndef test_Bohm_diffusion():\n    r\"\"\"Test Mag_Reynolds in dimensionless.py\"\"\"\n\n    T_e = 5000 * u.K\n    B = 10 * u.T\n\n    assert (Bohm_diffusion(T_e, B)).unit == u.m ** 2 / u.s\n\n    with pytest.warns(u.UnitsWarning):\n        Bohm_diffusion(5000, B)\n\n    with pytest.raises(u.UnitTypeError):\n        Bohm_diffusion(2.2 * u.kg, B)\n\n\n@pytest.mark.parametrize(\n    \"alias, parent\",\n    [\n        (rho_, mass_density),\n        (va_, Alfven_speed),\n        (cs_, ion_sound_speed),\n        (pth_, thermal_pressure),\n        (betaH_, Hall_parameter),\n        (oc_, gyrofrequency),\n        (wc_, gyrofrequency),\n        (rc_, gyroradius),\n        (rhoc_, gyroradius),\n        (wp_, plasma_frequency),\n        (lambdaD_, Debye_length),\n        (nD_, Debye_number),\n        (cwp_, inertial_length),\n        (pmag_, magnetic_pressure),\n        (ub_, magnetic_energy_density),\n        (wuh_, upper_hybrid_frequency),\n        (wlh_, lower_hybrid_frequency),\n        (DB_, Bohm_diffusion),\n    ],\n)\ndef test_parameters_aliases(alias, parent):\n    \"\"\"Test all aliases defined in parameters.py\"\"\"\n    assert alias is parent\n",
  "output": {
    "before": "\"\"\"Tests for functions that calculate plasma parameters.\"\"\"\n\nimport numpy as np\nimport pytest\n\nfrom astropy import units as u\nfrom astropy.constants import m_e, m_p\nfrom astropy.tests.helper import assert_quantity_allclose\n\nfrom plasmapy.formulary.parameters import (\n    Alfven_speed,\n    betaH_,\n    Bohm_diffusion,\n    cs_,\n    cwp_,\n    DB_,\n    Debye_length,\n    Debye_number,\n    gyrofrequency,\n    gyroradius,\n    Hall_parameter,\n    inertial_length,\n    ion_sound_speed,\n    lambdaD_,\n    lower_hybrid_frequency,\n    magnetic_energy_density,\n    magnetic_pressure,\n    mass_density,\n    nD_,\n    oc_,\n    plasma_frequency,\n    pmag_,\n    pth_,\n    rc_,\n    rho_,\n    rhoc_,\n    thermal_pressure,\n    thermal_speed,\n    ub_,\n    upper_hybrid_frequency,\n    va_,\n    wc_,\n    wlh_,\n    wp_,\n    wuh_,\n)\nfrom plasmapy.particles import Particle\nfrom plasmapy.particles.exceptions import InvalidParticleError\nfrom plasmapy.utils.exceptions import (\n    PhysicsError,\n    PhysicsWarning,\n    PlasmaPyFutureWarning,\n    RelativityError,\n    RelativityWarning,\n)\nfrom plasmapy.utils.pytest_helpers import assert_can_handle_nparray\n\nB = 1.0 * u.T\nZ = 1\nion = \"p\"\nm_i = m_p\nn_i = 5e19 * u.m ** -3\nn_e = Z * 5e19 * u.m ** -3\nrho = n_i * m_i + n_e * m_e\nT_e = 1e6 * u.K\nT_i = 1e6 * u.K\nk_1 = 3e1 * u.m ** -1\nk_2 = 3e7 * u.m ** -1\n\nB_arr = np.array([0.001, 0.002]) * u.T\nB_nanarr = np.array([0.001, np.nan]) * u.T\nB_allnanarr = np.array([np.nan, np.nan]) * u.T\n\nrho_arr = np.array([5e-10, 2e-10]) * u.kg / u.m ** 3\nrho_infarr = np.array([np.inf, 5e19]) * u.m ** -3\nrho_negarr = np.array([-5e19, 6e19]) * u.m ** -3\n\nT_arr = np.array([1e6, 2e6]) * u.K\nT_nanarr = np.array([1e6, np.nan]) * u.K\nT_nanarr2 = np.array([np.nan, 2e6]) * u.K\nT_allnanarr = np.array([np.nan, np.nan]) * u.K\nT_negarr = np.array([1e6, -5151.0]) * u.K\n\nV = 25.2 * u.m / u.s\nV_arr = np.array([25, 50]) * u.m / u.s\nV_nanarr = np.array([25, np.nan]) * u.m / u.s\nV_allnanarr = np.array([np.nan, np.nan]) * u.m / u.s\n\nmu = m_p.to(u.u).value\n\n\nclass Test_mass_density:\n    r\"\"\"Test the mass_density function in parameters.py.\"\"\"\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, conditional\",\n        [\n            ((-1 * u.kg * u.m ** -3, \"He\"), {}, pytest.raises(ValueError)),\n            ((-1 * u.m ** -3, \"He\"), {}, pytest.raises(ValueError)),\n            ((\"not a Quantity\", \"He\"), {}, pytest.raises(TypeError)),\n            ((1 * u.m ** -3,), {}, pytest.raises(TypeError)),\n            ((1 * u.J, \"He\"), {}, pytest.raises(u.UnitTypeError)),\n            ((1 * u.m ** -3, None), {}, pytest.raises(TypeError)),\n            (\n                (1 * u.m ** -3, \"He\"),\n                {\"z_ratio\": \"not a ratio\"},\n                pytest.raises(TypeError),\n            ),\n        ],\n    )\n    def test_raises(self, args, kwargs, conditional):\n        with conditional:\n            mass_density(*args, **kwargs)\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, expected\",\n        [\n            ((1.0 * u.g * u.m ** -3, \"\"), {}, 1.0e-3 * u.kg * u.m ** -3),\n            ((5.0e12 * u.cm ** -3, \"He\"), {}, 3.32323849e-8 * u.kg * u.m ** -3),\n            (\n                (5.0e12 * u.cm ** -3, Particle(\"He\")),\n                {},\n                3.32323849e-8 * u.kg * u.m ** -3,\n            ),\n            (\n                (5.0e12 * u.cm ** -3, \"He\"),\n                {\"z_ratio\": 0.5},\n                1.66161925e-08 * u.kg * u.m ** -3,\n            ),\n            (\n                (5.0e12 * u.cm ** -3, \"He\"),\n                {\"z_ratio\": -0.5},\n                1.66161925e-08 * u.kg * u.m ** -3,\n            ),\n        ],\n    )\n    def test_values(self, args, kwargs, expected):\n        assert np.isclose(mass_density(*args, **kwargs), expected)\n\n    def test_handle_nparrays(self):\n        \"\"\"Test for ability to handle numpy array quantities\"\"\"\n        assert_can_handle_nparray(mass_density)\n\n\n# Assertions below that are in CGS units with 2-3 significant digits\n# are generally from the NRL Plasma Formulary.\n\n\nclass TestAlfvenSpeed:\n    \"\"\"Test `~plasmapy.formulary.parameters.Alfven_speed`.\"\"\"\n\n    @pytest.mark.parametrize(\"alias\", [va_])\n    def test_aliases(self, alias):\n        assert alias is Alfven_speed\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, _error\",\n        [\n            # scenarios that raise RelativityError\n            ((10 * u.T, 1.0e-10 * u.kg * u.m ** -3), {}, RelativityError),\n            ((np.inf * u.T, 1 * u.m ** -3), {\"ion\": \"p\"}, RelativityError),\n            ((-np.inf * u.T, 1 * u.m ** -3), {\"ion\": \"p\"}, RelativityError),\n            #\n            # scenarios that raise InvalidParticleError\n            ((1 * u.T, 5e19 * u.m ** -3), {\"ion\": \"spacecats\"}, InvalidParticleError),\n            #\n            # scenarios that raise TypeError\n            ((\"not a Bfield\", 1.0e-10 * u.kg * u.m ** -3), {}, TypeError),\n            ((10 * u.T, \"not a density\"), {}, TypeError),\n            ((10 * u.T, 5), {\"ion\": \"p\"}, TypeError),\n            ((1 * u.T, 1.0e18 * u.m ** -3), {\"ion\": [\"He\"]}, TypeError),\n            ((1 * u.T, 1.0e18 * u.m ** -3), {\"ion\": \"He\", \"z_mean\": \"nope\"}, TypeError),\n            #\n            # scenarios that raise UnitTypeError\n            ((1 * u.T, 1.0e18 * u.cm), {\"ion\": \"He\"}, u.UnitTypeError),\n            ((1 * u.T, 5 * u.m ** -2), {\"ion\": \"p\"}, u.UnitTypeError),\n            ((1 * u.cm, 1.0e18 * u.m ** -3), {\"ion\": \"He\"}, u.UnitTypeError),\n            ((5 * u.A, 5e19 * u.m ** -3), {\"ion\": \"p\"}, u.UnitTypeError),\n            #\n            # scenarios that raise ValueError\n            ((1 * u.T, -1.0e18 * u.m ** -3), {\"ion\": \"He\"}, ValueError),\n            (\n                (np.array([5, 6, 7]) * u.T, np.array([5, 6]) * u.m ** -3),\n                {\"ion\": \"p\"},\n                ValueError,\n            ),\n            (\n                (np.array([0.001, 0.002]) * u.T, np.array([-5e19, 6e19]) * u.m ** -3),\n                {\"ion\": \"p\"},\n                ValueError,\n            ),\n        ],\n    )\n    def test_raises(self, args, kwargs, _error):\n        \"\"\"Test scenarios that raise exceptions or warnings.\"\"\"\n        with pytest.raises(_error):\n            Alfven_speed(*args, **kwargs)\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, expected, isclose_kw, _warning\",\n        [\n            # scenarios that issue RelativityWarning\n            (\n                (5 * u.T, 5e19 * u.m ** -3),\n                {\"ion\": \"H\"},\n                15413707.39,\n                {},\n                RelativityWarning,\n            ),\n            (\n                (5 * u.T, 5e19 * u.m ** -3),\n                {\"ion\": \"H+\"},\n                15413707.39,\n                {\"rtol\": 3.0e-4},\n                RelativityWarning,\n            ),\n            (\n                (5 * u.T, 5e19 * u.m ** -3),\n                {\"ion\": \"p\"},\n                15413707.39,\n                {\"rtol\": 4.0e-4},\n                RelativityWarning,\n            ),\n            #\n            # scenarios that issue UnitsWarning\n            ((0.5, 1.0e18 * u.m ** -3), {\"ion\": \"He\"}, 5470657.93, {}, u.UnitsWarning),\n        ],\n    )\n    def test_warns(self, args, kwargs, expected, isclose_kw, _warning):\n        \"\"\"Test scenarios that issue warnings\"\"\"\n        with pytest.warns(_warning):\n            val = Alfven_speed(*args, **kwargs)\n            assert isinstance(val, u.Quantity)\n            assert val.unit == u.m / u.s\n            assert np.isclose(val.value, expected, **isclose_kw)\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, expected, isclose_kw\",\n        [\n            (\n                (1 * u.T, 1e-8 * u.kg * u.m ** -3),\n                {\"ion\": \"p\"},\n                8920620.58 * u.m / u.s,\n                {\"rtol\": 1e-6},\n            ),\n            (\n                (1 * u.T, 1e-8 * u.kg * u.m ** -3),\n                {},\n                8920620.58 * u.m / u.s,\n                {\"rtol\": 1e-6},\n            ),\n            (\n                (0.05 * u.T, 1e18 * u.m ** -3),\n                {\"ion\": \"He\"},\n                Alfven_speed(0.05 * u.T, 6.64738793e-09 * u.kg * u.m ** -3),\n                {},\n            ),\n            (\n                (0.05 * u.T, 1e18 * u.m ** -3),\n                {\"ion\": \"He+\"},\n                Alfven_speed(0.05 * u.T, 1e18 * u.m ** -3, ion=\"He\"),\n                {\"rtol\": 7e-5},\n            ),\n            (\n                (0.05 * u.T, 1e18 * u.m ** -3),\n                {\"ion\": \"He\", \"z_mean\": 2},\n                Alfven_speed(0.05 * u.T, 1e18 * u.m ** -3, ion=\"He +2\"),\n                {\"rtol\": 1.4e-4},\n            ),\n            (\n                (0.05 * u.T, 1e18 * u.m ** -3),\n                {\"ion\": Particle(\"He+\")},\n                Alfven_speed(0.05 * u.T, 1e18 * u.m ** -3, ion=\"He+\"),\n                {},\n            ),\n            (\n                ([0.001, 0.002] * u.T, 5e-10 * u.kg * u.m ** -3),\n                {},\n                [\n                    va_(0.001 * u.T, 5e-10 * u.kg * u.m ** -3).value,\n                    va_(0.002 * u.T, 5e-10 * u.kg * u.m ** -3).value,\n                ]\n                * (u.m / u.s),\n                {},\n            ),\n            (\n                ([0.001, 0.002] * u.T, [5e-10, 2e-10] * u.kg * u.m ** -3),\n                {},\n                [\n                    va_(0.001 * u.T, 5e-10 * u.kg * u.m ** -3).value,\n                    va_(0.002 * u.T, 2e-10 * u.kg * u.m ** -3).value,\n                ]\n                * (u.m / u.s),\n                {},\n            ),\n            (\n                (0.001 * u.T, [1.0e18, 2e18] * u.m ** -3),\n                {\"ion\": \"p\"},\n                [\n                    va_(0.001 * u.T, 1e18 * u.m ** -3, ion=\"p\").value,\n                    va_(0.001 * u.T, 2e18 * u.m ** -3, ion=\"p\").value,\n                ]\n                * (u.m / u.s),\n                {},\n            ),\n        ],\n    )\n    def test_values(self, args, kwargs, expected, isclose_kw):\n        \"\"\"Test expected values.\"\"\"\n        assert np.allclose(Alfven_speed(*args, **kwargs), expected, **isclose_kw)\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, nan_mask\",\n        [\n            ((np.nan * u.T, 1 * u.kg * u.m ** -3), {}, []),\n            ((0.001 * u.T, np.nan * u.kg * u.m ** -3), {}, []),\n            (([np.nan, 0.001] * u.T, 1 * u.kg * u.m ** -3), {}, [True, False]),\n            (\n                (0.001 * u.T, [np.nan, 1.0, np.nan] * u.kg * u.m ** -3),\n                {},\n                [True, False, True],\n            ),\n            (([np.nan, 0.001] * u.T, [1, np.nan] * u.kg * u.m ** -3), {}, [True, True]),\n            (\n                (0.001 * u.T, [np.nan, 1e18, np.nan] * u.m ** -3),\n                {\"ion\": \"Ar+\"},\n                [True, False, True],\n            ),\n        ],\n    )\n    def test_nan_values(self, args, kwargs, nan_mask):\n        \"\"\"Input scenarios that leat to `numpy.nan` values being returned.\"\"\"\n        val = Alfven_speed(*args, **kwargs)\n        if np.isscalar(val.value):\n            assert np.isnan(val)\n        else:\n            nan_arr = np.isnan(val)\n            assert np.all(nan_arr[nan_mask])\n            assert np.all(np.logical_not(nan_arr[np.logical_not(nan_mask)]))\n\n    def test_handle_nparrays(self):\n        \"\"\"Test for ability to handle numpy array quantities\"\"\"\n        assert_can_handle_nparray(Alfven_speed)\n\n\nclass Test_Ion_Sound_Speed:\n    r\"\"\"Test the ion_sound_speed function in parameters.py.\"\"\"\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, expected, isclose_kw\",\n        [\n            (\n                (),\n                {\n                    \"T_i\": 1.3232 * u.MK,\n                    \"T_e\": 1.831 * u.MK,\n                    \"ion\": \"p\",\n                    \"gamma_e\": 1,\n                    \"gamma_i\": 3,\n                },\n                218816.06086407552 * (u.m / u.s),\n                {},\n            ),\n            (\n                (1.831 * u.MK, 1.3232 * u.MK, \"p\"),\n                {},\n                218816.06086407552 * (u.m / u.s),\n                {},\n            ),  # Test that function call without keyword argument works correctly\n            (\n                (),\n                {\n                    \"T_i\": 1.3232 * u.MK,\n                    \"T_e\": 1.831 * u.MK,\n                    \"n_e\": n_e,\n                    \"k\": k_1,\n                    \"ion\": \"p\",\n                    \"gamma_e\": 1,\n                    \"gamma_i\": 3,\n                },\n                218816.06086407552 * (u.m / u.s),\n                {},\n            ),\n            (\n                (),\n                {\n                    \"T_i\": 1.3232 * u.MK,\n                    \"T_e\": 1.831 * u.MK,\n                    \"n_e\": n_e,\n                    \"k\": k_2,\n                    \"ion\": \"p\",\n                    \"gamma_e\": 1,\n                    \"gamma_i\": 3,\n                },\n                552.3212936293337 * (u.m / u.s),\n                {},\n            ),\n            (\n                (),\n                {\n                    \"T_i\": 0.88 * u.MK,\n                    \"T_e\": 1.28 * u.MK,\n                    \"n_e\": n_e,\n                    \"k\": 0 * u.m ** -1,\n                    \"ion\": \"p\",\n                    \"gamma_e\": 1.2,\n                    \"gamma_i\": 3.4,\n                },\n                193328.52857788358 * (u.m / u.s),\n                {},\n            ),\n            (\n                (),\n                {\"T_i\": T_i, \"T_e\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p+\"},\n                ion_sound_speed(T_i=T_i, T_e=0 * u.K, n_e=n_e, k=k_1, ion=\"p+\").value\n                * (u.m / u.s),\n                {},\n            ),\n            (\n                (),\n                {\n                    \"T_e\": 1.2e6 * u.K,\n                    \"T_i\": 0 * u.K,\n                    \"n_e\": n_e,\n                    \"k\": 0 * u.m ** -1,\n                    \"z_mean\": 0.8,\n                    \"ion\": \"p\",\n                },\n                89018.09 * (u.m / u.s),\n                {\"atol\": 0.0, \"rtol\": 1e-6},\n            ),  # testing for user input z_mean\n        ],\n    )\n    def test_values(self, args, kwargs, expected, isclose_kw):\n        assert np.isclose(ion_sound_speed(*args, **kwargs), expected, **isclose_kw)\n\n    # case when Z=1 is assumed\n    # assert ion_sound_speed(T_i=T_i, T_e=T_e, ion='p+') == ion_sound_speed(T_i=T_i, T_e=T_e,\n    # ion='H-1')\n\n    @pytest.mark.parametrize(\n        \"kwargs1, kwargs2, _warning\",\n        [\n            ({\"T_i\": T_i, \"T_e\": T_e, \"n_e\": n_e, \"ion\": \"p\"}, {}, PhysicsWarning),\n            ({\"T_i\": T_i, \"T_e\": T_e, \"k\": k_1, \"ion\": \"p\"}, {}, PhysicsWarning),\n            ({\"T_i\": 5e11 * u.K, \"T_e\": 0 * u.K, \"ion\": \"p\"}, {}, RelativityWarning),\n            (\n                {\"T_e\": 1.2e6, \"T_i\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"},\n                {\"T_e\": 1.2e6 * u.K, \"T_i\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"},\n                u.UnitsWarning,\n            ),\n            (\n                {\"T_i\": 1.3e6, \"T_e\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"},\n                {\"T_i\": 1.3e6 * u.K, \"T_e\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"},\n                u.UnitsWarning,\n            ),\n        ],\n    )\n    def test_warns(self, kwargs1, kwargs2, _warning):\n        with pytest.warns(_warning):\n            val = ion_sound_speed(**kwargs1)\n            if kwargs2 != {}:\n                val == ion_sound_speed(**kwargs2)\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, _error\",\n        [\n            (\n                (),\n                {\n                    \"T_i\": T_i,\n                    \"T_e\": T_e,\n                    \"n_e\": n_e,\n                    \"k\": k_1,\n                    \"ion\": \"p\",\n                    \"gamma_i\": np.inf,\n                },\n                RelativityError,\n            ),\n            (\n                (),\n                {\n                    \"T_i\": np.array([5, 6, 5]) * u.K,\n                    \"T_e\": np.array([3, 4]) * u.K,\n                    \"n_e\": np.array([5, 6, 5]) * u.m ** -3,\n                    \"k\": np.array([3, 4]) * u.m ** -3,\n                    \"ion\": \"p\",\n                },\n                u.UnitTypeError,\n            ),\n            ((5 * u.T), {\"ion\": \"p\"}, TypeError),  # Is this test right??????\n            ((), {\"ion\": \"p\"}, TypeError),\n            (\n                (),\n                {\"T_i\": T_i, \"T_e\": 0 * u.K, \"gamma_i\": 0.9999, \"ion\": \"p\"},\n                PhysicsError,\n            ),\n            (\n                (),\n                {\"T_i\": T_i, \"T_e\": 0 * u.K, \"gamma_e\": 0.9999, \"ion\": \"p\"},\n                PhysicsError,\n            ),\n            (\n                (),\n                {\"T_i\": T_i, \"T_e\": 0 * u.K, \"gamma_e\": \"sdjklsf\", \"ion\": \"p\"},\n                TypeError,\n            ),\n            (\n                (),\n                {\"T_i\": T_i, \"T_e\": 0 * u.K, \"gamma_i\": \"fsdfas\", \"ion\": \"p\"},\n                TypeError,\n            ),\n            ((), {\"T_i\": T_i, \"T_e\": 0 * u.K, \"ion\": \"cupcakes\"}, InvalidParticleError),\n            ((), {\"T_i\": -np.abs(T_i), \"T_e\": 0 * u.K, \"ion\": \"p\"}, ValueError),\n            (\n                (),\n                {\"T_i\": T_i, \"T_e\": 0 * u.K, \"n_e\": -np.abs(n_e), \"k\": k_1, \"ion\": \"p\"},\n                ValueError,\n            ),\n            (\n                (),\n                {\"T_i\": T_i, \"T_e\": 0 * u.K, \"n_e\": n_e, \"k\": -np.abs(k_1), \"ion\": \"p\"},\n                ValueError,\n            ),\n            ((), {\"T_i\": 5e19 * u.K, \"T_e\": 0 * u.K, \"ion\": \"p\"}, RelativityError),\n            (\n                (),\n                {\"T_i\": 5 * u.A, \"T_e\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"},\n                u.UnitTypeError,\n            ),\n            (\n                (),\n                {\"T_i\": T_negarr, \"T_e\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"},\n                ValueError,\n            ),\n            (\n                (),\n                {\"T_e\": T_negarr, \"T_i\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"},\n                ValueError,\n            ),\n        ],\n    )\n    def test_raises(self, args, kwargs, _error):\n        with pytest.raises(_error):\n            ion_sound_speed(*args, **kwargs)\n\n    @pytest.mark.parametrize(\n        \"kwargs\",\n        [\n            ({\"T_i\": T_nanarr, \"T_e\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"}),\n            ({\"T_e\": T_nanarr, \"T_i\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"}),\n        ],\n    )\n    def test_nan_values(self, kwargs):\n        np.isnan(ion_sound_speed(**kwargs)[1])\n\n    def test_handle_nparrays(self):\n        assert_can_handle_nparray(ion_sound_speed)\n\n\ndef test_thermal_pressure():\n    assert thermal_pressure(T_e, n_i).unit.is_equivalent(u.Pa)\n\n    # TODO: may be array issues with arg \"mass\"\n    assert_can_handle_nparray(thermal_pressure)\n\n\ndef test_gyrofrequency():\n    r\"\"\"Test the gyrofrequency function in parameters.py.\"\"\"\n\n    assert gyrofrequency(B, \"e-\").unit.is_equivalent(u.rad / u.s)\n\n    assert gyrofrequency(B, \"e-\", to_hz=True).unit.is_equivalent(u.Hz)\n\n    assert np.isclose(gyrofrequency(1 * u.T, \"e-\").value, 175882008784.72018)\n\n    assert np.isclose(gyrofrequency(2.4 * u.T, \"e-\").value, 422116821083.3284)\n\n    assert np.isclose(\n        gyrofrequency(1 * u.T, \"e-\", to_hz=True).value, 27992490076.528206\n    )\n\n    assert np.isclose(\n        gyrofrequency(2.4 * u.T, \"e-\", signed=True).value, -422116821083.3284\n    )\n\n    assert np.isclose(gyrofrequency(1 * u.G, \"e-\").cgs.value, 1.76e7, rtol=1e-3)\n\n    with pytest.raises(TypeError):\n        with pytest.warns(u.UnitsWarning):\n            gyrofrequency(u.m, \"e-\")\n\n    with pytest.raises(u.UnitTypeError):\n        gyrofrequency(u.m * 1, \"e-\")\n\n    assert np.isnan(gyrofrequency(B_nanarr, \"e-\")[-1])\n\n    # The following is a test to check that equivalencies from astropy\n    # are working.\n    omega_ce = gyrofrequency(2.2 * u.T, \"e-\")\n    f_ce = (omega_ce / (2 * np.pi)) / u.rad\n    f_ce_use_equiv = omega_ce.to(u.Hz, equivalencies=[(u.cy / u.s, u.Hz)])\n    assert np.isclose(f_ce.value, f_ce_use_equiv.value)\n\n    with pytest.warns(u.UnitsWarning):\n        assert gyrofrequency(5.0, \"e-\") == gyrofrequency(5.0 * u.T, \"e-\")\n\n    assert gyrofrequency(B, particle=ion).unit.is_equivalent(u.rad / u.s)\n\n    assert np.isclose(gyrofrequency(1 * u.T, particle=\"p\").value, 95788335.834874)\n\n    assert np.isclose(gyrofrequency(2.4 * u.T, particle=\"p\").value, 229892006.00369796)\n\n    assert np.isclose(gyrofrequency(1 * u.G, particle=\"p\").cgs.value, 9.58e3, rtol=2e-3)\n\n    assert gyrofrequency(-5 * u.T, \"p\") == gyrofrequency(5 * u.T, \"p\")\n\n    # Case when Z=1 is assumed\n    # assert gyrofrequency(B, particle='p+') == gyrofrequency(B, particle='H-1')\n\n    assert gyrofrequency(B, particle=\"e+\") == gyrofrequency(B, \"e-\")\n\n    with pytest.warns(u.UnitsWarning):\n        gyrofrequency(8, \"p\")\n\n    with pytest.raises(u.UnitTypeError):\n        gyrofrequency(5 * u.m, \"p\")\n\n    with pytest.raises(InvalidParticleError):\n        gyrofrequency(8 * u.T, particle=\"asdfasd\")\n\n    with pytest.warns(u.UnitsWarning):\n        # TODO this should be WARNS, not RAISES. and it's probably still raised\n        assert gyrofrequency(5.0, \"p\") == gyrofrequency(5.0 * u.T, \"p\")\n\n    gyrofrequency(1 * u.T, particle=\"p\")\n    # testing for user input Z\n    testMeth1 = gyrofrequency(1 * u.T, particle=\"p\", Z=0.8).si.value\n    testTrue1 = 76630665.79318453\n    errStr = f\"gyrofrequency() gave {testMeth1}, should be {testTrue1}.\"\n    assert np.isclose(testMeth1, testTrue1, atol=0.0, rtol=1e-5), errStr\n\n    assert_can_handle_nparray(gyrofrequency, kwargs={\"signed\": True})\n\n    assert_can_handle_nparray(gyrofrequency, kwargs={\"signed\": False})\n\n\ndef test_gyroradius():\n    r\"\"\"Test the gyroradius function in parameters.py.\"\"\"\n\n    assert gyroradius(B, \"e-\", T=T_e).unit.is_equivalent(u.m)\n\n    assert gyroradius(B, \"e-\", Vperp=25 * u.m / u.s).unit.is_equivalent(u.m)\n\n    # test for possiblity to allow nan for input values\n    assert np.isnan(gyroradius(np.nan * u.T, particle=\"e-\", T=1 * u.K))\n    assert np.isnan(gyroradius(1 * u.T, particle=\"e-\", T=np.nan * u.K))\n    assert np.isnan(gyroradius(1 * u.T, particle=\"e-\", Vperp=np.nan * u.m / u.s))\n\n    Vperp = 1e6 * u.m / u.s\n    Bmag = 1 * u.T\n    omega_ce = gyrofrequency(Bmag, \"e-\")\n    analytical_result = (Vperp / omega_ce).to(\n        u.m, equivalencies=u.dimensionless_angles()\n    )\n    assert gyroradius(Bmag, \"e-\", Vperp=Vperp) == analytical_result\n\n    with pytest.raises(TypeError):\n        with pytest.warns(u.UnitsWarning):\n            gyroradius(u.T, \"e-\")\n\n    with pytest.raises(u.UnitTypeError):\n        gyroradius(5 * u.A, \"e-\", Vperp=8 * u.m / u.s)\n\n    with pytest.raises(u.UnitTypeError):\n        gyroradius(5 * u.T, \"e-\", Vperp=8 * u.m)\n\n    with pytest.raises(ValueError):\n        gyroradius(np.array([5, 6]) * u.T, \"e-\", Vperp=np.array([5, 6, 7]) * u.m / u.s)\n\n    assert np.isnan(gyroradius(np.nan * u.T, \"e-\", Vperp=1 * u.m / u.s))\n\n    with pytest.raises(ValueError):\n        gyroradius(3.14159 * u.T, \"e-\", T=-1 * u.K)\n\n    with pytest.warns(u.UnitsWarning):\n        assert gyroradius(1.0, \"e-\", Vperp=1.0) == gyroradius(\n            1.0 * u.T, \"e-\", Vperp=1.0 * u.m / u.s\n        )\n\n    with pytest.warns(u.UnitsWarning):\n        assert gyroradius(1.1, \"e-\", T=1.2) == gyroradius(1.1 * u.T, \"e-\", T=1.2 * u.K)\n\n    with pytest.raises(ValueError):\n        gyroradius(1.1 * u.T, \"e-\", Vperp=1 * u.m / u.s, T=1.2 * u.K)\n\n    with pytest.raises(u.UnitTypeError):\n        gyroradius(1.1 * u.T, \"e-\", Vperp=1.1 * u.m, T=1.2 * u.K)\n\n    # Check for Deprecation warning when using T_i instead of T\n    with pytest.warns(PlasmaPyFutureWarning):\n        gyroradius(1.1 * u.T, \"e-\", T_i=1.2 * u.K)\n\n    assert gyroradius(B, particle=\"p\", T=T_i).unit.is_equivalent(u.m)\n\n    assert gyroradius(B, particle=\"p\", Vperp=25 * u.m / u.s).unit.is_equivalent(u.m)\n\n    # Case when Z=1 is assumed\n    assert np.isclose(\n        gyroradius(B, particle=\"p\", T=T_i),\n        gyroradius(B, particle=\"H+\", T=T_i),\n        atol=1e-6 * u.m,\n    )\n\n    gyroPos = gyroradius(B, particle=\"p\", Vperp=V)\n    gyroNeg = gyroradius(B, particle=\"p\", Vperp=-V)\n    assert gyroPos == gyroNeg\n\n    Vperp = 1e6 * u.m / u.s\n    Bmag = 1 * u.T\n    omega_ci = gyrofrequency(Bmag, particle=\"p\")\n    analytical_result = (Vperp / omega_ci).to(\n        u.m, equivalencies=u.dimensionless_angles()\n    )\n    assert gyroradius(Bmag, particle=\"p\", Vperp=Vperp) == analytical_result\n\n    T2 = 1.2 * u.MK\n    B2 = 123 * u.G\n    particle2 = \"alpha\"\n    Vperp2 = thermal_speed(T2, particle=particle2)\n    gyro_by_vperp = gyroradius(B2, particle=\"alpha\", Vperp=Vperp2)\n    assert gyro_by_vperp == gyroradius(B2, particle=\"alpha\", T=T2)\n\n    explicit_positron_gyro = gyroradius(1 * u.T, particle=\"positron\", T=1 * u.MK)\n    assert explicit_positron_gyro == gyroradius(1 * u.T, \"e-\", T=1 * u.MK)\n\n    with pytest.raises(TypeError):\n        with pytest.warns(u.UnitsWarning):\n            gyroradius(u.T, particle=\"p\", Vperp=8 * u.m / u.s)\n\n    with pytest.raises(ValueError):\n        gyroradius(B, particle=\"p\", T=-1 * u.K)\n\n    with pytest.warns(u.UnitsWarning):\n        gyro_without_units = gyroradius(1.0, particle=\"p\", Vperp=1.0)\n        gyro_with_units = gyroradius(1.0 * u.T, particle=\"p\", Vperp=1.0 * u.m / u.s)\n        assert gyro_without_units == gyro_with_units\n\n    with pytest.warns(u.UnitsWarning):\n        gyro_t_without_units = gyroradius(1.1, particle=\"p\", T=1.2)\n        gyro_t_with_units = gyroradius(1.1 * u.T, particle=\"p\", T=1.2 * u.K)\n        assert gyro_t_with_units == gyro_t_without_units\n\n    with pytest.raises(ValueError):\n        gyroradius(1.1 * u.T, particle=\"p\", Vperp=1 * u.m / u.s, T=1.2 * u.K)\n\n    with pytest.raises(u.UnitTypeError):\n        gyroradius(1.1 * u.T, particle=\"p\", Vperp=1.1 * u.m, T=1.2 * u.K)\n\n    with pytest.raises(u.UnitTypeError):\n        gyroradius(1.1 * u.T, particle=\"p\", Vperp=1.2 * u.m, T=1.1 * u.K)\n\n\nclass Test_gyroradius:\n\n    # some custom numpy array tests here, because of the T / Vperp situation\n    def test_handle_numpy_array(self):\n        # Tests to verify that can handle Quantities with numpy array as the value:\n        assert gyroradius(B_arr, \"e-\", Vperp=V_arr)[0] == gyroradius(\n            B_arr[0], \"e-\", Vperp=V_arr[0]\n        )\n        assert gyroradius(B_arr, \"e-\", T=T_arr)[0] == gyroradius(\n            B_arr[0], \"e-\", T=T_arr[0]\n        )\n\n    def test_handle_mixed_Qarrays(self):\n        # If both Vperp or T are input as Qarrays, but only one of the two is valid\n        # at each element, then that's fine, the function should work:\n        assert gyroradius(B_arr, \"e-\", Vperp=V_nanarr, T=T_nanarr2)[0] == gyroradius(\n            B_arr[0], \"e-\", Vperp=V_nanarr[0], T=T_nanarr2[0]\n        )\n\n    def test_raise_two_valid_inputs(self):\n        # If both Vperp or T are nan-less, Qarrays or not, should raise ValueError:\n        with pytest.raises(ValueError):\n            gyroradius(B_arr, \"e-\", Vperp=V, T=T_arr)\n        with pytest.raises(ValueError):\n            gyroradius(B_arr, \"e-\", Vperp=V_arr, T=T_i)\n\n    def test_all_valid_and_one_valid(self):\n        # If one of (Vperp, T) is a valid and one is Qarray with at least one valid, ValueError:\n        with pytest.raises(ValueError):\n            gyroradius(B_arr, \"e-\", Vperp=V, T=T_nanarr)\n        with pytest.raises(ValueError):\n            gyroradius(B_arr, \"e-\", Vperp=V_nanarr, T=T_i)\n\n    def test_scalar_and_nan_qarray(self):\n        # If either Vperp or T is a valid scalar and the other is a Qarray of all nans,\n        # should do something valid and not raise a ValueError\n        assert np.all(np.isfinite(gyroradius(B_arr, \"e-\", Vperp=V, T=T_allnanarr)))\n        assert np.all(np.isfinite(gyroradius(B_arr, \"e-\", Vperp=V_allnanarr, T=T_i)))\n\n    def test_keeps_arguments_unchanged(self):\n        Vperp1 = u.Quantity([np.nan, 1], unit=u.m / u.s)\n        Vperp2 = u.Quantity([np.nan, 1], unit=u.m / u.s)  # an exact copy\n        T_i = u.Quantity([1, np.nan], unit=u.K)\n\n        gyroradius(B_arr, \"e-\", Vperp=Vperp1, T=T_i)\n        assert_quantity_allclose(Vperp1, Vperp2)\n\n\ndef test_plasma_frequency():\n    r\"\"\"Test the plasma_frequency function in parameters.py.\"\"\"\n\n    assert plasma_frequency(n_e, \"e-\").unit.is_equivalent(u.rad / u.s)\n\n    assert plasma_frequency(n_e, \"e-\", to_hz=True).unit.is_equivalent(u.Hz)\n\n    assert np.isclose(plasma_frequency(1 * u.cm ** -3, \"e-\").value, 5.64e4, rtol=1e-2)\n\n    assert np.isclose(\n        plasma_frequency(1 * u.cm ** -3, particle=\"N\").value, 3.53e2, rtol=1e-1\n    )\n\n    assert np.isclose(\n        plasma_frequency(1 * u.cm ** -3, particle=\"N\", to_hz=True).value,\n        56.19000195094519,\n    )\n\n    with pytest.raises(TypeError):\n        with pytest.warns(u.UnitsWarning):\n            plasma_frequency(u.m ** -3, \"e-\")\n\n    with pytest.raises(u.UnitTypeError):\n        plasma_frequency(5 * u.m ** -2, \"e-\")\n\n    assert np.isnan(plasma_frequency(np.nan * u.m ** -3, \"e-\"))\n\n    with pytest.warns(u.UnitsWarning):\n        assert plasma_frequency(1e19, \"e-\") == plasma_frequency(1e19 * u.m ** -3, \"e-\")\n\n        assert plasma_frequency(n_i, particle=\"p\").unit.is_equivalent(u.rad / u.s)\n\n    # Case where Z=1 is assumed\n    assert plasma_frequency(n_i, particle=\"H-1+\") == plasma_frequency(n_i, particle=\"p\")\n\n    assert np.isclose(\n        plasma_frequency(mu * u.cm ** -3, particle=\"p\").value, 1.32e3, rtol=1e-2\n    )\n\n    with pytest.raises(ValueError):\n        plasma_frequency(n=5 * u.m ** -3, particle=\"sdfas\")\n\n    with pytest.warns(u.UnitsWarning):\n        plasma_freq_no_units = plasma_frequency(1e19, particle=\"p\")\n        assert plasma_freq_no_units == plasma_frequency(1e19 * u.m ** -3, particle=\"p\")\n\n    plasma_frequency(1e17 * u.cm ** -3, particle=\"p\")\n    # testing for user input z_mean\n    testMeth1 = plasma_frequency(1e17 * u.cm ** -3, particle=\"p\", z_mean=0.8).si.value\n    testTrue1 = 333063562455.4028\n    errStr = f\"plasma_frequency() gave {testMeth1}, should be {testTrue1}.\"\n    assert np.isclose(testMeth1, testTrue1, atol=0.0, rtol=1e-6), errStr\n\n    assert_can_handle_nparray(plasma_frequency)\n\n\ndef test_Debye_length():\n    r\"\"\"Test the Debye_length function in parameters.py.\"\"\"\n\n    assert Debye_length(T_e, n_e).unit.is_equivalent(u.m)\n\n    assert np.isclose(Debye_length(1 * u.eV, 1 * u.cm ** -3).value, 7.43, atol=0.005)\n\n    with pytest.warns(u.UnitsWarning):\n        Debye_length(5, 5 * u.m ** -3)\n\n    with pytest.raises(u.UnitTypeError):\n        Debye_length(56 * u.kg, 5 * u.m ** -3)\n\n    with pytest.raises(ValueError):\n        Debye_length(5 * u.eV, -5 * u.m ** -3)\n\n    with pytest.raises(ValueError):\n        Debye_length(-45 * u.K, 5 * u.m ** -3)\n\n    Tarr2 = np.array([1, 2]) * u.K\n    narr3 = np.array([1, 2, 3]) * u.m ** -3\n    with pytest.raises(ValueError):\n        Debye_length(Tarr2, narr3)\n\n    with pytest.warns(u.UnitsWarning):\n        assert Debye_length(2.0, 2.0) == Debye_length(2.0 * u.K, 2.0 * u.m ** -3)\n\n    with pytest.warns(u.UnitsWarning):\n        assert Debye_length(2.0 * u.K, 2.0) == Debye_length(2.0, 2.0 * u.m ** -3)\n\n    assert_can_handle_nparray(Debye_length)\n\n\ndef test_Debye_number():\n    r\"\"\"Test the Debye_number function in parameters.py.\"\"\"\n\n    assert Debye_number(T_e, n_e).unit.is_equivalent(u.dimensionless_unscaled)\n\n    T_e_eV = T_e.to(u.eV, equivalencies=u.temperature_energy())\n    assert np.isclose(Debye_number(T_e, n_e).value, Debye_number(T_e_eV, n_e).value)\n\n    assert np.isclose(Debye_number(1 * u.eV, 1 * u.cm ** -3).value, 1720862385.43342)\n\n    with pytest.warns(u.UnitsWarning):\n        Debye_number(T_e, 4)\n\n    with pytest.raises(ValueError):\n        Debye_number(None, n_e)\n\n    with pytest.raises(u.UnitTypeError):\n        Debye_number(5 * u.m, 5 * u.m ** -3)\n\n    with pytest.raises(u.UnitTypeError):\n        Debye_number(5 * u.K, 5 * u.m ** 3)\n\n    with pytest.raises(ValueError):\n        Debye_number(5j * u.K, 5 * u.cm ** -3)\n\n    Tarr2 = np.array([1, 2]) * u.K\n    narr3 = np.array([1, 2, 3]) * u.m ** -3\n    with pytest.raises(ValueError):\n        Debye_number(Tarr2, narr3)\n\n    with pytest.warns(u.UnitsWarning):\n        assert Debye_number(1.1, 1.1) == Debye_number(1.1 * u.K, 1.1 * u.m ** -3)\n\n    with pytest.warns(u.UnitsWarning):\n        assert Debye_number(1.1 * u.K, 1.1) == Debye_number(1.1, 1.1 * u.m ** -3)\n\n    assert_can_handle_nparray(Debye_number)\n\n\ndef test_inertial_length():\n    r\"\"\"Test the inertial_length function in parameters.py.\"\"\"\n\n    assert inertial_length(n_i, particle=\"p\").unit.is_equivalent(u.m)\n\n    assert np.isclose(\n        inertial_length(mu * u.cm ** -3, particle=\"p\").cgs.value, 2.28e7, rtol=0.01\n    )\n\n    inertial_length_electron_plus = inertial_length(5.351 * u.m ** -3, particle=\"e+\")\n    assert inertial_length_electron_plus == inertial_length(\n        5.351 * u.m ** -3, particle=\"e\"\n    )\n\n    assert inertial_length(n_i, particle=\"p\") == inertial_length(n_i, particle=\"p\")\n\n    with pytest.warns(u.UnitsWarning):\n        inertial_length(4, particle=\"p\")\n\n    with pytest.raises(u.UnitTypeError):\n        inertial_length(4 * u.m ** -2, particle=\"p\")\n\n    with pytest.raises(ValueError):\n        inertial_length(-5 * u.m ** -3, particle=\"p\")\n\n    with pytest.raises(InvalidParticleError):\n        inertial_length(n_i, particle=-135)\n\n    with pytest.warns(u.UnitsWarning):\n        inertial_length_no_units = inertial_length(1e19, particle=\"p\")\n        assert inertial_length_no_units == inertial_length(\n            1e19 * u.m ** -3, particle=\"p\"\n        )\n\n    assert inertial_length(n_e, \"e-\").unit.is_equivalent(u.m)\n\n    assert np.isclose(\n        inertial_length(1 * u.cm ** -3, \"e-\").cgs.value, 5.31e5, rtol=1e-3\n    )\n\n    with pytest.warns(u.UnitsWarning):\n        inertial_length(5, \"e-\")\n\n    with pytest.raises(u.UnitTypeError):\n        inertial_length(5 * u.m, \"e-\")\n\n    with pytest.raises(ValueError):\n        inertial_length(-5 * u.m ** -3, \"e-\")\n\n    with pytest.warns(u.UnitsWarning):\n        assert inertial_length(1e19, \"e-\") == inertial_length(1e19 * u.m ** -3, \"e-\")\n\n    assert_can_handle_nparray(inertial_length)\n\n\ndef test_magnetic_pressure():\n    r\"\"\"Test the magnetic_pressure function in parameters.py.\"\"\"\n\n    assert magnetic_pressure(B_arr).unit.is_equivalent(u.Pa)\n\n    assert magnetic_pressure(B).unit.is_equivalent(u.Pa)\n\n    assert magnetic_pressure(B).unit.name == \"Pa\"\n\n    assert magnetic_pressure(B).value == magnetic_energy_density(B).value\n\n    assert magnetic_pressure(B) == magnetic_energy_density(B.to(u.G))\n\n    assert np.isclose(magnetic_pressure(B).value, 397887.35772973835)\n\n    with pytest.warns(u.UnitsWarning):\n        magnetic_pressure(5)\n\n    with pytest.raises(u.UnitTypeError):\n        magnetic_pressure(5 * u.m)\n\n    assert np.isnan(magnetic_pressure(np.nan * u.T))\n\n    with pytest.raises(ValueError):\n        magnetic_pressure(5j * u.T)\n\n    assert np.isnan(magnetic_pressure(B_nanarr)[-1])\n\n    with pytest.warns(u.UnitsWarning):\n        assert magnetic_pressure(22.2) == magnetic_pressure(22.2 * u.T)\n\n    assert_can_handle_nparray(magnetic_pressure)\n\n\ndef test_magnetic_energy_density():\n    r\"\"\"Test the magnetic_energy_density function in parameters.py.\"\"\"\n\n    assert magnetic_energy_density(B_arr).unit.is_equivalent(u.J / u.m ** 3)\n\n    assert magnetic_energy_density(B).unit.is_equivalent(\"J / m3\")\n\n    assert magnetic_energy_density(B).value == magnetic_pressure(B).value\n\n    assert_quantity_allclose(\n        magnetic_energy_density(2 * B), 4 * magnetic_energy_density(B)\n    )\n\n    assert_quantity_allclose(magnetic_energy_density(B).value, 397887.35772973835)\n\n    assert_quantity_allclose(\n        magnetic_energy_density(B), magnetic_energy_density(B.to(u.G))\n    )\n\n    assert isinstance(magnetic_energy_density(B_arr), u.Quantity)\n\n    with pytest.warns(u.UnitsWarning):\n        magnetic_energy_density(5)\n\n    with pytest.raises(u.UnitTypeError):\n        magnetic_energy_density(5 * u.m)\n\n    assert np.isnan(magnetic_energy_density(np.nan * u.T))\n\n    with pytest.raises(ValueError):\n        magnetic_energy_density(5j * u.T)\n\n    assert np.isnan(magnetic_energy_density(B_nanarr)[-1])\n\n    with pytest.warns(u.UnitsWarning):\n        assert magnetic_energy_density(22.2) == magnetic_energy_density(22.2 * u.T)\n\n    assert_can_handle_nparray(magnetic_energy_density)\n\n\ndef test_upper_hybrid_frequency():\n    r\"\"\"Test the upper_hybrid_frequency function in parameters.py.\"\"\"\n\n    omega_uh = upper_hybrid_frequency(B, n_e=n_e)\n    omega_uh_hz = upper_hybrid_frequency(B, n_e=n_e, to_hz=True)\n    omega_ce = gyrofrequency(B, \"e-\")\n    omega_pe = plasma_frequency(n=n_e, particle=\"e-\")\n    assert omega_ce.unit.is_equivalent(u.rad / u.s)\n    assert omega_pe.unit.is_equivalent(u.rad / u.s)\n    assert omega_uh.unit.is_equivalent(u.rad / u.s)\n    assert omega_uh_hz.unit.is_equivalent(u.Hz)\n    left_hand_side = omega_uh ** 2\n    right_hand_side = omega_ce ** 2 + omega_pe ** 2\n    assert np.isclose(left_hand_side.value, right_hand_side.value)\n\n    assert np.isclose(omega_uh_hz.value, 69385868857.90918)\n\n    with pytest.raises(ValueError):\n        upper_hybrid_frequency(5 * u.T, n_e=-1 * u.m ** -3)\n\n    with pytest.warns(u.UnitsWarning):\n        assert upper_hybrid_frequency(1.2, 1.3) == upper_hybrid_frequency(\n            1.2 * u.T, 1.3 * u.m ** -3\n        )\n\n    with pytest.warns(u.UnitsWarning):\n        assert upper_hybrid_frequency(1.4 * u.T, 1.3) == upper_hybrid_frequency(\n            1.4, 1.3 * u.m ** -3\n        )\n\n    assert_can_handle_nparray(upper_hybrid_frequency)\n\n\ndef test_lower_hybrid_frequency():\n    r\"\"\"Test the lower_hybrid_frequency function in parameters.py.\"\"\"\n\n    ion = \"He-4 1+\"\n    omega_ci = gyrofrequency(B, particle=ion)\n    omega_pi = plasma_frequency(n=n_i, particle=ion)\n    omega_ce = gyrofrequency(B, \"e-\")\n    omega_lh = lower_hybrid_frequency(B, n_i=n_i, ion=ion)\n    omega_lh_hz = lower_hybrid_frequency(B, n_i=n_i, ion=ion, to_hz=True)\n    assert omega_ci.unit.is_equivalent(u.rad / u.s)\n    assert omega_pi.unit.is_equivalent(u.rad / u.s)\n    assert omega_ce.unit.is_equivalent(u.rad / u.s)\n    assert omega_lh.unit.is_equivalent(u.rad / u.s)\n    left_hand_side = omega_lh ** -2\n    right_hand_side = (\n        1 / (omega_ci ** 2 + omega_pi ** 2) + omega_ci ** -1 * omega_ce ** -1\n    )\n    assert np.isclose(left_hand_side.value, right_hand_side.value)\n\n    assert np.isclose(omega_lh_hz.value, 299878691.3223296)\n\n    with pytest.raises(ValueError):\n        lower_hybrid_frequency(0.2 * u.T, n_i=5e19 * u.m ** -3, ion=\"asdfasd\")\n\n    with pytest.raises(ValueError):\n        lower_hybrid_frequency(0.2 * u.T, n_i=-5e19 * u.m ** -3, ion=\"asdfasd\")\n\n    with pytest.raises(ValueError):\n        lower_hybrid_frequency(np.nan * u.T, n_i=-5e19 * u.m ** -3, ion=\"asdfasd\")\n\n    with pytest.warns(u.UnitsWarning):\n        assert lower_hybrid_frequency(1.3, 1e19, \"p+\") == lower_hybrid_frequency(\n            1.3 * u.T, 1e19 * u.m ** -3, \"p+\"\n        )\n    assert_can_handle_nparray(lower_hybrid_frequency)\n\n\ndef test_Bohm_diffusion():\n    r\"\"\"Test Mag_Reynolds in dimensionless.py\"\"\"\n\n    T_e = 5000 * u.K\n    B = 10 * u.T\n\n    assert (Bohm_diffusion(T_e, B)).unit == u.m ** 2 / u.s\n\n    with pytest.warns(u.UnitsWarning):\n        Bohm_diffusion(5000, B)\n\n    with pytest.raises(u.UnitTypeError):\n        Bohm_diffusion(2.2 * u.kg, B)\n\n\n@pytest.mark.parametrize(\n    \"alias, parent\",\n    [\n        (rho_, mass_density),\n        (va_, Alfven_speed),\n        (cs_, ion_sound_speed),\n        (pth_, thermal_pressure),\n        (betaH_, Hall_parameter),\n        (oc_, gyrofrequency),\n        (wc_, gyrofrequency),\n        (rc_, gyroradius),\n        (rhoc_, gyroradius),\n        (wp_, plasma_frequency),\n        (lambdaD_, Debye_length),\n        (nD_, Debye_number),\n        (cwp_, inertial_length),\n        (pmag_, magnetic_pressure),\n        (ub_, magnetic_energy_density),\n        (wuh_, upper_hybrid_frequency),\n        (wlh_, lower_hybrid_frequency),\n        (DB_, Bohm_diffusion),\n    ],\n)\ndef test_parameters_aliases(alias, parent):\n    \"\"\"Test all aliases defined in parameters.py\"\"\"\n    assert alias is parent\n    \n        )\n        \n    ,\n        \n        \n        \n    )\n    )\n    \n    )\n    \n    \n    \n    ),\n    \n    \n\n    \n\n    ),\n        )\n    \n",
    "after": "\"\"\"Tests for functions that calculate plasma parameters.\"\"\"\n\nimport numpy as np\nimport pytest\n\nfrom astropy import units as u\nfrom astropy.constants import m_e, m_p\nfrom astropy.tests.helper import assert_quantity_allclose\n\nfrom plasmapy.formulary.parameters import (\n    Alfven_speed,\n    betaH_,\n    Bohm_diffusion,\n    cs_,\n    cwp_,\n    DB_,\n    Debye_length,\n    Debye_number,\n    gyrofrequency,\n    gyroradius,\n    Hall_parameter,\n    inertial_length,\n    ion_sound_speed,\n    lambdaD_,\n    lower_hybrid_frequency,\n    magnetic_energy_density,\n    magnetic_pressure,\n    mass_density,\n    nD_,\n    oc_,\n    plasma_frequency,\n    pmag_,\n    pth_,\n    rc_,\n    rho_,\n    rhoc_,\n    thermal_pressure,\n    thermal_speed,\n    ub_,\n    upper_hybrid_frequency,\n    va_,\n    wc_,\n    wlh_,\n    wp_,\n    wuh_,\n)\nfrom plasmapy.particles import Particle\nfrom plasmapy.particles.exceptions import InvalidParticleError\nfrom plasmapy.utils.exceptions import (\n    PhysicsError,\n    PhysicsWarning,\n    PlasmaPyFutureWarning,\n    RelativityError,\n    RelativityWarning,\n)\nfrom plasmapy.utils.pytest_helpers import assert_can_handle_nparray\n\nB = 1.0 * u.T\nZ = 1\nion = \"p\"\nm_i = m_p\nn_i = 5e19 * u.m ** -3\nn_e = Z * 5e19 * u.m ** -3\nrho = n_i * m_i + n_e * m_e\nT_e = 1e6 * u.K\nT_i = 1e6 * u.K\nk_1 = 3e1 * u.m ** -1\nk_2 = 3e7 * u.m ** -1\n\nB_arr = np.array([0.001, 0.002]) * u.T\nB_nanarr = np.array([0.001, np.nan]) * u.T\nB_allnanarr = np.array([np.nan, np.nan]) * u.T\n\nrho_arr = np.array([5e-10, 2e-10]) * u.kg / u.m ** 3\nrho_infarr = np.array([np.inf, 5e19]) * u.m ** -3\nrho_negarr = np.array([-5e19, 6e19]) * u.m ** -3\n\nT_arr = np.array([1e6, 2e6]) * u.K\nT_nanarr = np.array([1e6, np.nan]) * u.K\nT_nanarr2 = np.array([np.nan, 2e6]) * u.K\nT_allnanarr = np.array([np.nan, np.nan]) * u.K\nT_negarr = np.array([1e6, -5151.0]) * u.K\n\nV = 25.2 * u.m / u.s\nV_arr = np.array([25, 50]) * u.m / u.s\nV_nanarr = np.array([25, np.nan]) * u.m / u.s\nV_allnanarr = np.array([np.nan, np.nan]) * u.m / u.s\n\nmu = m_p.to(u.u).value\n\n\nclass Test_mass_density:\n    r\"\"\"Test the mass_density function in parameters.py.\"\"\"\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, conditional\",\n        [\n            ((-1 * u.kg * u.m ** -3, \"He\"), {}, pytest.raises(ValueError)),\n            ((-1 * u.m ** -3, \"He\"), {}, pytest.raises(ValueError)),\n            ((\"not a Quantity\", \"He\"), {}, pytest.raises(TypeError)),\n            ((1 * u.m ** -3,), {}, pytest.raises(TypeError)),\n            ((1 * u.J, \"He\"), {}, pytest.raises(u.UnitTypeError)),\n            ((1 * u.m ** -3, None), {}, pytest.raises(TypeError)),\n            (\n                (1 * u.m ** -3, \"He\"),\n                {\"z_ratio\": \"not a ratio\"},\n                pytest.raises(TypeError),\n            ),\n        ],\n    )\n    def test_raises(self, args, kwargs, conditional):\n        with conditional:\n            mass_density(*args, **kwargs)\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, expected\",\n        [\n            ((1.0 * u.g * u.m ** -3, \"\"), {}, 1.0e-3 * u.kg * u.m ** -3),\n            ((5.0e12 * u.cm ** -3, \"He\"), {}, 3.32323849e-8 * u.kg * u.m ** -3),\n            (\n                (5.0e12 * u.cm ** -3, Particle(\"He\")),\n                {},\n                3.32323849e-8 * u.kg * u.m ** -3,\n            ),\n            (\n                (5.0e12 * u.cm ** -3, \"He\"),\n                {\"z_ratio\": 0.5},\n                1.66161925e-08 * u.kg * u.m ** -3,\n            ),\n            (\n                (5.0e12 * u.cm ** -3, \"He\"),\n                {\"z_ratio\": -0.5},\n                1.66161925e-08 * u.kg * u.m ** -3,\n            ),\n        ],\n    )\n    def test_values(self, args, kwargs, expected):\n        assert np.isclose(mass_density(*args, **kwargs), expected)\n\n    def test_handle_nparrays(self):\n        \"\"\"Test for ability to handle numpy array quantities\"\"\"\n        assert_can_handle_nparray(mass_density)\n\n\n# Assertions below that are in CGS units with 2-3 significant digits\n# are generally from the NRL Plasma Formulary.\n\n\nclass TestAlfvenSpeed:\n    \"\"\"Test `~plasmapy.formulary.parameters.Alfven_speed`.\"\"\"\n\n    @pytest.mark.parametrize(\"alias\", [va_])\n    def test_aliases(self, alias):\n        assert alias is Alfven_speed\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, _error\",\n        [\n            # scenarios that raise RelativityError\n            ((10 * u.T, 1.0e-10 * u.kg * u.m ** -3), {}, RelativityError),\n            ((np.inf * u.T, 1 * u.m ** -3), {\"ion\": \"p\"}, RelativityError),\n            ((-np.inf * u.T, 1 * u.m ** -3), {\"ion\": \"p\"}, RelativityError),\n            #\n            # scenarios that raise InvalidParticleError\n            ((1 * u.T, 5e19 * u.m ** -3), {\"ion\": \"spacecats\"}, InvalidParticleError),\n            #\n            # scenarios that raise TypeError\n            ((\"not a Bfield\", 1.0e-10 * u.kg * u.m ** -3), {}, TypeError),\n            ((10 * u.T, \"not a density\"), {}, TypeError),\n            ((10 * u.T, 5), {\"ion\": \"p\"}, TypeError),\n            ((1 * u.T, 1.0e18 * u.m ** -3), {\"ion\": [\"He\"]}, TypeError),\n            ((1 * u.T, 1.0e18 * u.m ** -3), {\"ion\": \"He\", \"z_mean\": \"nope\"}, TypeError),\n            #\n            # scenarios that raise UnitTypeError\n            ((1 * u.T, 1.0e18 * u.cm), {\"ion\": \"He\"}, u.UnitTypeError),\n            ((1 * u.T, 5 * u.m ** -2), {\"ion\": \"p\"}, u.UnitTypeError),\n            ((1 * u.cm, 1.0e18 * u.m ** -3), {\"ion\": \"He\"}, u.UnitTypeError),\n            ((5 * u.A, 5e19 * u.m ** -3), {\"ion\": \"p\"}, u.UnitTypeError),\n            #\n            # scenarios that raise ValueError\n            ((1 * u.T, -1.0e18 * u.m ** -3), {\"ion\": \"He\"}, ValueError),\n            (\n                (np.array([5, 6, 7]) * u.T, np.array([5, 6]) * u.m ** -3),\n                {\"ion\": \"p\"},\n                ValueError,\n            ),\n            (\n                (np.array([0.001, 0.002]) * u.T, np.array([-5e19, 6e19]) * u.m ** -3),\n                {\"ion\": \"p\"},\n                ValueError,\n            ),\n        ],\n    )\n    def test_raises(self, args, kwargs, _error):\n        \"\"\"Test scenarios that raise exceptions or warnings.\"\"\"\n        with pytest.raises(_error):\n            Alfven_speed(*args, **kwargs)\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, expected, isclose_kw, _warning\",\n        [\n            # scenarios that issue RelativityWarning\n            (\n                (5 * u.T, 5e19 * u.m ** -3),\n                {\"ion\": \"H\"},\n                15413707.39,\n                {},\n                RelativityWarning,\n            ),\n            (\n                (5 * u.T, 5e19 * u.m ** -3),\n                {\"ion\": \"H+\"},\n                15413707.39,\n                {\"rtol\": 3.0e-4},\n                RelativityWarning,\n            ),\n            (\n                (5 * u.T, 5e19 * u.m ** -3),\n                {\"ion\": \"p\"},\n                15413707.39,\n                {\"rtol\": 4.0e-4},\n                RelativityWarning,\n            ),\n            #\n            # scenarios that issue UnitsWarning\n            ((0.5, 1.0e18 * u.m ** -3), {\"ion\": \"He\"}, 5470657.93, {}, u.UnitsWarning),\n        ],\n    )\n    def test_warns(self, args, kwargs, expected, isclose_kw, _warning):\n        \"\"\"Test scenarios that issue warnings\"\"\"\n        with pytest.warns(_warning):\n            val = Alfven_speed(*args, **kwargs)\n            assert isinstance(val, u.Quantity)\n            assert val.unit == u.m / u.s\n            assert np.isclose(val.value, expected, **isclose_kw)\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, expected, isclose_kw\",\n        [\n            (\n                (1 * u.T, 1e-8 * u.kg * u.m ** -3),\n                {\"ion\": \"p\"},\n                8920620.58 * u.m / u.s,\n                {\"rtol\": 1e-6},\n            ),\n            (\n                (1 * u.T, 1e-8 * u.kg * u.m ** -3),\n                {},\n                8920620.58 * u.m / u.s,\n                {\"rtol\": 1e-6},\n            ),\n            (\n                (0.05 * u.T, 1e18 * u.m ** -3),\n                {\"ion\": \"He\"},\n                Alfven_speed(0.05 * u.T, 6.64738793e-09 * u.kg * u.m ** -3),\n                {},\n            ),\n            (\n                (0.05 * u.T, 1e18 * u.m ** -3),\n                {\"ion\": \"He+\"},\n                Alfven_speed(0.05 * u.T, 1e18 * u.m ** -3, ion=\"He\"),\n                {\"rtol\": 7e-5},\n            ),\n            (\n                (0.05 * u.T, 1e18 * u.m ** -3),\n                {\"ion\": \"He\", \"z_mean\": 2},\n                Alfven_speed(0.05 * u.T, 1e18 * u.m ** -3, ion=\"He +2\"),\n                {\"rtol\": 1.4e-4},\n            ),\n            (\n                (0.05 * u.T, 1e18 * u.m ** -3),\n                {\"ion\": Particle(\"He+\")},\n                Alfven_speed(0.05 * u.T, 1e18 * u.m ** -3, ion=\"He+\"),\n                {},\n            ),\n            (\n                ([0.001, 0.002] * u.T, 5e-10 * u.kg * u.m ** -3),\n                {},\n                [\n                    va_(0.001 * u.T, 5e-10 * u.kg * u.m ** -3).value,\n                    va_(0.002 * u.T, 5e-10 * u.kg * u.m ** -3).value,\n                ]\n                * (u.m / u.s),\n                {},\n            ),\n            (\n                ([0.001, 0.002] * u.T, [5e-10, 2e-10] * u.kg * u.m ** -3),\n                {},\n                [\n                    va_(0.001 * u.T, 5e-10 * u.kg * u.m ** -3).value,\n                    va_(0.002 * u.T, 2e-10 * u.kg * u.m ** -3).value,\n                ]\n                * (u.m / u.s),\n                {},\n            ),\n            (\n                (0.001 * u.T, [1.0e18, 2e18] * u.m ** -3),\n                {\"ion\": \"p\"},\n                [\n                    va_(0.001 * u.T, 1e18 * u.m ** -3, ion=\"p\").value,\n                    va_(0.001 * u.T, 2e18 * u.m ** -3, ion=\"p\").value,\n                ]\n                * (u.m / u.s),\n                {},\n            ),\n        ],\n    )\n    def test_values(self, args, kwargs, expected, isclose_kw):\n        \"\"\"Test expected values.\"\"\"\n        assert np.allclose(Alfven_speed(*args, **kwargs), expected, **isclose_kw)\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, nan_mask\",\n        [\n            ((np.nan * u.T, 1 * u.kg * u.m ** -3), {}, []),\n            ((0.001 * u.T, np.nan * u.kg * u.m ** -3), {}, []),\n            (([np.nan, 0.001] * u.T, 1 * u.kg * u.m ** -3), {}, [True, False]),\n            (\n                (0.001 * u.T, [np.nan, 1.0, np.nan] * u.kg * u.m ** -3),\n                {},\n                [True, False, True],\n            ),\n            (([np.nan, 0.001] * u.T, [1, np.nan] * u.kg * u.m ** -3), {}, [True, True]),\n            (\n                (0.001 * u.T, [np.nan, 1e18, np.nan] * u.m ** -3),\n                {\"ion\": \"Ar+\"},\n                [True, False, True],\n            ),\n        ],\n    )\n    def test_nan_values(self, args, kwargs, nan_mask):\n        \"\"\"Input scenarios that leat to `numpy.nan` values being returned.\"\"\"\n        val = Alfven_speed(*args, **kwargs)\n        if np.isscalar(val.value):\n            assert np.isnan(val)\n        else:\n            nan_arr = np.isnan(val)\n            assert np.all(nan_arr[nan_mask])\n            assert np.all(np.logical_not(nan_arr[np.logical_not(nan_mask)]))\n\n    def test_handle_nparrays(self):\n        \"\"\"Test for ability to handle numpy array quantities\"\"\"\n        assert_can_handle_nparray(Alfven_speed)\n\n\nclass Test_Ion_Sound_Speed:\n    r\"\"\"Test the ion_sound_speed function in parameters.py.\"\"\"\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, expected, isclose_kw\",\n        [\n            (\n                (),\n                {\n                    \"T_i\": 1.3232 * u.MK,\n                    \"T_e\": 1.831 * u.MK,\n                    \"ion\": \"p\",\n                    \"gamma_e\": 1,\n                    \"gamma_i\": 3,\n                },\n                218816.06086407552 * (u.m / u.s),\n                {},\n            ),\n            (\n                (1.831 * u.MK, 1.3232 * u.MK, \"p\"),\n                {},\n                218816.06086407552 * (u.m / u.s),\n                {},\n            ),  # Test that function call without keyword argument works correctly\n            (\n                (),\n                {\n                    \"T_i\": 1.3232 * u.MK,\n                    \"T_e\": 1.831 * u.MK,\n                    \"n_e\": n_e,\n                    \"k\": k_1,\n                    \"ion\": \"p\",\n                    \"gamma_e\": 1,\n                    \"gamma_i\": 3,\n                },\n                218816.06086407552 * (u.m / u.s),\n                {},\n            ),\n            (\n                (),\n                {\n                    \"T_i\": 1.3232 * u.MK,\n                    \"T_e\": 1.831 * u.MK,\n                    \"n_e\": n_e,\n                    \"k\": k_2,\n                    \"ion\": \"p\",\n                    \"gamma_e\": 1,\n                    \"gamma_i\": 3,\n                },\n                552.3212936293337 * (u.m / u.s),\n                {},\n            ),\n            (\n                (),\n                {\n                    \"T_i\": 0.88 * u.MK,\n                    \"T_e\": 1.28 * u.MK,\n                    \"n_e\": n_e,\n                    \"k\": 0 * u.m ** -1,\n                    \"ion\": \"p\",\n                    \"gamma_e\": 1.2,\n                    \"gamma_i\": 3.4,\n                },\n                193328.52857788358 * (u.m / u.s),\n                {},\n            ),\n            (\n                (),\n                {\"T_i\": T_i, \"T_e\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p+\"},\n                ion_sound_speed(T_i=T_i, T_e=0 * u.K, n_e=n_e, k=k_1, ion=\"p+\").value\n                * (u.m / u.s),\n                {},\n            ),\n            (\n                (),\n                {\n                    \"T_e\": 1.2e6 * u.K,\n                    \"T_i\": 0 * u.K,\n                    \"n_e\": n_e,\n                    \"k\": 0 * u.m ** -1,\n                    \"z_mean\": 0.8,\n                    \"ion\": \"p\",\n                },\n                89018.09 * (u.m / u.s),\n                {\"atol\": 0.0, \"rtol\": 1e-6},\n            ),  # testing for user input z_mean\n        ],\n    )\n    def test_values(self, args, kwargs, expected, isclose_kw):\n        assert np.isclose(ion_sound_speed(*args, **kwargs), expected, **isclose_kw)\n\n    # case when Z=1 is assumed\n    # assert ion_sound_speed(T_i=T_i, T_e=T_e, ion='p+') == ion_sound_speed(T_i=T_i, T_e=T_e,\n    # ion='H-1')\n\n    @pytest.mark.parametrize(\n        \"kwargs1, kwargs2, _warning\",\n        [\n            ({\"T_i\": T_i, \"T_e\": T_e, \"n_e\": n_e, \"ion\": \"p\"}, {}, PhysicsWarning),\n            ({\"T_i\": T_i, \"T_e\": T_e, \"k\": k_1, \"ion\": \"p\"}, {}, PhysicsWarning),\n            ({\"T_i\": 5e11 * u.K, \"T_e\": 0 * u.K, \"ion\": \"p\"}, {}, RelativityWarning),\n            (\n                {\"T_e\": 1.2e6, \"T_i\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"},\n                {\"T_e\": 1.2e6 * u.K, \"T_i\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"},\n                u.UnitsWarning,\n            ),\n            (\n                {\"T_i\": 1.3e6, \"T_e\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"},\n                {\"T_i\": 1.3e6 * u.K, \"T_e\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"},\n                u.UnitsWarning,\n            ),\n        ],\n    )\n    def test_warns(self, kwargs1, kwargs2, _warning):\n        with pytest.warns(_warning):\n            val = ion_sound_speed(**kwargs1)\n            if kwargs2 != {}:\n                val == ion_sound_speed(**kwargs2)\n\n    @pytest.mark.parametrize(\n        \"args, kwargs, _error\",\n        [\n            (\n                (),\n                {\n                    \"T_i\": T_i,\n                    \"T_e\": T_e,\n                    \"n_e\": n_e,\n                    \"k\": k_1,\n                    \"ion\": \"p\",\n                    \"gamma_i\": np.inf,\n                },\n                RelativityError,\n            ),\n            (\n                (),\n                {\n                    \"T_i\": np.array([5, 6, 5]) * u.K,\n                    \"T_e\": np.array([3, 4]) * u.K,\n                    \"n_e\": np.array([5, 6, 5]) * u.m ** -3,\n                    \"k\": np.array([3, 4]) * u.m ** -3,\n                    \"ion\": \"p\",\n                },\n                u.UnitTypeError,\n            ),\n            ((5 * u.T), {\"ion\": \"p\"}, TypeError),  # Is this test right??????\n            ((), {\"ion\": \"p\"}, TypeError),\n            (\n                (),\n                {\"T_i\": T_i, \"T_e\": 0 * u.K, \"gamma_i\": 0.9999, \"ion\": \"p\"},\n                PhysicsError,\n            ),\n            (\n                (),\n                {\"T_i\": T_i, \"T_e\": 0 * u.K, \"gamma_e\": 0.9999, \"ion\": \"p\"},\n                PhysicsError,\n            ),\n            (\n                (),\n                {\"T_i\": T_i, \"T_e\": 0 * u.K, \"gamma_e\": \"sdjklsf\", \"ion\": \"p\"},\n                TypeError,\n            ),\n            (\n                (),\n                {\"T_i\": T_i, \"T_e\": 0 * u.K, \"gamma_i\": \"fsdfas\", \"ion\": \"p\"},\n                TypeError,\n            ),\n            ((), {\"T_i\": T_i, \"T_e\": 0 * u.K, \"ion\": \"cupcakes\"}, InvalidParticleError),\n            ((), {\"T_i\": -np.abs(T_i), \"T_e\": 0 * u.K, \"ion\": \"p\"}, ValueError),\n            (\n                (),\n                {\"T_i\": T_i, \"T_e\": 0 * u.K, \"n_e\": -np.abs(n_e), \"k\": k_1, \"ion\": \"p\"},\n                ValueError,\n            ),\n            (\n                (),\n                {\"T_i\": T_i, \"T_e\": 0 * u.K, \"n_e\": n_e, \"k\": -np.abs(k_1), \"ion\": \"p\"},\n                ValueError,\n            ),\n            ((), {\"T_i\": 5e19 * u.K, \"T_e\": 0 * u.K, \"ion\": \"p\"}, RelativityError),\n            (\n                (),\n                {\"T_i\": 5 * u.A, \"T_e\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"},\n                u.UnitTypeError,\n            ),\n            (\n                (),\n                {\"T_i\": T_negarr, \"T_e\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"},\n                ValueError,\n            ),\n            (\n                (),\n                {\"T_e\": T_negarr, \"T_i\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"},\n                ValueError,\n            ),\n        ],\n    )\n    def test_raises(self, args, kwargs, _error):\n        with pytest.raises(_error):\n            ion_sound_speed(*args, **kwargs)\n\n    @pytest.mark.parametrize(\n        \"kwargs\",\n        [\n            ({\"T_i\": T_nanarr, \"T_e\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"}),\n            ({\"T_e\": T_nanarr, \"T_i\": 0 * u.K, \"n_e\": n_e, \"k\": k_1, \"ion\": \"p\"}),\n        ],\n    )\n    def test_nan_values(self, kwargs):\n        np.isnan(ion_sound_speed(**kwargs)[1])\n\n    def test_handle_nparrays(self):\n        assert_can_handle_nparray(ion_sound_speed)\n\n\ndef test_thermal_pressure():\n    assert thermal_pressure(T_e, n_i).unit.is_equivalent(u.Pa)\n\n    # TODO: may be array issues with arg \"mass\"\n    assert_can_handle_nparray(thermal_pressure)\n\n\ndef test_gyrofrequency():\n    r\"\"\"Test the gyrofrequency function in parameters.py.\"\"\"\n\n    assert gyrofrequency(B, \"e-\").unit.is_equivalent(u.rad / u.s)\n\n    assert gyrofrequency(B, \"e-\", to_hz=True).unit.is_equivalent(u.Hz)\n\n    assert np.isclose(gyrofrequency(1 * u.T, \"e-\").value, 175882008784.72018)\n\n    assert np.isclose(gyrofrequency(2.4 * u.T, \"e-\").value, 422116821083.3284)\n\n    assert np.isclose(\n        gyrofrequency(1 * u.T, \"e-\", to_hz=True).value, 27992490076.528206\n    )\n\n    assert np.isclose(\n        gyrofrequency(2.4 * u.T, \"e-\", signed=True).value, -422116821083.3284\n    )\n\n    assert np.isclose(gyrofrequency(1 * u.G, \"e-\").cgs.value, 1.76e7, rtol=1e-3)\n\n    with pytest.raises(TypeError):\n        with pytest.warns(u.UnitsWarning):\n            gyrofrequency(u.m, \"e-\")\n\n    with pytest.raises(u.UnitTypeError):\n        gyrofrequency(u.m * 1, \"e-\")\n\n    assert np.isnan(gyrofrequency(B_nanarr, \"e-\")[-1])\n\n    # The following is a test to check that equivalencies from astropy\n    # are working.\n    omega_ce = gyrofrequency(2.2 * u.T, \"e-\")\n    f_ce = (omega_ce / (2 * np.pi)) / u.rad\n    f_ce_use_equiv = omega_ce.to(u.Hz, equivalencies=[(u.cy / u.s, u.Hz)])\n    assert np.isclose(f_ce.value, f_ce_use_equiv.value)\n\n    with pytest.warns(u.UnitsWarning):\n        assert gyrofrequency(5.0, \"e-\") == gyrofrequency(5.0 * u.T, \"e-\")\n\n    assert gyrofrequency(B, particle=ion).unit.is_equivalent(u.rad / u.s)\n\n    assert np.isclose(gyrofrequency(1 * u.T, particle=\"p\").value, 95788335.834874)\n\n    assert np.isclose(gyrofrequency(2.4 * u.T, particle=\"p\").value, 229892006.00369796)\n\n    assert np.isclose(gyrofrequency(1 * u.G, particle=\"p\").cgs.value, 9.58e3, rtol=2e-3)\n\n    assert gyrofrequency(-5 * u.T, \"p\") == gyrofrequency(5 * u.T, \"p\")\n\n    # Case when Z=1 is assumed\n    # assert gyrofrequency(B, particle='p+') == gyrofrequency(B, particle='H-1')\n\n    assert gyrofrequency(B, particle=\"e+\") == gyrofrequency(B, \"e-\")\n\n    with pytest.warns(u.UnitsWarning):\n        gyrofrequency(8, \"p\")\n\n    with pytest.raises(u.UnitTypeError):\n        gyrofrequency(5 * u.m, \"p\")\n\n    with pytest.raises(InvalidParticleError):\n        gyrofrequency(8 * u.T, particle=\"asdfasd\")\n\n    with pytest.warns(u.UnitsWarning):\n        # TODO this should be WARNS, not RAISES. and it's probably still raised\n        assert gyrofrequency(5.0, \"p\") == gyrofrequency(5.0 * u.T, \"p\")\n\n    gyrofrequency(1 * u.T, particle=\"p\")\n    # testing for user input Z\n    testMeth1 = gyrofrequency(1 * u.T, particle=\"p\", Z=0.8).si.value\n    testTrue1 = 76630665.79318453\n    errStr = f\"gyrofrequency() gave {testMeth1}, should be {testTrue1}.\"\n    assert np.isclose(testMeth1, testTrue1, atol=0.0, rtol=1e-5), errStr\n\n    assert_can_handle_nparray(gyrofrequency, kwargs={\"signed\": True})\n\n    assert_can_handle_nparray(gyrofrequency, kwargs={\"signed\": False})\n\n\ndef test_gyroradius():\n    r\"\"\"Test the gyroradius function in parameters.py.\"\"\"\n\n    assert gyroradius(B, \"e-\", T=T_e).unit.is_equivalent(u.m)\n\n    assert gyroradius(B, \"e-\", Vperp=25 * u.m / u.s).unit.is_equivalent(u.m)\n\n    # test for possiblity to allow nan for input values\n    assert np.isnan(gyroradius(np.nan * u.T, particle=\"e-\", T=1 * u.K))\n    assert np.isnan(gyroradius(1 * u.T, particle=\"e-\", T=np.nan * u.K))\n    assert np.isnan(gyroradius(1 * u.T, particle=\"e-\", Vperp=np.nan * u.m / u.s))\n\n    Vperp = 1e6 * u.m / u.s\n    Bmag = 1 * u.T\n    omega_ce = gyrofrequency(Bmag, \"e-\")\n    analytical_result = (Vperp / omega_ce).to(\n        u.m, equivalencies=u.dimensionless_angles()\n    )\n    assert gyroradius(Bmag, \"e-\", Vperp=Vperp) == analytical_result\n\n    with pytest.raises(TypeError):\n        with pytest.warns(u.UnitsWarning):\n            gyroradius(u.T, \"e-\")\n\n    with pytest.raises(u.UnitTypeError):\n        gyroradius(5 * u.A, \"e-\", Vperp=8 * u.m / u.s)\n\n    with pytest.raises(u.UnitTypeError):\n        gyroradius(5 * u.T, \"e-\", Vperp=8 * u.m)\n\n    with pytest.raises(ValueError):\n        gyroradius(np.array([5, 6]) * u.T, \"e-\", Vperp=np.array([5, 6, 7]) * u.m / u.s)\n\n    assert np.isnan(gyroradius(np.nan * u.T, \"e-\", Vperp=1 * u.m / u.s))\n\n    with pytest.raises(ValueError):\n        gyroradius(3.14159 * u.T, \"e-\", T=-1 * u.K)\n\n    with pytest.warns(u.UnitsWarning):\n        assert gyroradius(1.0, \"e-\", Vperp=1.0) == gyroradius(\n            1.0 * u.T, \"e-\", Vperp=1.0 * u.m / u.s\n        )\n\n    with pytest.warns(u.UnitsWarning):\n        assert gyroradius(1.1, \"e-\", T=1.2) == gyroradius(1.1 * u.T, \"e-\", T=1.2 * u.K)\n\n    with pytest.raises(ValueError):\n        gyroradius(1.1 * u.T, \"e-\", Vperp=1 * u.m / u.s, T=1.2 * u.K)\n\n    with pytest.raises(u.UnitTypeError):\n        gyroradius(1.1 * u.T, \"e-\", Vperp=1.1 * u.m, T=1.2 * u.K)\n\n    # Check for Deprecation warning when using T_i instead of T\n    with pytest.warns(PlasmaPyFutureWarning):\n        gyroradius(1.1 * u.T, \"e-\", T_i=1.2 * u.K)\n\n    assert gyroradius(B, particle=\"p\", T=T_i).unit.is_equivalent(u.m)\n\n    assert gyroradius(B, particle=\"p\", Vperp=25 * u.m / u.s).unit.is_equivalent(u.m)\n\n    # Case when Z=1 is assumed\n    assert np.isclose(\n        gyroradius(B, particle=\"p\", T=T_i),\n        gyroradius(B, particle=\"H+\", T=T_i),\n        atol=1e-6 * u.m,\n    )\n\n    gyroPos = gyroradius(B, particle=\"p\", Vperp=V)\n    gyroNeg = gyroradius(B, particle=\"p\", Vperp=-V)\n    assert gyroPos == gyroNeg\n\n    Vperp = 1e6 * u.m / u.s\n    Bmag = 1 * u.T\n    omega_ci = gyrofrequency(Bmag, particle=\"p\")\n    analytical_result = (Vperp / omega_ci).to(\n        u.m, equivalencies=u.dimensionless_angles()\n    )\n    assert gyroradius(Bmag, particle=\"p\", Vperp=Vperp) == analytical_result\n\n    T2 = 1.2 * u.MK\n    B2 = 123 * u.G\n    particle2 = \"alpha\"\n    Vperp2 = thermal_speed(T2, particle=particle2)\n    gyro_by_vperp = gyroradius(B2, particle=\"alpha\", Vperp=Vperp2)\n    assert gyro_by_vperp == gyroradius(B2, particle=\"alpha\", T=T2)\n\n    explicit_positron_gyro = gyroradius(1 * u.T, particle=\"positron\", T=1 * u.MK)\n    assert explicit_positron_gyro == gyroradius(1 * u.T, \"e-\", T=1 * u.MK)\n\n    with pytest.raises(TypeError):\n        with pytest.warns(u.UnitsWarning):\n            gyroradius(u.T, particle=\"p\", Vperp=8 * u.m / u.s)\n\n    with pytest.raises(ValueError):\n        gyroradius(B, particle=\"p\", T=-1 * u.K)\n\n    with pytest.warns(u.UnitsWarning):\n        gyro_without_units = gyroradius(1.0, particle=\"p\", Vperp=1.0)\n        gyro_with_units = gyroradius(1.0 * u.T, particle=\"p\", Vperp=1.0 * u.m / u.s)\n        assert gyro_without_units == gyro_with_units\n\n    with pytest.warns(u.UnitsWarning):\n        gyro_t_without_units = gyroradius(1.1, particle=\"p\", T=1.2)\n        gyro_t_with_units = gyroradius(1.1 * u.T, particle=\"p\", T=1.2 * u.K)\n        assert gyro_t_with_units == gyro_t_without_units\n\n    with pytest.raises(ValueError):\n        gyroradius(1.1 * u.T, particle=\"p\", Vperp=1 * u.m / u.s, T=1.2 * u.K)\n\n    with pytest.raises(u.UnitTypeError):\n        gyroradius(1.1 * u.T, particle=\"p\", Vperp=1.1 * u.m, T=1.2 * u.K)\n\n    with pytest.raises(u.UnitTypeError):\n        gyroradius(1.1 * u.T, particle=\"p\", Vperp=1.2 * u.m, T=1.1 * u.K)\n\n\nclass Test_gyroradius:\n\n    # some custom numpy array tests here, because of the T / Vperp situation\n    def test_handle_numpy_array(self):\n        # Tests to verify that can handle Quantities with numpy array as the value:\n        assert gyroradius(B_arr, \"e-\", Vperp=V_arr)[0] == gyroradius(\n            B_arr[0], \"e-\", Vperp=V_arr[0]\n        )\n        assert gyroradius(B_arr, \"e-\", T=T_arr)[0] == gyroradius(\n            B_arr[0], \"e-\", T=T_arr[0]\n        )\n\n    def test_handle_mixed_Qarrays(self):\n        # If both Vperp or T are input as Qarrays, but only one of the two is valid\n        # at each element, then that's fine, the function should work:\n        assert gyroradius(B_arr, \"e-\", Vperp=V_nanarr, T=T_nanarr2)[0] == gyroradius(\n            B_arr[0], \"e-\", Vperp=V_nanarr[0], T=T_nanarr2[0]\n        )\n\n    def test_raise_two_valid_inputs(self):\n        # If both Vperp or T are nan-less, Qarrays or not, should raise ValueError:\n        with pytest.raises(ValueError):\n            gyroradius(B_arr, \"e-\", Vperp=V, T=T_arr)\n        with pytest.raises(ValueError):\n            gyroradius(B_arr, \"e-\", Vperp=V_arr, T=T_i)\n\n    def test_all_valid_and_one_valid(self):\n        # If one of (Vperp, T) is a valid and one is Qarray with at least one valid, ValueError:\n        with pytest.raises(ValueError):\n            gyroradius(B_arr, \"e-\", Vperp=V, T=T_nanarr)\n        with pytest.raises(ValueError):\n            gyroradius(B_arr, \"e-\", Vperp=V_nanarr, T=T_i)\n\n    def test_scalar_and_nan_qarray(self):\n        # If either Vperp or T is a valid scalar and the other is a Qarray of all nans,\n        # should do something valid and not raise a ValueError\n        assert np.all(np.isfinite(gyroradius(B_arr, \"e-\", Vperp=V, T=T_allnanarr)))\n        assert np.all(np.isfinite(gyroradius(B_arr, \"e-\", Vperp=V_allnanarr, T=T_i)))\n\n    def test_keeps_arguments_unchanged(self):\n        Vperp1 = u.Quantity([np.nan, 1], unit=u.m / u.s)\n        Vperp2 = u.Quantity([np.nan, 1], unit=u.m / u.s)  # an exact copy\n        T_i = u.Quantity([1, np.nan], unit=u.K)\n\n        gyroradius(B_arr, \"e-\", Vperp=Vperp1, T=T_i)\n        assert_quantity_allclose(Vperp1, Vperp2)\n\n\ndef test_plasma_frequency():\n    r\"\"\"Test the plasma_frequency function in parameters.py.\"\"\"\n\n    assert plasma_frequency(n_e, \"e-\").unit.is_equivalent(u.rad / u.s)\n\n    assert plasma_frequency(n_e, \"e-\", to_hz=True).unit.is_equivalent(u.Hz)\n\n    assert np.isclose(plasma_frequency(1 * u.cm ** -3, \"e-\").value, 5.64e4, rtol=1e-2)\n\n    assert np.isclose(\n        plasma_frequency(1 * u.cm ** -3, particle=\"N\").value, 3.53e2, rtol=1e-1\n    )\n\n    assert np.isclose(\n        plasma_frequency(1 * u.cm ** -3, particle=\"N\", to_hz=True).value,\n        56.19000195094519,\n    )\n\n    with pytest.raises(TypeError):\n        with pytest.warns(u.UnitsWarning):\n            plasma_frequency(u.m ** -3, \"e-\")\n\n    with pytest.raises(u.UnitTypeError):\n        plasma_frequency(5 * u.m ** -2, \"e-\")\n\n    assert np.isnan(plasma_frequency(np.nan * u.m ** -3, \"e-\"))\n\n    with pytest.warns(u.UnitsWarning):\n        assert plasma_frequency(1e19, \"e-\") == plasma_frequency(1e19 * u.m ** -3, \"e-\")\n\n        assert plasma_frequency(n_i, particle=\"p\").unit.is_equivalent(u.rad / u.s)\n\n    # Case where Z=1 is assumed\n    assert plasma_frequency(n_i, particle=\"H-1+\") == plasma_frequency(n_i, particle=\"p\")\n\n    assert np.isclose(\n        plasma_frequency(mu * u.cm ** -3, particle=\"p\").value, 1.32e3, rtol=1e-2\n    )\n\n    with pytest.raises(ValueError):\n        plasma_frequency(n=5 * u.m ** -3, particle=\"sdfas\")\n\n    with pytest.warns(u.UnitsWarning):\n        plasma_freq_no_units = plasma_frequency(1e19, particle=\"p\")\n        assert plasma_freq_no_units == plasma_frequency(1e19 * u.m ** -3, particle=\"p\")\n\n    plasma_frequency(1e17 * u.cm ** -3, particle=\"p\")\n    # testing for user input z_mean\n    testMeth1 = plasma_frequency(1e17 * u.cm ** -3, particle=\"p\", z_mean=0.8).si.value\n    testTrue1 = 333063562455.4028\n    errStr = f\"plasma_frequency() gave {testMeth1}, should be {testTrue1}.\"\n    assert np.isclose(testMeth1, testTrue1, atol=0.0, rtol=1e-6), errStr\n\n    assert_can_handle_nparray(plasma_frequency)\n\n\ndef test_Debye_length():\n    r\"\"\"Test the Debye_length function in parameters.py.\"\"\"\n\n    assert Debye_length(T_e, n_e).unit.is_equivalent(u.m)\n\n    assert np.isclose(Debye_length(1 * u.eV, 1 * u.cm ** -3).value, 7.43, atol=0.005)\n\n    with pytest.warns(u.UnitsWarning):\n        Debye_length(5, 5 * u.m ** -3)\n\n    with pytest.raises(u.UnitTypeError):\n        Debye_length(56 * u.kg, 5 * u.m ** -3)\n\n    with pytest.raises(ValueError):\n        Debye_length(5 * u.eV, -5 * u.m ** -3)\n\n    with pytest.raises(ValueError):\n        Debye_length(-45 * u.K, 5 * u.m ** -3)\n\n    Tarr2 = np.array([1, 2]) * u.K\n    narr3 = np.array([1, 2, 3]) * u.m ** -3\n    with pytest.raises(ValueError):\n        Debye_length(Tarr2, narr3)\n\n    with pytest.warns(u.UnitsWarning):\n        assert Debye_length(2.0, 2.0) == Debye_length(2.0 * u.K, 2.0 * u.m ** -3)\n\n    with pytest.warns(u.UnitsWarning):\n        assert Debye_length(2.0 * u.K, 2.0) == Debye_length(2.0, 2.0 * u.m ** -3)\n\n    assert_can_handle_nparray(Debye_length)\n\n\ndef test_Debye_number():\n    r\"\"\"Test the Debye_number function in parameters.py.\"\"\"\n\n    assert Debye_number(T_e, n_e).unit.is_equivalent(u.dimensionless_unscaled)\n\n    T_e_eV = T_e.to(u.eV, equivalencies=u.temperature_energy())\n    assert np.isclose(Debye_number(T_e, n_e).value, Debye_number(T_e_eV, n_e).value)\n\n    assert np.isclose(Debye_number(1 * u.eV, 1 * u.cm ** -3).value, 1720862385.43342)\n\n    with pytest.warns(u.UnitsWarning):\n        Debye_number(T_e, 4)\n\n    with pytest.raises(ValueError):\n        Debye_number(None, n_e)\n\n    with pytest.raises(u.UnitTypeError):\n        Debye_number(5 * u.m, 5 * u.m ** -3)\n\n    with pytest.raises(u.UnitTypeError):\n        Debye_number(5 * u.K, 5 * u.m ** 3)\n\n    with pytest.raises(ValueError):\n        Debye_number(5j * u.K, 5 * u.cm ** -3)\n\n    Tarr2 = np.array([1, 2]) * u.K\n    narr3 = np.array([1, 2, 3]) * u.m ** -3\n    with pytest.raises(ValueError):\n        Debye_number(Tarr2, narr3)\n\n    with pytest.warns(u.UnitsWarning):\n        assert Debye_number(1.1, 1.1) == Debye_number(1.1 * u.K, 1.1 * u.m ** -3)\n\n    with pytest.warns(u.UnitsWarning):\n        assert Debye_number(1.1 * u.K, 1.1) == Debye_number(1.1, 1.1 * u.m ** -3)\n\n    assert_can_handle_nparray(Debye_number)\n\n\ndef test_inertial_length():\n    r\"\"\"Test the inertial_length function in parameters.py.\"\"\"\n\n    assert inertial_length(n_i, particle=\"p\").unit.is_equivalent(u.m)\n\n    assert np.isclose(\n        inertial_length(mu * u.cm ** -3, particle=\"p\").cgs.value, 2.28e7, rtol=0.01\n    )\n\n    inertial_length_electron_plus = inertial_length(5.351 * u.m ** -3, particle=\"e+\")\n    assert inertial_length_electron_plus == inertial_length(\n        5.351 * u.m ** -3, particle=\"e\"\n    )\n\n    assert inertial_length(n_i, particle=\"p\") == inertial_length(n_i, particle=\"p\")\n\n    with pytest.warns(u.UnitsWarning):\n        inertial_length(4, particle=\"p\")\n\n    with pytest.raises(u.UnitTypeError):\n        inertial_length(4 * u.m ** -2, particle=\"p\")\n\n    with pytest.raises(ValueError):\n        inertial_length(-5 * u.m ** -3, particle=\"p\")\n\n    with pytest.raises(InvalidParticleError):\n        inertial_length(n_i, particle=-135)\n\n    with pytest.warns(u.UnitsWarning):\n        inertial_length_no_units = inertial_length(1e19, particle=\"p\")\n        assert inertial_length_no_units == inertial_length(\n            1e19 * u.m ** -3, particle=\"p\"\n        )\n\n    assert inertial_length(n_e, \"e-\").unit.is_equivalent(u.m)\n\n    assert np.isclose(\n        inertial_length(1 * u.cm ** -3, \"e-\").cgs.value, 5.31e5, rtol=1e-3\n    )\n\n    with pytest.warns(u.UnitsWarning):\n        inertial_length(5, \"e-\")\n\n    with pytest.raises(u.UnitTypeError):\n        inertial_length(5 * u.m, \"e-\")\n\n    with pytest.raises(ValueError):\n        inertial_length(-5 * u.m ** -3, \"e-\")\n\n    with pytest.warns(u.UnitsWarning):\n        assert inertial_length(1e19, \"e-\") == inertial_length(1e19 * u.m ** -3, \"e-\")\n\n    assert_can_handle_nparray(inertial_length)\n\n\ndef test_magnetic_pressure():\n    r\"\"\"Test the magnetic_pressure function in parameters.py.\"\"\"\n\n    assert magnetic_pressure(B_arr).unit.is_equivalent(u.Pa)\n\n    assert magnetic_pressure(B).unit.is_equivalent(u.Pa)\n\n    assert magnetic_pressure(B).unit.name == \"Pa\"\n\n    assert magnetic_pressure(B).value == magnetic_energy_density(B).value\n\n    assert magnetic_pressure(B) == magnetic_energy_density(B.to(u.G))\n\n    assert np.isclose(magnetic_pressure(B).value, 397887.35772973835)\n\n    with pytest.warns(u.UnitsWarning):\n        magnetic_pressure(5)\n\n    with pytest.raises(u.UnitTypeError):\n        magnetic_pressure(5 * u.m)\n\n    assert np.isnan(magnetic_pressure(np.nan * u.T))\n\n    with pytest.raises(ValueError):\n        magnetic_pressure(5j * u.T)\n\n    assert np.isnan(magnetic_pressure(B_nanarr)[-1])\n\n    with pytest.warns(u.UnitsWarning):\n        assert magnetic_pressure(22.2) == magnetic_pressure(22.2 * u.T)\n\n    assert_can_handle_nparray(magnetic_pressure)\n\n\ndef test_magnetic_energy_density():\n    r\"\"\"Test the magnetic_energy_density function in parameters.py.\"\"\"\n\n    assert magnetic_energy_density(B_arr).unit.is_equivalent(u.J / u.m ** 3)\n\n    assert magnetic_energy_density(B).unit.is_equivalent(\"J / m3\")\n\n    assert magnetic_energy_density(B).value == magnetic_pressure(B).value\n\n    assert_quantity_allclose(\n        magnetic_energy_density(2 * B), 4 * magnetic_energy_density(B)\n    )\n\n    assert_quantity_allclose(magnetic_energy_density(B).value, 397887.35772973835)\n\n    assert_quantity_allclose(\n        magnetic_energy_density(B), magnetic_energy_density(B.to(u.G))\n    )\n\n    assert isinstance(magnetic_energy_density(B_arr), u.Quantity)\n\n    with pytest.warns(u.UnitsWarning):\n        magnetic_energy_density(5)\n\n    with pytest.raises(u.UnitTypeError):\n        magnetic_energy_density(5 * u.m)\n\n    assert np.isnan(magnetic_energy_density(np.nan * u.T))\n\n    with pytest.raises(ValueError):\n        magnetic_energy_density(5j * u.T)\n\n    assert np.isnan(magnetic_energy_density(B_nanarr)[-1])\n\n    with pytest.warns(u.UnitsWarning):\n        assert magnetic_energy_density(22.2) == magnetic_energy_density(22.2 * u.T)\n\n    assert_can_handle_nparray(magnetic_energy_density)\n\n\ndef test_upper_hybrid_frequency():\n    r\"\"\"Test the upper_hybrid_frequency function in parameters.py.\"\"\"\n\n    omega_uh = upper_hybrid_frequency(B, n_e=n_e)\n    omega_uh_hz = upper_hybrid_frequency(B, n_e=n_e, to_hz=True)\n    omega_ce = gyrofrequency(B, \"e-\")\n    omega_pe = plasma_frequency(n=n_e, particle=\"e-\")\n    assert omega_ce.unit.is_equivalent(u.rad / u.s)\n    assert omega_pe.unit.is_equivalent(u.rad / u.s)\n    assert omega_uh.unit.is_equivalent(u.rad / u.s)\n    assert omega_uh_hz.unit.is_equivalent(u.Hz)\n    left_hand_side = omega_uh ** 2\n    right_hand_side = omega_ce ** 2 + omega_pe ** 2\n    assert np.isclose(left_hand_side.value, right_hand_side.value)\n\n    assert np.isclose(omega_uh_hz.value, 69385868857.90918)\n\n    with pytest.raises(ValueError):\n        upper_hybrid_frequency(5 * u.T, n_e=-1 * u.m ** -3)\n\n    with pytest.warns(u.UnitsWarning):\n        assert upper_hybrid_frequency(1.2, 1.3) == upper_hybrid_frequency(\n            1.2 * u.T, 1.3 * u.m ** -3\n        )\n\n    with pytest.warns(u.UnitsWarning):\n        assert upper_hybrid_frequency(1.4 * u.T, 1.3) == upper_hybrid_frequency(\n            1.4, 1.3 * u.m ** -3\n        )\n\n    assert_can_handle_nparray(upper_hybrid_frequency)\n\n\ndef test_lower_hybrid_frequency():\n    r\"\"\"Test the lower_hybrid_frequency function in parameters.py.\"\"\"\n\n    ion = \"He-4 1+\"\n    omega_ci = gyrofrequency(B, particle=ion)\n    omega_pi = plasma_frequency(n=n_i, particle=ion)\n    omega_ce = gyrofrequency(B, \"e-\")\n    omega_lh = lower_hybrid_frequency(B, n_i=n_i, ion=ion)\n    omega_lh_hz = lower_hybrid_frequency(B, n_i=n_i, ion=ion, to_hz=True)\n    assert omega_ci.unit.is_equivalent(u.rad / u.s)\n    assert omega_pi.unit.is_equivalent(u.rad / u.s)\n    assert omega_ce.unit.is_equivalent(u.rad / u.s)\n    assert omega_lh.unit.is_equivalent(u.rad / u.s)\n    left_hand_side = omega_lh ** -2\n    right_hand_side = (\n        1 / (omega_ci ** 2 + omega_pi ** 2) + omega_ci ** -1 * omega_ce ** -1\n    )\n    assert np.isclose(left_hand_side.value, right_hand_side.value)\n\n    assert np.isclose(omega_lh_hz.value, 299878691.3223296)\n\n    with pytest.raises(ValueError):\n        lower_hybrid_frequency(0.2 * u.T, n_i=5e19 * u.m ** -3, ion=\"asdfasd\")\n\n    with pytest.raises(ValueError):\n        lower_hybrid_frequency(0.2 * u.T, n_i=-5e19 * u.m ** -3, ion=\"asdfasd\")\n\n    with pytest.raises(ValueError):\n        lower_hybrid_frequency(np.nan * u.T, n_i=-5e19 * u.m ** -3, ion=\"asdfasd\")\n\n    with pytest.warns(u.UnitsWarning):\n        assert lower_hybrid_frequency(1.3, 1e19, \"p+\") == lower_hybrid_frequency(\n            1.3 * u.T, 1e19 * u.m ** -3, \"p+\"\n        )\n    assert_can_handle_nparray(lower_hybrid_frequency)\n\n\ndef test_Bohm_diffusion():\n    r\"\"\"Test Mag_Reynolds in dimensionless.py\"\"\"\n\n    T_e = 5000 * u.K\n    B = 10 * u.T\n\n    assert (Bohm_diffusion(T_e, B)).unit == u.m ** 2 / u.s\n\n    with pytest.warns(u.UnitsWarning):\n        Bohm_diffusion(5000, B)\n\n    with pytest.raises(u.UnitTypeError):\n        Bohm_diffusion(2.2 * u.kg, B)\n\n\n@pytest.mark.parametrize(\n    \"alias, parent\",\n    [\n        (rho_, mass_density),\n        (va_, Alfven_speed),\n        (cs_, ion_sound_speed),\n        (pth_, thermal_pressure),\n        (betaH_, Hall_parameter),\n        (oc_, gyrofrequency),\n        (wc_, gyrofrequency),\n        (rc_, gyroradius),\n        (rhoc_, gyroradius),\n        (wp_, plasma_frequency),\n        (lambdaD_, Debye_length),\n        (nD_, Debye_number),\n        (cwp_, inertial_length),\n        (pmag_, magnetic_pressure),\n        (ub_, magnetic_energy_density),\n        (wuh_, upper_hybrid_frequency),\n        (wlh_, lower_hybrid_frequency),\n        (DB_, Bohm_diffusion),\n    ],\n)\ndef test_parameters_aliases(alias, parent):\n    \"\"\"Test all aliases defined in parameters.py\"\"\"\n    assert alias is parent\n    \n    \n\n    \n\n    \n    \n\n    \n\n        \n    :\n    \n\n    .\n\n    :\n    \n    \n\n    .\n    \n\n    (\n    )\n    (\n    :\n\n    \n\n\n    \n\n"
  },
  "feature_stats": {
    "indices": [
      2,
      0,
      4645,
      6994,
      5276,
      7186,
      526,
      5761,
      3073,
      1026,
      4405
    ],
    "f_before": [
      0.0,
      0.2228751927614212,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "f_after": [
      0.0,
      0.2228751927614212,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0
    ],
    "g_before": [
      0.127700537443161,
      0.01853427104651928,
      0.027154549956321716,
      0.019187726080417633,
      0.01792440004646778,
      0.03914615139365196,
      0.05435449630022049,
      0.008707444183528423,
      0.013446015305817127,
      0.01761634461581707,
      0.06305938214063644
    ],
    "g_after": [
      0.127700537443161,
      0.01853427104651928,
      0.027154549956321716,
      0.019187726080417633,
      0.01792440004646778,
      0.03914615139365196,
      0.05435449630022049,
      0.008707444183528423,
      0.013446015305817127,
      0.01761634461581707,
      0.06305938214063644
    ],
    "num_batches_for_stats": 10
  },
  "loss_summary": {
    "train_mean_loss": 8.54353929513693,
    "train_mean_l2": 6.013987733893097,
    "train_mean_l1": 2.5168445214927195,
    "num_steps": 2000,
    "num_batches": 2000
  },
  "feature_std_summary": {
    "plot_path": "outputs/plots/20251128-010452/feature_std_layer_12.html",
    "mean_std": 1.0416896343231201,
    "max_std": 30.567893981933594
  }
}